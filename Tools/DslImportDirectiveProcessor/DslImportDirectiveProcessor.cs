#region Public Domain Notice
/**************************************************************************\
* DSL Import Directive Processor for the Neumont Modeling Framework        *
*                                                                          *
* This file is hereby released into the public domain by its author. This  *
* applies worldwide. For countries in which this is not legally possible,  *
* the author grants anyone the right to use this work for any purpose,     *
* without any conditions, unless such conditions are required by law.      *
\**************************************************************************/
#endregion

using System;
using System.Collections.Generic;
using Microsoft.VisualStudio.Modeling.DslDefinition;
using Microsoft.VisualStudio.TextTemplating;

namespace Neumont.Tools.Modeling
{
	public class DslImportDirectiveProcessor : DslDirectiveProcessorBase
	{
		public const string DslImportDirectiveProcessorName = "DslImportDirectiveProcessor";

		protected override string FriendlyName
		{
			get
			{
				return DslImportDirectiveProcessorName;
			}
		}

		public override void StartProcessingRun(System.CodeDom.Compiler.CodeDomProvider languageProvider, string templateContents, System.CodeDom.Compiler.CompilerErrorCollection errors)
		{
			base.StartProcessingRun(languageProvider, templateContents, errors);

			Dictionary<string, string> requiresArguments = new Dictionary<string, string>(2, StringComparer.OrdinalIgnoreCase);
			base.InitializeRequiresDictionary("Dsl", requiresArguments);
			Dictionary<string, string> providesArguments = new Dictionary<string, string>(1, StringComparer.OrdinalIgnoreCase);
			base.InitializeProvidesDictionary("Dsl", providesArguments);

			// Call base.GenerateTransformCode once so that oneTimeCodeGenerated gets set to true (which prevents the
			// "ConvertDslLibraryRelativePathToTemplateRelativePath" method from being generated later when GenerateTransformCode
			// is called "for real." If it were generated, it would conflict with the one generated by DslDirectiveProcessor.
			base.GenerateTransformCode("Dsl", new System.Text.StringBuilder(), languageProvider, requiresArguments, providesArguments);
		}

		protected override void GeneratePreInitializationCode(string directiveName, System.Text.StringBuilder codeBuffer, System.CodeDom.Compiler.CodeDomProvider languageProvider, IDictionary<string, string> requiresArguments, IDictionary<string, string> providesArguments)
		{
			// Do nothing, and don't call the base implementation.
			// This prevents the calls to AddDomainModel from being generated.
			// These extra calls don't actually hurt anything, but they aren't necessary.
		}

		public override string GetPostInitializationCodeForProcessingRun()
		{
			// Wrap everything we (and the regular DslDirectiveProcessor) do in a single transaction.
			// This is necessary so that the Monikers for each model loaded remain available to the rest of the models loaded after it.
			return "using (Microsoft.VisualStudio.Modeling.Transaction outerDslImportTransaction = this.Store.TransactionManager.BeginTransaction(\"Load Files\", true)) { " + base.GetPostInitializationCodeForProcessingRun();
		}
	}

	public class DslImportEndDirectiveProcessor : DirectiveProcessor
	{
		public override string GetPostInitializationCodeForProcessingRun()
		{
			// Commit the transaction started in DslImportDirectiveProcessor.GetPostInitializationCodeForProcessingRun,
			// and close the 'using' block.
			return " outerDslImportTransaction.Commit(); }";
		}

		#region Does nothing
		public override void FinishProcessingRun()
		{
			// Do nothing
		}
		public override string GetClassCodeForProcessingRun()
		{
			return string.Empty;
		}
		public override string[] GetImportsForProcessingRun()
		{
			return new string[0];
		}
		public override string GetPreInitializationCodeForProcessingRun()
		{
			return string.Empty;
		}
		public override string[] GetReferencesForProcessingRun()
		{
			return new string[0];
		}
		public override bool IsDirectiveSupported(string directiveName)
		{
			return string.Equals(directiveName, "Dsl", StringComparison.OrdinalIgnoreCase);
		}
		public override void ProcessDirective(string directiveName, IDictionary<string, string> arguments)
		{
			// Do nothing
		}
		#endregion
	}
}

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Text;
using System.Text.RegularExpressions;
using Microsoft.VisualStudio.Modeling;
using Neumont.Tools.ORM.ObjectModel;
using Neumont.Tools.ORMAbstraction;
using Neumont.Tools.ORMToORMAbstractionBridge;
using Neumont.Tools.RelationalModels.ConceptualDatabase;
using ORMCore = Neumont.Tools.ORM.ObjectModel;
using CasingOption = Neumont.Tools.ORM.ObjectModel.NameGeneratorCasingOption;
using DslModeling = global::Microsoft.VisualStudio.Modeling;

namespace Neumont.Tools.ORMAbstractionToConceptualDatabaseBridge
{
	#region IDatabaseNameGenerator interface
	/// <summary>
	/// Generate relational names for elements contained in a <see cref="Schema"/>
	/// </summary>
	public interface IDatabaseNameGenerator
	{
		/// <summary>
		/// Generate a name for the provided <paramref name="table"/>
		/// </summary>
		/// <param name="table">A <see cref="Table"/> element</param>
		/// <param name="longerThan">Generate a more specific name than provided.
		/// If this is set, then the passed in name will have been generated by
		/// this method on this instance. Can be <see langword="null"/></param>
		/// <returns>A name for <paramref name="table"/>.</returns>
		string GenerateTableName(Table table, string longerThan);
		/// <summary>
		/// Generate a name for the provided <paramref name="column"/>
		/// </summary>
		/// <param name="column">A <see cref="Column"/> element</param>
		/// <param name="longerThan">Generate a more specific name than provided.
		/// If this is set, then the passed in name will have been generated by
		/// this method on this instance. Can be <see langword="null"/></param>
		/// <returns>A name for <paramref name="column"/>.</returns>
		string GenerateColumnName(Column column, string longerThan);
		/// <summary>
		/// Generate a name for the provided <paramref name="constraint"/>
		/// </summary>
		/// <param name="constraint">A <see cref="Constraint"/> element</param>
		/// <param name="longerThan">Generate a more specific name than provided.
		/// If this is set, then the passed in name will have been generated by
		/// this method on this instance. Can be <see langword="null"/></param>
		/// <returns>A name for <paramref name="constraint"/>.</returns>
		string GenerateConstraintName(Constraint constraint, string longerThan);
	}
	#endregion // IDatabaseNameGenerator interface
	#region NamePart struct
	/// <summary>
	/// Options used with the <see cref="NamePart"/> structure
	/// </summary>
	[Flags]
	public enum NamePartOptions
	{
		/// <summary>
		/// No special options
		/// </summary>
		None = 0,
		/// <summary>
		/// The element should not be cased
		/// </summary>
		ExplicitCasing = 1,
	}
	/// <summary>
	/// A callback delegate for adding a <see cref="NamePart"/>
	/// </summary>
	/// <param name="part">The <see cref="NamePart"/> to add</param>
	/// <param name="insertIndex">The index to insert the name part at.</param>
	public delegate void AddNamePart(NamePart part, int? insertIndex);
	/// <summary>
	/// Represent a single string with options
	/// </summary>
	public struct NamePart
	{
		private string myString;
		private NamePartOptions myOptions;
		/// <summary>
		/// Create a new NamePart with default options
		/// </summary>
		/// <param name="value">The string value for this <see cref="NamePart"/></param>
		public NamePart(string value)
		{
			myString = value;
			myOptions = NamePartOptions.None;
		}
		/// <summary>
		/// Create a new NamePart with explicit options
		/// </summary>
		/// <param name="value">The string value for this <see cref="NamePart"/></param>
		/// <param name="options">Values from <see cref="NamePartOptions"/></param>
		public NamePart(string value, NamePartOptions options)
		{
			myString = value;
			myOptions = options;
		}
		/// <summary>
		/// Is the structure populated?
		/// </summary>
		public bool IsEmpty
		{
			get
			{
				return string.IsNullOrEmpty(myString);
			}
		}
		/// <summary>
		/// Return the <see cref="NamePartOptions"/> passed to the constructor
		/// </summary>
		public NamePartOptions Options
		{
			get
			{
				return myOptions;
			}
		}
		/// <summary>
		/// If <see langword="true"/>, then the casing of the string should not be changed
		/// </summary>
		public bool ExplicitCasing
		{
			get
			{
				return 0 != (myOptions & NamePartOptions.ExplicitCasing);
			}
		}
		/// <summary>
		/// Implicitly cast the <see cref="NamePart"/> to its string value
		/// </summary>
		public static implicit operator string(NamePart part)
		{
			return part.myString;
		}
		/// <summary>
		/// Implicitly cast the <see cref="NamePart"/> to its string value
		/// </summary>
		public static implicit operator NamePart(string value)
		{
			return new NamePart(value);
		}
	}
	#endregion // NamePart struct
	#region ORMAbstractionToConceptualDatabaseBridgeDomainModel.NameGeneration class
	partial class ORMAbstractionToConceptualDatabaseBridgeDomainModel
	{
		private static class NameGeneration
		{
			#region GenerateAllNames method
			private static IDatabaseNameGenerator myNameGenerator;
			private static IDatabaseNameGenerator NameGenerator
			{
				get
				{
					IDatabaseNameGenerator retVal = myNameGenerator;
					if (null == retVal)
					{
						myNameGenerator = retVal = new DefaultDatabaseNameGenerator();
					}
					return retVal;
				}
			}
			public static void GenerateAllNames(Schema schema)
			{
				IDatabaseNameGenerator nameGenerator = NameGenerator;
				UniqueNameGenerator uniqueChecker = new UniqueNameGenerator();

				LinkedElementCollection<Table> tables = schema.TableCollection;

				// Generate table names
				uniqueChecker.GenerateUniqueElementNames(
					tables,
					delegate(object element, string longerThan)
					{
						return nameGenerator.GenerateTableName((Table)element, longerThan);
					},
					delegate(object element, string longerThan)
					{
						((Table)element).Name = longerThan;
					});

				foreach (Table table in tables)
				{
					//column names
					uniqueChecker.GenerateUniqueElementNames(
						table.ColumnCollection,
						delegate(object element, string longerThan)
						{
							return nameGenerator.GenerateColumnName((Column)element, longerThan);
						},
						delegate(object element, string longerThan)
						{
							((Column)element).Name = longerThan;
						});

					//constraint names
					LinkedElementCollection<ReferenceConstraint> constraints;
					if (0 != (constraints = table.ReferenceConstraintCollection).Count)
					{
						uniqueChecker.GenerateUniqueElementNames(
							constraints,
							delegate(object element, string longerThan)
							{
								return nameGenerator.GenerateConstraintName((Constraint)element, longerThan);
							},
							delegate(object element, string longerThan)
							{
								((Constraint)element).Name = longerThan;
							});
					}
				}
			}
			#endregion // GenerateAllNames method
			#region Unique name generation algorithm
			/// <summary>
			/// Generate a candidate name for the given <paramref name="element"/>
			/// </summary>
			/// <param name="element">The element to generate a candidate name for</param>
			/// <param name="longerThan">A previously generated name. Generate a longer form of the name. Generate a shorter name if this is null.</param>
			/// <returns>The candidate name, or <see langword="null"/> if a longer name is not available.</returns>
			private delegate string GenerateCandidateElementNameCallback(object element, string longerThan);
			/// <summary>
			/// Set the name for the given element. Used by GenerateUniqueElementNames
			/// </summary>
			private delegate void SetElementNameCallback(object element, string elementName);
			private struct UniqueNameGenerator
			{
				#region ElementNode class
				/// <summary>
				/// A linked list node class. LinkedList{} is too hard to modify during iteration,
				/// and a LinkedListNode{} requires a LinkedList, so we rolled our own.
				/// </summary>
				private class ElementNode
				{
					private object myElement;
					private ElementNode myNext;
					private ElementNode myPrev;
					public ElementNode(object element)
					{
						myElement = element;
					}
					/// <summary>
					/// Set the next element
					/// </summary>
					/// <param name="next">Next element. If next has a previous element, then the head of the next element is inserted.</param>
					/// <param name="head">Reference to head node</param>
					public void SetNext(ElementNode next, ref ElementNode head)
					{
						Debug.Assert(next != null);
						if (next.myPrev != null)
						{
							next.myPrev.SetNext(GetHead(), ref head);
							return;
						}
						if (myNext != null)
						{
							myNext.myPrev = next.GetTail();
						}
						if (myPrev == null)
						{
							head = this;
						}
						myNext = next;
						next.myPrev = this;
					}
					/// <summary>
					/// The element passed to the constructor
					/// </summary>
					public object Element
					{
						get
						{
							return myElement;
						}
					}
					/// <summary>
					/// Get the next node
					/// </summary>
					public ElementNode Next
					{
						get
						{
							return myNext;
						}
					}
					/// <summary>
					/// Get the previous node
					/// </summary>
					public ElementNode Previous
					{
						get
						{
							return myPrev;
						}
					}
					/// <summary>
					/// Get the head element in the linked list
					/// </summary>
					public ElementNode GetHead()
					{
						ElementNode retVal = this;
						ElementNode prev;
						while (null != (prev = retVal.myPrev))
						{
							retVal = prev;
						}
						return retVal;
					}
					/// <summary>
					/// Get the tail element in the linked list
					/// </summary>
					public ElementNode GetTail()
					{
						ElementNode retVal = this;
						ElementNode next;
						while (null != (next = retVal.myNext))
						{
							retVal = next;
						}
						return retVal;
					}
					/// <summary>
					/// Detach the current node
					/// </summary>
					/// <param name="headNode"></param>
					public void Detach(ref ElementNode headNode)
					{
						if (myPrev == null)
						{
							headNode = myNext;
						}
						else
						{
							myPrev.myNext = myNext;
						}
						if (myNext != null)
						{
							myNext.myPrev = myPrev;
						}
						myNext = null;
						myPrev = null;
					}
				}
				#endregion // ElementNode class
				#region Fields
				/// <summary>
				/// Map already generated names into a dictionary that contains either one of the element
				/// objects or a linked list of objects. Linked lists contain duplicate nodes
				/// </summary>
				private Dictionary<string, object> myNameMappingDictionary;
				/// <summary>
				/// A dictionary of unresolved names, corresponds to keys in the nameMappingDictionary
				/// </summary>
				Dictionary<string, string> myUnresolvedNames;
				#endregion // Fields
				#region Public methods
				public void GenerateUniqueElementNames(IEnumerable elements, GenerateCandidateElementNameCallback generateName, SetElementNameCallback setName)
				{
					if (myNameMappingDictionary != null)
					{
						myNameMappingDictionary.Clear();
					}
					else
					{
						myNameMappingDictionary = new Dictionary<string, object>();
					}
					if (myUnresolvedNames != null)
					{
						myUnresolvedNames.Clear();
					}
					// Generate initial names
					foreach (object element in elements)
					{
						string elementName = generateName(element, null);
						if (elementName != null)
						{
							AddElement(element, elementName);
						}
					}

					Dictionary<string, object> nameMappingDictionary = myNameMappingDictionary;
					while (myUnresolvedNames != null && 0 != myUnresolvedNames.Count)
					{
						// Walk the existing unresolved names and attempt to resolve them further.
						// Iterate until we can't resolve any more
						Dictionary<string, string> unresolvedNames = myUnresolvedNames;
						myUnresolvedNames = null;

						foreach (string currentName in unresolvedNames.Values)
						{
							// If we've added this name as unresolved during this pass, then take it back out
							// We'll a
							if (myUnresolvedNames != null && myUnresolvedNames.ContainsKey(currentName))
							{
								myUnresolvedNames.Remove(currentName);
							}
							ElementNode startHeadNode = (ElementNode)nameMappingDictionary[currentName];
							ElementNode headNode = startHeadNode;
							ElementNode nextNode = headNode;
							while (nextNode != null)
							{
								ElementNode currentNode = nextNode;
								nextNode = currentNode.Next;

								object element = currentNode.Element;
								string newName = generateName(element, currentName);
								// Name generation can return null if the longerThan condition cannot be satisfied
								if (newName != null && newName.Length > currentName.Length)
								{
									currentNode.Detach(ref headNode);
									// UNDONE: Is it worth reusing the old node?
									AddElement(element, newName);
								}
							}

							// Manage the remains of the list in the dictionary
							if (headNode == null)
							{
								// Everything detached from this name, remove the key
								nameMappingDictionary.Remove(currentName);
							}
							else if (headNode != startHeadNode)
							{
								nameMappingDictionary[currentName] = headNode;
							}
						}
					}

					// Walk the set, appending additional numbers as needed, and set the names
					foreach (KeyValuePair<string, object> pair in nameMappingDictionary)
					{
						object element = pair.Value;
						ElementNode node = element as ElementNode;
						if (node != null)
						{
							// We added these in reverse order, so walk backwards to number them
							ElementNode tail = node.GetTail();
							if (node == tail)
							{
								setName(node.Element, pair.Key);
							}
							else
							{
								// We need to resolve further
								string baseName = pair.Key;
								int currentIndex = 0;
								ElementNode nextNode = tail;
								while (nextNode != null)
								{
									element = nextNode.Element;
									nextNode = nextNode.Previous; // We started at the tail, walk backwards

									string candidateName;
									do
									{
										++currentIndex;
										candidateName = baseName + currentIndex.ToString();
									} while (nameMappingDictionary.ContainsKey(candidateName));

									// If we get out of the loop, then we finally have a unique name
									setName(element, candidateName);
								}
							}
						}
						else
						{
							setName(element, pair.Key);
						}
					}
				}
				#endregion // Public methods
				#region Helper methods
				private void AddElement(object element, string elementName)
				{
					object existing;
					Dictionary<string, object> nameMappingDictionary = myNameMappingDictionary;
					if (nameMappingDictionary.TryGetValue(elementName, out existing))
					{
						// Note: We use LinkedListNode here directly instead of a LinkedList
						// to facilitate dynamically adding/removing elements during iteration
						ElementNode node = existing as ElementNode;
						if (node == null)
						{
							// Record the unresolvedName
							if (myUnresolvedNames == null)
							{
								myUnresolvedNames = new Dictionary<string, string>();
							}
							myUnresolvedNames[elementName] = elementName;

							// Create a node for the original element
							node = new ElementNode(existing);
						}

						ElementNode newNode = new ElementNode(element);
						newNode.SetNext(node, ref node);
						nameMappingDictionary[elementName] = newNode;
					}
					else
					{
						nameMappingDictionary[elementName] = element;
					}
				}
				#endregion // Helper methods
			}
			#endregion // Unique name generation algorithm
			#region DefaultDatabaseNameGenerator class
			private class DefaultDatabaseNameGenerator : IDatabaseNameGenerator
			{
				#region IDatabaseNameGenerator Members
				string IDatabaseNameGenerator.GenerateTableName(Table table, string longerThan)
				{
					return GenerateTableName(table, longerThan);
				}
				string IDatabaseNameGenerator.GenerateColumnName(Column column, string longerThan)
				{
					return GenerateColumnName(column, longerThan);
				}
				string IDatabaseNameGenerator.GenerateConstraintName(Constraint constraint, string longerThan)
				{
					return GenerateConstraintName(constraint, longerThan);
				}
				#endregion
				private static Regex myReplaceFieldsPattern;
				private string GenerateTableName(Table table, string longerThan)
				{
					NamePart singleName = default(NamePart);
					List<NamePart> nameCollection = null;
					AddToNameCollection(ref singleName, ref nameCollection, TableIsPrimarilyForConceptType.GetConceptType(table).Name);

					#region UNDONE: Need to be separated out of this method as this exact code is used in other methods
					CasingOption tableCase = ORMCore.NameGenerator.GetGenerator(table.Store, typeof(RelationalNameGenerator), typeof(TableNameUsage)).CasingOption;
					string tableSpace = "";

					switch (ORMCore.NameGenerator.GetGenerator(table.Store, typeof(RelationalNameGenerator), typeof(TableNameUsage)).SpacingFormat)
					{
						case NameGeneratorSpacingFormat.Remove:
							tableSpace = "";
							break;
						case NameGeneratorSpacingFormat.ReplaceWith:
							tableSpace = ORMCore.NameGenerator.GetGenerator(table.Store, typeof(RelationalNameGenerator), typeof(TableNameUsage)).SpacingReplacement;
							break;
						case NameGeneratorSpacingFormat.Retain:
							tableSpace = " ";
							break;
					} 
					#endregion
					
					string finalName = GetFinalName(singleName, nameCollection, tableSpace, tableCase);
					if (NeedLongerName(finalName, longerThan))
					{
						return null;
					}
					else
					{
						return finalName;
					}
				}
				private string GenerateColumnName(Column column, string longerThan)
				{
					#region UNDONE: Need to be separated out of this method as this exact code is used in other methods
					// UNDONE: use these two varables to reflect preference customization 
					CasingOption columnCase = ORMCore.NameGenerator.GetGenerator(column.Store, typeof(RelationalNameGenerator), typeof(ColumnNameUsage)).CasingOption; // CasingOption.Camel;
					string columnSpace = "";

					switch (ORMCore.NameGenerator.GetGenerator(column.Store, typeof(RelationalNameGenerator), typeof(ColumnNameUsage)).SpacingFormat)
					{
						case NameGeneratorSpacingFormat.Remove:
							columnSpace = "";
							break;
						case NameGeneratorSpacingFormat.ReplaceWith:
							columnSpace = ORMCore.NameGenerator.GetGenerator(column.Store, typeof(RelationalNameGenerator), typeof(ColumnNameUsage)).SpacingReplacement;
							break;
						case NameGeneratorSpacingFormat.Retain:
							columnSpace = " ";
							break;
					}
					#endregion

					//the string is used when possible to avoid using the list for a single entry
					NamePart singleName = default(NamePart);
					List<NamePart> nameCollection = null;
					AddNamePart addPart = delegate(NamePart newPart, int? insertIndex)
						{
							AddToNameCollection(ref singleName, ref nameCollection, newPart, insertIndex.HasValue ? insertIndex.Value : -1);
						};
					LinkedElementCollection<ConceptTypeChild> path = ColumnHasConceptTypeChild.GetConceptTypeChildPath(column);
					int pathCount = path.Count;
					if (pathCount < 1)
					{
						//if we dont have a path, there is nothing we can do
						addPart(column.Name, null);
					}
					else
					{
						ConceptTypeChild link = null;
						//this is used so that only the leaf subtype node is collected by default
						bool hasSubtypeNode = false;
						FactType mainFactType = null;
						//find the first non subtype fact type
						for (int i = 0; i < pathCount; ++i)
						{
							link = path[i];
							LinkedElementCollection<FactType> factTypes = ConceptTypeChildHasPathFactType.GetPathFactTypeCollection(link);
							if (factTypes.Count < 1)
							{
								continue;
							}
							FactType firstFactType = factTypes[0];
							if (null == mainFactType)
							{
								mainFactType = firstFactType;
							}
							if (firstFactType is SubtypeFact)
							{
								if (!hasSubtypeNode)
								{
									//add the subtype name
									addPart(((ConceptType)link.Target).Name, null);
									hasSubtypeNode = true;
								}
								if (mainFactType == firstFactType)
								{
									mainFactType = null;
								}
							}
							if (hasSubtypeNode && null != mainFactType)
							{
								break;
							}
						}

						if (null == mainFactType)
						{
							//not much we can really do if there are no non subtype fact types
							addPart(link.Name, null);
						}
						else
						{
							RoleBase towardsRole = FactTypeMapsTowardsRole.GetTowardsRole(mainFactType);
							Objectification objectification = mainFactType.ImpliedByObjectification;
							//use the main fact type to determine if this column is part of the primary identifier
							if (null == objectification && IsPreferredIdentifierFactType(mainFactType, towardsRole))
							{
								//for primary identifier columns, just use the name of the value type
								GetEndNodeValueType(path, pathCount, addPart);
							}
							else
							{
								RoleBase oppositeRole = towardsRole.OppositeRole;
								bool createRoleNameSecond = false;
								if (null != objectification)
								{
									//get the nested fact type and its towards role as they should provide more logical names
									mainFactType = objectification.NestedFactType;
									oppositeRole = towardsRole.OppositeRoleAlwaysResolveProxy.Role;
									towardsRole = oppositeRole.Role.OppositeRoleResolveProxy;
									//used for second-level name precision later on, if needed
									createRoleNameSecond = true;
								}

								//search the fact type for a role name or relevant hyphen binding
								LinkedElementCollection<RoleBase> factTypeRoles = mainFactType.RoleCollection;
								int? unaryRoleIndex = FactType.GetUnaryRoleIndex(factTypeRoles);
								bool isUnary = unaryRoleIndex.HasValue;
								bool createRoleName = false;
								string roleName = oppositeRole.Role.Name;
								if (StringIsNullOrEmpty(roleName))
								{
									//no role name, look for hyphen binding
									ReadingOrder readingOrder = GetReadingOrder(mainFactType, towardsRole, oppositeRole, isUnary);
									string hyphenBoundRolePlayerName;
									if ((null != readingOrder) &&
										(IsHyphenBound(readingOrder.PrimaryReading, factTypeRoles, oppositeRole, unaryRoleIndex, out hyphenBoundRolePlayerName)))
									{
										//use the hyphen bound name
										AddToNameCollection(ref singleName, ref nameCollection, hyphenBoundRolePlayerName);
									}
									else
									{
										if (isUnary)
										{
											RoleBase unaryRole = mainFactType.UnaryRole;
											//always use predicate text for unary fact types
											GetRoleNameFromPredicateText(mainFactType, unaryRole.OppositeRoleResolveProxy, unaryRole, isUnary, columnSpace, addPart);
										}
										else
										{
											if (null == objectification)
											{
												if (addPart == null)
												{
													addPart = delegate(NamePart newPart, int? insertIndex)
														{
															if (nameCollection != null)
															{
																nameCollection.Add(newPart);
															}
															else if (!singleName.IsEmpty)
															{
																nameCollection = new List<NamePart>();
																nameCollection.Add(singleName);
																nameCollection.Add(newPart);
															}
															else
															{
																singleName = newPart;
															}
														};
												}
												GetObjectTypeName(oppositeRole.Role.RolePlayer, addPart);
											}
											//used for second-level name precision later on, if needed
											createRoleName = true;
										}
									}
								}
								else
								{
									//use the role name
									AddToNameCollection(ref singleName, ref nameCollection, roleName);
								}

								//check if we need second-level name precision
								if (NeedLongerName(singleName, nameCollection, longerThan, columnSpace))
								{
									bool needValueTypeName = true;
								CreateRoleName:
									if (createRoleName && !createRoleNameSecond)
									{
										//generate a role name from the predicate text and prepend it

										// UNDONE: Matt Curland (Oct 13, 2007)
										// The predicate text can be used to generate a much better name
										// than just prepending it. There are several things to consider here.
										// This is not a spec, just things we should look at.
										// 1) If we do generate a role name that ends up being unique, then there
										// really is no reason to use the role player name at all if we use a reading
										// that ends with the opposite role.
										// 2) The generated text here should use the opposite role as a predicate
										// replacement if it starts the format string and the near role ends the format
										// string. In other words, we prefer to find a reading that is the forward reading
										// for the near role, but we need to respect the order if we don't find it.
										// 3) The 'longerThan' approach may be too simplistic. We may look at other ways
										// to track 'refinement level' that allows us to know what we have tried already
										// and to jump immediately to other alternatives. Refinements are not necessary longer.

										int nextInsertIndex = 0;
										GetRoleNameFromPredicateText(
											mainFactType,
											towardsRole,
											oppositeRole,
											isUnary,
											columnSpace,
											delegate(NamePart insertPart, int? insertIndex)
											{
												addPart(insertPart, nextInsertIndex);
												++nextInsertIndex;
											});
										if (needValueTypeName)
										{
											//determine if we still need to append the value type name for third-level precision
											needValueTypeName = NeedLongerName(singleName, nameCollection, longerThan, columnSpace);
										}
									}
									if (needValueTypeName)
									{
										GetEndNodeValueType(path, pathCount, addPart);

										if (createRoleNameSecond && createRoleName && NeedLongerName(singleName, nameCollection, longerThan, columnSpace))
										{
											//set variables so that the role name is created but not the value type again
											needValueTypeName = false;
											createRoleNameSecond = false;
											//create the role name
											goto CreateRoleName;
										}
									}
								}
							}
						}
					}

					string finalName = GetFinalName(singleName, nameCollection, columnSpace, columnCase);
					if (NeedLongerName(finalName, longerThan))
					{
						//no more precision available
						return null;
					}
					else
					{
						return finalName;
					}
				}
				private string GenerateConstraintName(Constraint constraint, string longerThan)
				{
					ReferenceConstraint refConstraint = constraint as ReferenceConstraint;
					if (null != refConstraint)
					{
						string name = refConstraint.SourceTable.Name + "_FK";
						if (NeedLongerName(name, longerThan))
						{
							return null;
						}
						else
						{
							return name;
						}
					}
					return constraint.Name;
				}
				private void AddToNameCollection(ref NamePart singleName, ref List<NamePart> nameCollection, string newName)
				{
					AddToNameCollection(ref singleName, ref  nameCollection, new NamePart(newName), -1);
				}
				private void AddToNameCollection(ref NamePart singleName, ref List<NamePart> nameCollection, string newName, int index)
				{
					AddToNameCollection(ref singleName, ref nameCollection, new NamePart(newName), index);
				}
				private void AddToNameCollection(ref NamePart singleName, ref List<NamePart> nameCollection, NamePart newNamePart, int index)
				{
					string newName = newNamePart;
					newName = newName.Trim();
					NamePartOptions options = newNamePart.Options;
					Debug.Assert(!string.IsNullOrEmpty(newName));
					if (newName.Contains(" "))
					{
						string[] individualEntries = newName.Split(new char[] { ' ' }, StringSplitOptions.RemoveEmptyEntries);
						for (int i = 0; i < individualEntries.Length; ++i)
						{
							//add each space separated name individually
							AddToNameCollection(ref singleName, ref nameCollection, individualEntries[i], index == -1 ? -1 : index + i);
						}
						return;
					}

					if (singleName.IsEmpty)
					{
						//we only have one name so far, so just use the string
						singleName = new NamePart(newName, options);
					}
					else
					{
						//we need to now use the collection
						if (null == nameCollection)
						{
							nameCollection = new List<NamePart>();
							//first add to the actual collection the element that had previosly been added
							nameCollection.Add(singleName);
						}
						int count;
						if (index == -1)
						{
							index = nameCollection.Count;
							count = index + 1;
							nameCollection.Add(new NamePart(newName, options));
						}
						else
						{
							nameCollection.Insert(index, new NamePart(newName, options));
							count = nameCollection.Count;
						}
						//remove duplicate information
						int nextIndex;
						if ((index > 0 && ((string)nameCollection[index - 1]).EndsWith(newName, StringComparison.CurrentCultureIgnoreCase))
							|| ((nextIndex = index + 1) < count && ((string)nameCollection[nextIndex]).StartsWith(newName, StringComparison.CurrentCultureIgnoreCase)))
						{
							//we don't need the name that was just added
							nameCollection.RemoveAt(index);
						}
						else
						{
							//check if we need the following name
							while (nextIndex < count)
							{
								if (newName.EndsWith(nameCollection[nextIndex], StringComparison.CurrentCultureIgnoreCase))
								{
									nameCollection.RemoveAt(nextIndex);
									--count;
								}
								else
								{
									break;
								}
							}
							//check the preceding name
							nextIndex = index - 1;
							while (nextIndex > -1)
							{
								if (newName.StartsWith(nameCollection[nextIndex], StringComparison.CurrentCultureIgnoreCase))
								{
									nameCollection.RemoveAt(nextIndex--);
								}
								else
								{
									break;
								}
							}
						}
					}
				}
				private bool NeedLongerName(NamePart finalName, List<NamePart> finalNameCollection, string longerThan, string space)
				{
					return NeedLongerName(GetFinalName(finalName, finalNameCollection, space), longerThan);
				}
				private bool NeedLongerName(string finalName, string longerThan)
				{
					return finalName == "" || ((null != longerThan) && longerThan.IndexOf(finalName, 0, StringComparison.CurrentCultureIgnoreCase) > -1);
				}
				private string GetFinalName(NamePart singleName, List<NamePart> nameCollection, string space)
				{
					//use -1 to signify that case changes should not be done
					return GetFinalName(singleName, nameCollection, space, CasingOption.None);
				}
				private string GetFinalName(NamePart singleName, List<NamePart> nameCollection, string space, CasingOption casing)
				{
					// UNDONE: There are several things we need to do this correctly.
					// Object type names cannot be treated as atomic unit.
					// 1) ValueType names may be composed of EntityType and reference mode names combined with
					//    a format string.
					// 2) EntityType names may be composed of a format string combining EntityType/ValueType/ReferenceMode names
					//    that also need to be considered as atomic names and a format string to combine them
					// 3) ReferenceModeNames may be units, which should never be cased.
					//
					// Camel gives inconsistent results until these are done, although it is used as the column default.
					string finalName;
					if (null == nameCollection)
					{
						if (singleName.IsEmpty)
						{
							return "";
						}
						else if (casing == CasingOption.None)
						{
							finalName = singleName;
						}
						else
						{
							finalName = DoFirstWordCasing(singleName, casing, CultureInfo.CurrentCulture.TextInfo);
						}
					}
					else
					{
						TextInfo textInfo = CultureInfo.CurrentCulture.TextInfo;

						string name;
						if (casing == CasingOption.None)
						{
							name = nameCollection[0];
						}
						else
						{
							name = DoFirstWordCasing(nameCollection[0], casing, textInfo);
						}

						//we already know there are at least two name entries, so use a string builder
						StringBuilder builder = new StringBuilder(name);

						//we already have the first entry, so mark camel as pascal
						CasingOption tempCasing = casing;
						if (tempCasing == CasingOption.Camel)
						{
							tempCasing = CasingOption.Pascal;
						}

						//add each entry with proper spaces and casing
						int count = nameCollection.Count;
						for (int i = 1; i < count; ++i)
						{
							builder.Append(space);
							if (casing == CasingOption.None)
							{
								name = nameCollection[i];
							}
							else
							{
								name = DoFirstWordCasing(nameCollection[i], tempCasing, textInfo);
							}
							builder.Append(name);
						}
						finalName = builder.ToString();
					}

					return finalName;
				}
				private string DoFirstWordCasing(NamePart name, CasingOption casing, TextInfo textInfo)
				{
					if (name.ExplicitCasing) return name;
					switch (casing)
					{
						case CasingOption.Camel:
							return TestHasAdjacentUpperCase(name) ? (string)name : DoFirstLetterCase(name, false, textInfo);
						case CasingOption.Pascal:
							return TestHasAdjacentUpperCase(name) ? (string)name : DoFirstLetterCase(name, true, textInfo);
						case CasingOption.Lower:
							return TestHasAdjacentUpperCase(name) ? (string)name : textInfo.ToLower(name);
						case CasingOption.Upper:
							return textInfo.ToUpper(name);
					}

					return null;
				}
				private bool TestHasAdjacentUpperCase(string name)
				{
					if (!string.IsNullOrEmpty(name))
					{
						int length = name.Length;
						bool previousCharUpper = false;
						for (int i = 0; i < length; ++i)
						{
							// UNDONE: Hack until we can consider individual parts of
							// reference mode names. Ignore anything after a separator.
							if (!Char.IsLetterOrDigit(name, i))
							{
								return false;
							}
							if (Char.IsUpper(name, i))
							{
								if (previousCharUpper)
								{
									return true;
								}
								previousCharUpper = true;
							}
							else
							{
								previousCharUpper = false;
							}
						}
					}
					return false;
				}
				private string DoFirstLetterCase(NamePart name, bool upper, TextInfo textInfo)
				{
					string nameValue = name;
					char c = nameValue[0];
					if (upper)
					{
						c = textInfo.ToUpper(c);
					}
					else
					{
						c = textInfo.ToLower(c);
					}
					if (nameValue.Length > 1)
					{
						nameValue = c.ToString() + nameValue.Substring(1);
					}
					else
					{
						nameValue = c.ToString();
					}
					return nameValue;
				}
				private bool IsHyphenBound(IReading reading, LinkedElementCollection<RoleBase> factTypeRoles, RoleBase role, int? unaryRoleIndex, out string hyphenBoundRolePlayerName)
				{
					// UNDONE: The hyphen binder does a lot of stuff we don't need, including
					// building replacement strings for each role and rebuilding the predicate text.
					// Add another method to the hyphenBinder to support binding one role only.
					VerbalizationHyphenBinder hyphenBinder = new VerbalizationHyphenBinder(reading, factTypeRoles, unaryRoleIndex, "{0}{{0}}{1}");
					string rolePlayerName = role.Role.RolePlayer.Name;
					hyphenBoundRolePlayerName = hyphenBinder.HyphenBindRoleReplacement(rolePlayerName, factTypeRoles.IndexOf(role));
					return ((object)hyphenBoundRolePlayerName != (object)rolePlayerName);
				}
				private bool IsPreferredIdentifierFactType(FactType factType, RoleBase role)
				{
					ORMCore.UniquenessConstraint preferredIdentifier = role.Role.RolePlayer.ResolvedPreferredIdentifier;
					if (null == preferredIdentifier)
					{
						return false;
					}
					return preferredIdentifier.FactTypeCollection.Contains(factType);
				}
				private void GetObjectTypeName(ObjectType objectType, AddNamePart addNamePartCallback)
				{
					ReferenceModeNaming.ResolveObjectTypeName(objectType, null, addNamePartCallback);
				}
				private void GetEndNodeValueType(LinkedElementCollection<ConceptTypeChild> path, int pathCount, AddNamePart addNamePartCallback)
				{
					//find the last ConceptTypeChild with an InformationTypeFormat target
					for (int i = pathCount; --i > -1; )
					{
						ConceptTypeChild link = path[i];
						InformationTypeFormat target;
						if (null != (target = link.Target as InformationTypeFormat))
						{
							addNamePartCallback(target.Name, null);
						}
					}
				}
#if FALSE // NOT CALLED
				private string GetEndNodeObjectType(LinkedElementCollection<ConceptTypeChild> path, int pathCount)
				{
					//find the last ConceptTypeChild with an InformationTypeFormat target
					for (int i = pathCount; --i > -1; )
					{
						ConceptTypeChild link = path[i];
						InformationTypeFormat target;
						if (null != (target = link.Target as InformationTypeFormat))
						{
							LinkedElementCollection<FactType> factTypes = ConceptTypeChildHasPathFactType.GetPathFactTypeCollection(link);
							ObjectType objectType = FactTypeMapsTowardsRole.GetTowardsRole(factTypes[factTypes.Count - 1]).Role.RolePlayer;
							if (null != objectType.NestedFactType)
							{
								return GetEndNodeValueType(path, pathCount);
							}
							return GetObjectTypeName(objectType);
						}
					}
					return null;
				}
#endif // FALSE
				private void GetRoleNameFromPredicateText(FactType factType, RoleBase towardsRole, RoleBase oppositeRole, bool isUnary, string spaceReplaceString, AddNamePart addNamePartCallback)
				{
					ReadingOrder readingOrder = GetReadingOrder(factType, towardsRole, oppositeRole, isUnary);
					if (null != readingOrder)
					{
						IReading reading = readingOrder.PrimaryReading;
						if (null == myReplaceFieldsPattern)
						{
							myReplaceFieldsPattern = new Regex(@"{\d+}", RegexOptions.Compiled);
						}
						//get rid of string replace fields
						string text = myReplaceFieldsPattern.Replace(reading.Text, " ");
						text = " " + CultureInfo.CurrentCulture.TextInfo.ToLower(text) + " ";
						//remove articles and hyphens
						text = text.Replace(" a ", " ").Replace(" an ", " ").Replace(" the ", " ").Replace("- ", " ").Replace(" -", " ");
						if (!isUnary && text.Trim() != "has")
						{
							text = text.Replace(" has ", " ");
						}
						if (!StringIsNullOrEmpty(text))
						{
							addNamePartCallback(text, null);
						}
					}

					GetObjectTypeName(oppositeRole.Role.RolePlayer, addNamePartCallback);
				}
				private ReadingOrder GetReadingOrder(FactType factType, RoleBase towardsRole, RoleBase oppositeRole, bool isUnary)
				{
					if (!isUnary)
					{
						//get the reading in the correct direction, if possible
						ReadingOrder readingOrder = factType.FindMatchingReadingOrder(new RoleBase[] { towardsRole, oppositeRole });
						if (null != readingOrder)
						{
							return readingOrder;
						}
					}

					//return the first reading
					foreach (ReadingOrder readingOrder in factType.ReadingOrderCollection)
					{
						return readingOrder;
					}

					return null;
				}
				private bool StringIsNullOrEmpty(string newName)
				{
					return (null == newName) || (newName.Trim().Length < 1);
				}
				//private enum CasingOption
				//{
				//    None,
				//    Pascal,
				//    Camel,
				//    Flat,
				//    Upper,
				//}
			}
			#endregion // DefaultDatabaseNameGenerator class
		}
	}
	#endregion // ORMAbstractionToConceptualDatabaseBridgeDomainModel.NameGeneration class

	#region ORMAbstractionToConceptualDatabaseBridgeDomainModel.RelationalNameGenerator Class
	partial class RelationalNameGenerator
	{
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public RelationalNameGenerator(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartition : null, propertyAssignments)
		{
		}

		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public RelationalNameGenerator(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, GenerateDefaultValues(propertyAssignments))
		{
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="propertyAssignments"></param>
		/// <returns></returns>
		private static PropertyAssignment[] GenerateDefaultValues(params PropertyAssignment[] propertyAssignments)
		{
			PropertyAssignment[] properties = propertyAssignments;
			string nameUsage = null;
			int casingOptionIndex = -1;
			int spacingOptionIndex = -1;
			for (int i = 0; i < properties.Length; ++i)
			{
				PropertyAssignment assignment = properties[i];
				Guid propertyId = assignment.PropertyId;
				if (propertyId == ORMCore.NameGenerator.CasingOptionDomainPropertyId)
				{
					casingOptionIndex = i;
				}
				else if (propertyId == ORMCore.NameGenerator.NameUsageDomainPropertyId)
				{
					nameUsage = (string)assignment.Value;
				}
				else if (propertyId == ORMCore.NameGenerator.SpacingFormatDomainPropertyId)
				{
					spacingOptionIndex = i;
				}
			}
			if (nameUsage == null)
			{
				if (spacingOptionIndex != -1)
				{
					properties[spacingOptionIndex] = new PropertyAssignment(ORMCore.NameGenerator.SpacingFormatDomainPropertyId, NameGeneratorSpacingFormat.Remove);
				}
			}
			else if (casingOptionIndex != -1)
			{
				if (nameUsage == "RelationalColumn")
				{
					properties[casingOptionIndex] = new PropertyAssignment(ORMCore.NameGenerator.CasingOptionDomainPropertyId, NameGeneratorCasingOption.Camel);
				}
				else if (nameUsage == "RelationalTable")
				{
					properties[casingOptionIndex] = new PropertyAssignment(ORMCore.NameGenerator.CasingOptionDomainPropertyId, NameGeneratorCasingOption.Pascal);
				}
			}
			return properties;
		}
	}
	#endregion // ORMAbstractionToConceptualDatabaseBridgeDomainModel.RelationalNameGenerator Class
}

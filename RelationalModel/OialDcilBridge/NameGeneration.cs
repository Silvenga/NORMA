using System;
using System.Collections.Generic;
using System.Text;
using Neumont.Tools.ORM.ObjectModel;
using ORMCore = Neumont.Tools.ORM.ObjectModel;
using Microsoft.VisualStudio.Modeling;
using Neumont.Tools.ORMAbstraction;
using Neumont.Tools.ORMToORMAbstractionBridge;
using Neumont.Tools.RelationalModels.ConceptualDatabase;
using System.Text.RegularExpressions;
using System.Diagnostics;
using System.Globalization;

namespace Neumont.Tools.ORMAbstractionToConceptualDatabaseBridge
{
	#region IDatabaseNameGenerator interface
	/// <summary>
	/// Generate relational names for elements contained in a <see cref="Schema"/>
	/// </summary>
	public interface IDatabaseNameGenerator
	{
		/// <summary>
		/// Generate a name for the provided <paramref name="table"/>
		/// </summary>
		/// <param name="table">A <see cref="Table"/> element</param>
		/// <param name="longerThan">Generate a more specific name than provided.
		/// If this is set, then the passed in name will have been generated by
		/// this method on this instance. Can be <see langword="null"/></param>
		/// <returns>A name for <paramref name="table"/>.</returns>
		string GenerateTableName(Table table, string longerThan);
		/// <summary>
		/// Generate a name for the provided <paramref name="column"/>
		/// </summary>
		/// <param name="column">A <see cref="Column"/> element</param>
		/// <param name="longerThan">Generate a more specific name than provided.
		/// If this is set, then the passed in name will have been generated by
		/// this method on this instance. Can be <see langword="null"/></param>
		/// <returns>A name for <paramref name="column"/>.</returns>
		string GenerateColumnName(Column column, string longerThan);
		/// <summary>
		/// Generate a name for the provided <paramref name="constraint"/>
		/// </summary>
		/// <param name="constraint">A <see cref="Constraint"/> element</param>
		/// <param name="longerThan">Generate a more specific name than provided.
		/// If this is set, then the passed in name will have been generated by
		/// this method on this instance. Can be <see langword="null"/></param>
		/// <returns>A name for <paramref name="constraint"/>.</returns>
		string GenerateConstraintName(Constraint constraint, string longerThan);
	}
	#endregion // IDatabaseNameGenerator interface
	partial class ORMAbstractionToConceptualDatabaseBridgeDomainModel
	{
		private static class NameGeneration
		{
			#region GenerateAllNames method
			public static void GenerateAllNames(Schema schema)
			{
				Dictionary<string, ConceptualDatabaseModelElement> tableNames = new Dictionary<string, ConceptualDatabaseModelElement>();
				Dictionary<string, ConceptualDatabaseModelElement> tempNames = new Dictionary<string, ConceptualDatabaseModelElement>();
				LinkedElementCollection<Table> tables = schema.TableCollection;
				foreach (Table table in tables)
				{
					//table names
					CallGeneratorForTableName(table, tableNames, null);

					//column names
					tempNames.Clear();
					LinkedElementCollection<Column> columns = table.ColumnCollection;
					foreach (Column column in columns)
					{
						CallGeneratorForColumnName(column, tempNames, null);
					}

					//constraint names
					LinkedElementCollection<ReferenceConstraint> constraints;
					if (null != (constraints = table.ReferenceConstraintCollection))
					{
						tempNames.Clear();
						foreach (ReferenceConstraint constraint in constraints)
						{
							CallGeneratorForConstraintName(constraint, tempNames, null);
						}
					}
				}
			}
			#endregion // GenerateAllNames method
			#region private helper methods
			private static void CallGeneratorForTableName(Table table, Dictionary<string, ConceptualDatabaseModelElement> tableNames, string tableName)
			{
				CallGenerator(table, tableNames, tableName,
					new GeneratorCall(delegate(ConceptualDatabaseModelElement element, string longerThan)
					{
						return GenerateTableName(element as Table, longerThan);
					}));
			}
			private static void CallGeneratorForColumnName(Column column, Dictionary<string, ConceptualDatabaseModelElement> columnNames, string columnName)
			{
				CallGenerator(column, columnNames, columnName,
					new GeneratorCall(delegate(ConceptualDatabaseModelElement element, string longerThan)
					{
						return GenerateColumnName(element as Column, longerThan);
					}));
			}
			private static void CallGeneratorForConstraintName(Constraint constraint, Dictionary<string, ConceptualDatabaseModelElement> constraintNames, string constraintName)
			{
				CallGenerator(constraint, constraintNames, constraintName,
					new GeneratorCall(delegate(ConceptualDatabaseModelElement element, string longerThan)
					{
						return GenerateConstraintName(element as Constraint, longerThan);
					}));
			}
			delegate string GeneratorCall(ConceptualDatabaseModelElement element, string longerThan);
			private static void CallGenerator(ConceptualDatabaseModelElement element, Dictionary<string, ConceptualDatabaseModelElement> existingNames, string curName, GeneratorCall generatorCall)
			{
				ConceptualDatabaseModelElement nameConflictElement = null;
				while (true)
				{
					if (null != nameConflictElement)
					{
						//set the value in the collection to null so this element does not have yet another name generated
						existingNames[curName] = null;
						//generate a new name for this element as well
						CallGenerator(nameConflictElement, existingNames, curName, generatorCall);
					}

					curName = generatorCall(element, curName);

					if (existingNames.ContainsKey(curName))
					{
						//mark the conflicting element to have a new name generated as well
						nameConflictElement = existingNames[curName];
					}
					else
					{
						//no conflict, so we are done
						break;
					}
				}
				existingNames.Add(curName, element);

				//set the name
				Table table;
				Column column;
				Constraint constraint;
				if (null != (constraint = element as Constraint))
				{
					constraint.Name = curName;
				}
				else if (null != (column = element as Column))
				{
					column.Name = curName;
				}
				else if (null != (table = element as Table))
				{
					table.Name = curName;
				}
			}
			#endregion // private helper methods
			#region UNDONE: temporary static imitation of an IDatabaseNameGenerator implementation
			private static Regex myReplaceFieldsPattern;
			private static Regex myNumberPattern;
			// UNDONE: This field will not remain static when this is moved
			// into an object model with additional information
			private static Dictionary<string, int> myCounts;
			private static string GenerateTableName(Table table, string longerThan)
			{
				if (null != myCounts && null == longerThan)
				{
					myCounts.Clear();
				}
				string singleName = null;
				List<string> nameCollection = null;
				AddToNameCollection(ref singleName, ref nameCollection, TableIsPrimarilyForConceptType.GetConceptType(table).Name);
				return EnsureDifference(GetFinalName(singleName, nameCollection, "", CasingOption.Pascal), longerThan);
			}
			private static string GenerateColumnName(Column column, string longerThan)
			{
				// UNDONE: use these two varables to reflect preference customization 
				CasingOption columnCase = CasingOption.Pascal;
				string columnSpace = "";

				//the string is used when possible to avoid using the list for a single entry
				string singleName = null;
				List<string> nameCollection = null;
				LinkedElementCollection<ConceptTypeChild> path = ColumnHasConceptTypeChild.GetConceptTypeChildPath(column);
				int pathCount = path.Count;
				if (pathCount < 1)
				{
					//if we dont have a path, there is nothing we can do
					AddToNameCollection(ref singleName, ref nameCollection, column.Name);
				}
				else
				{
					ConceptTypeChild link = null;
					//this is used so that only the leaf subtype node is collected by default
					bool hasSubtypeNode = false;
					FactType firstFactType = null;
					//find the first non subtype fact type
					for (int i = 0; i < pathCount; ++i)
					{
						link = path[i];
						LinkedElementCollection<FactType> factTypes = ConceptTypeChildHasPathFactType.GetPathFactTypeCollection(link);
						if (factTypes.Count < 1)
						{
							continue;
						}
						firstFactType = factTypes[0];
						if (firstFactType is SubtypeFact)
						{
							if (!hasSubtypeNode)
							{
								AddToNameCollection(ref singleName, ref nameCollection, ((ConceptType)link.Target).Name);
								hasSubtypeNode = true;
							}
						}
						else
						{
							break;
						}
					}

					if (null == firstFactType)
					{
						//not much we can really do if there are no fact types
						AddToNameCollection(ref singleName, ref nameCollection, link.Name);
					}
					else
					{
						//use the first fact type to determine if this column is part of the primary identifier
						RoleBase towardsRoleBase = FactTypeMapsTowardsRole.GetTowardsRole(firstFactType);
						if (IsPreferredIdentifierFactType(firstFactType, towardsRoleBase.Role))
						{
							//for primary identifiers, just use the end node value type name
							AddToNameCollection(ref singleName, ref nameCollection, GetValueType(path, pathCount));
						}
						else
						{
							//search the fact type for a role name or relevant hyphen binding
							LinkedElementCollection<RoleBase> factTypeRoles = firstFactType.RoleCollection;
							int? unaryRoleIndex = FactType.GetUnaryRoleIndex(factTypeRoles);
							bool isUnary = unaryRoleIndex.HasValue;
							RoleBase oppositeRoleBase = towardsRoleBase.OppositeRoleAlwaysResolveProxy;
							Role oppositeRole = oppositeRoleBase.Role;
							string roleName = oppositeRole.Name;
							bool usingRolePlayerName = false;
							if (StringIsNullOrEmpty(roleName))
							{
								//no role name, look for hyphen binding
								ReadingOrder readingOrder = GetReadingOrder(firstFactType, oppositeRole, isUnary);
								string rolePlayerName = oppositeRole.RolePlayer.Name;
								string hyphenBoundRolePlayerName;
								if ((null != readingOrder) &&
									(IsHyphenBound(readingOrder.PrimaryReading, factTypeRoles, oppositeRoleBase, unaryRoleIndex, out hyphenBoundRolePlayerName)))
								{
									//use the hyphen bound name
									AddToNameCollection(ref singleName, ref nameCollection, hyphenBoundRolePlayerName);
								}
								else
								{
									if (isUnary)
									{
										//always use predicate text for unary fact types
										AddToNameCollection(ref singleName, ref nameCollection,
											GetRoleNameFromPredicateText(firstFactType, firstFactType.UnaryRole, isUnary, columnSpace));
									}
									else
									{
										AddToNameCollection(ref singleName, ref nameCollection, rolePlayerName);
										//used for second-level name precision later on, if needed
										usingRolePlayerName = true;
									}
								}
							}
							else
							{
								//use the role name
								AddToNameCollection(ref singleName, ref nameCollection, roleName);
							}

							//check if we need second-level name precision
							if (IsEqual(singleName, nameCollection, longerThan, columnSpace))
							{
								bool needValueType = true;
								if (usingRolePlayerName)
								{
									//generate a role name from the predicate text and prepend it
									AddToNameCollection(ref singleName, ref nameCollection,
										GetRoleNameFromPredicateText(firstFactType, oppositeRoleBase, isUnary, columnSpace),
										0);
									//determine if we still need to append the value type name for third-level precision
									needValueType = IsEqual(singleName, nameCollection, longerThan, columnSpace);
								}
								if (needValueType)
								{
									AddToNameCollection(ref singleName, ref nameCollection, GetValueType(path, pathCount));
								}
							}
						}
					}
				}

				//call the final method to ensure a name difference
				return EnsureDifference(GetFinalName(singleName, nameCollection, columnSpace, columnCase), longerThan);
			}
			private static string GenerateConstraintName(Constraint constraint, string longerThan)
			{
				ReferenceConstraint refConstraint = constraint as ReferenceConstraint;
				if (null != refConstraint)
				{
					StringBuilder name = new StringBuilder(refConstraint.SourceTable.Name);
					name.Append("_FK");
					return EnsureDifference(name.ToString(), longerThan);
				}
				return constraint.Name;
			}
			private static void AddToNameCollection(ref string singleName, ref List<string> nameCollection, string newName)
			{
				Debug.Assert(!StringIsNullOrEmpty(newName));
				AddToNameCollection(ref singleName, ref  nameCollection, newName, -1);
			}
			private static void AddToNameCollection(ref string singleName, ref List<string> nameCollection, string newName, int index)
			{
				newName = newName.Trim();
				if (newName.Contains(" "))
				{
					string[] individualEntries = newName.Split(' ');
					for (int i = 0; i < individualEntries.Length; ++i)
					{
						//add each space separated name individually
						AddToNameCollection(ref singleName, ref nameCollection, individualEntries[i], index == -1 ? -1 : index + i);
					}
					return;
				}

				if (null == singleName)
				{
					//we only have one name so far, so just use the string
					singleName = newName;
				}
				else
				{
					//we need to now use the collection
					if (null == nameCollection)
					{
						nameCollection = new List<string>();
						//first add to the actual collection the element that had previosly been added
						nameCollection.Add(singleName);
					}
					if (index == -1)
					{
						nameCollection.Add(newName);
					}
					else
					{
						nameCollection.Insert(index, newName);
					}
				}
			}
			private static bool IsEqual(string finalName, List<string> finalNameCollection, string longerThan, string space)
			{
				return (null != longerThan) &&
					longerThan.StartsWith(GetFinalName(finalName, finalNameCollection, space), StringComparison.CurrentCultureIgnoreCase);
			}
			private static string GetFinalName(string singleName, List<string> nameCollection, string space)
			{
				//use -1 to signify that case changes should not be done
				return GetFinalName(singleName, nameCollection, space, CasingOption.None);
			}
			private static string GetFinalName(string singleName, List<string> nameCollection, string space, CasingOption casing)
			{
				string finalName;
				if (null == nameCollection)
				{
					if (casing == CasingOption.None)
					{
						finalName = singleName;
					}
					else
					{
						finalName = DoFirstWordCasing(singleName, casing);
					}
				}
				else
				{
					string name;
					if (casing == CasingOption.None)
					{
						name = nameCollection[0];
					}
					else
					{
						name = DoFirstWordCasing(nameCollection[0], casing);
					}

					//we already know there are at least two name entries, so use a string builder
					StringBuilder builder = new StringBuilder(name);

					//we already have the first entry, so mark camel as pascal
					CasingOption tempCasing = casing;
					if (tempCasing == CasingOption.Camel)
					{
						tempCasing = CasingOption.Pascal;
					}

					int count = nameCollection.Count;
					for (int i = 1; i < count; ++i)
					{
						builder.Append(space);
						if (casing == CasingOption.None)
						{
							name = nameCollection[i];
						}
						else
						{
							name = DoFirstWordCasing(nameCollection[i], tempCasing);
						}
						builder.Append(name);
					}
					finalName = builder.ToString();
				}

				return finalName;
			}
			private static string DoFirstWordCasing(string name, CasingOption casing)
			{
				switch (casing)
				{
					case CasingOption.Camel:
						return DoFirstLetterCase(name, false);
					case CasingOption.Pascal:
						return DoFirstLetterCase(name, true);
					case CasingOption.Flat:
						return CultureInfo.CurrentCulture.TextInfo.ToLower(name);
					case CasingOption.Upper:
						return CultureInfo.CurrentCulture.TextInfo.ToUpper(name);
				}

				return null;
			}
			private static string DoFirstLetterCase(string name, bool upper)
			{
				char c = name[0];
				if (upper)
				{
					c = CultureInfo.CurrentCulture.TextInfo.ToUpper(c);
				}
				else
				{
					c = CultureInfo.CurrentCulture.TextInfo.ToLower(c);
				}
				if (name.Length > 1)
				{
					name = c.ToString() + name.Substring(1);
				}
				else
				{
					name = c.ToString();
				}
				return name;
			}
			private static bool IsHyphenBound(IReading reading, LinkedElementCollection<RoleBase> factTypeRoles, RoleBase role, int? unaryRoleIndex, out string hyphenBoundRolePlayerName)
			{
				// UNDONE: The hyphen binder does a lot of stuff we don't need, including
				// building replacement strings for each role and rebuilding the predicate text.
				// Add another method to the hyphenBinder to support binding one role only.
				VerbalizationHyphenBinder hyphenBinder = new VerbalizationHyphenBinder(reading, factTypeRoles, unaryRoleIndex, "{0}{{0}}{1}");
				string rolePlayerName = role.Role.RolePlayer.Name;
				hyphenBoundRolePlayerName = hyphenBinder.HyphenBindRoleReplacement(rolePlayerName, factTypeRoles.IndexOf(role));
				return ((object)hyphenBoundRolePlayerName != (object)rolePlayerName);
			}
			private static bool IsPreferredIdentifierFactType(FactType factType, Role role)
			{
				return role.RolePlayer.ResolvedPreferredIdentifier.FactTypeCollection.Contains(factType);
			}
			private static string GetValueType(LinkedElementCollection<ConceptTypeChild> path, int pathCount)
			{
				//find the last ConceptTypeChild with an InformationTypeFormat target
				for (int i = pathCount; --i > -1; )
				{
					ConceptTypeChild link = path[i];
					InformationTypeFormat target;
					if (null != (target = link.Target as InformationTypeFormat))
					{
						LinkedElementCollection<FactType> factTypes = ConceptTypeChildHasPathFactType.GetPathFactTypeCollection(link);
						ObjectType objectType = FactTypeMapsTowardsRole.GetTowardsRole(factTypes[factTypes.Count - 1]).Role.RolePlayer;
						ObjectType valueType;
						string name = ReferenceModeNaming.ResolveObjectTypeName(objectType,
							valueType = InformationTypeFormatIsForValueType.GetValueType(target));
						return name ?? valueType.Name;
					}
				}
				return null;
			}
			private static string GetRoleNameFromPredicateText(FactType factType, RoleBase role, bool isUnary, string spaceReplaceString)
			{
				ReadingOrder readingOrder = GetReadingOrder(factType, role.Role, isUnary);
				if (null == readingOrder)
				{
					return role.Role.RolePlayer.Name;
				}
				else
				{
					IReading reading = readingOrder.PrimaryReading;
					if (null == myReplaceFieldsPattern)
					{
						myReplaceFieldsPattern = new Regex(@"{\d+}", RegexOptions.Compiled);
					}
					//get rid of string replace fields
					string text = " " + myReplaceFieldsPattern.Replace(reading.Text, " ") + " ";
					//remove articles
					text = text.Replace(" a ", " ").Replace(" an ", " ").Replace(" the ", " ");
					if (!isUnary)
					{
						text = text.Replace(" has ", " ");
					}
					return text;
				}
			}
			private static ReadingOrder GetReadingOrder(FactType factType, Role role, bool isUnary)
			{
				if (!isUnary)
				{
					//get the reading in the correct direction, if possible
					ReadingOrder readingOrder = factType.FindMatchingReadingOrder(new RoleBase[] { role.OppositeRoleAlwaysResolveProxy, role });
					if (null != readingOrder)
					{
						return readingOrder;
					}
				}

				//return the first reading
				foreach (ReadingOrder readingOrder in factType.ReadingOrderCollection)
				{
					return readingOrder;
				}

				return null;
			}
			private static string EnsureDifference(string name, string longerThan)
			{
				if (null != longerThan && longerThan.StartsWith(name))
				{
					bool areEqual = name == longerThan;
					if (!areEqual)
					{
						//determine if longerThan is just name followed by a string of numbers
						if (null == myNumberPattern)
						{
							myNumberPattern = new Regex(@"\d+", RegexOptions.RightToLeft | RegexOptions.Compiled);
						}
						string endNumbers = longerThan.Substring(name.Length);
						Match longerThanMatches = myNumberPattern.Match(endNumbers);
						if (longerThanMatches.Success && longerThanMatches.Index + longerThanMatches.Length == endNumbers.Length)
						{
							//if so, mark them as equal
							areEqual = true;
						}
					}

					if (areEqual)
					{
						if (null == myCounts)
						{
							myCounts = new Dictionary<string, int>();
						}
						int curCount;
						if (myCounts.ContainsKey(name))
						{
							//keep track of the number of occurances of this string
							curCount = ++myCounts[name];
						}
						else
						{
							curCount = 1;
							myCounts.Add(name, 1);
						}
						name += curCount.ToString();
					}
				}
				return name;
			}
			private static bool StringIsNullOrEmpty(string newName)
			{
				return string.IsNullOrEmpty(newName.Trim());
			}
			private enum CasingOption
			{
				None,
				Pascal,
				Camel,
				Flat,
				Upper,
			}
			#endregion // UNDONE: temporary static immitation of an IDatabaseNameGenerator implementation
		}
	}
}

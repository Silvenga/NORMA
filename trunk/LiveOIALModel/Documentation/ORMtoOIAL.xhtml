<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
	<head>
		<title>ORM to OIAL Transformation Explanation</title>
		<link type="text/css" href="styles.css" rel="stylesheet" />
	</head>
	<body>
		<h2>ORMtoOIAL.xslt &ndash; 2006/04</h2>
		<hr />
		<h4>Introduction</h4>
		<p>This document is intended to describe in great detail how the ORMtoOIAL.xslt transform works, and the resulting structure of the OIAL document which results from the transform. This is intended to help people better understand how a live OIAL implementation would work in code.</p>
		<hr/>
		<h4>Transformation Process: Diagnostic Phase</h4>
		<ol>
			<!-- #1 -->
			<li id="debug">
				Debug Information: <span class="var">$EnableAssertions</span> (which does checks that CoRefORM.xslt is written correctly), <span class="var">$OutputDebugInformation</span>, and <span class="var">$OutputVerboseDebugInformation</span>. These will be referenced throughout the rest of this document.<br/>
				<span class="line">Lines 31 &ndash; 34</span><br/><br/>
			</li>
			<!-- #2 -->
			<li id="Model">
				The imported CoRefORM.xslt is called to ensure the input model has already been binarized, passing SourceModel (the entire document), which is subsequently stored in the <span class="var">$Model</span> variable.<br/>
				<span class="line">Lines 36 &ndash; 50</span><br /><br/>
			</li>
			<!-- #3 -->
			<li>
				Diagnostic Information:
				<ol class="lalpha">
					<li id="objectsAndFacts">
						Stores the objects and facts in <span class="var">$objectAndFacts</span>.<br/>
						<span class="line">Line 52</span>
					</li>
					<li id="SingleRoleMandatoryConstraints">
						Stores the single role mandatory constraints in <span class="var">$SingleRoleMandatoryConstraints</span>.<br/>
						<span class="line">Line 54</span>
					</li>
					<li id="SingleRoleUniquenessConstraints">
						Stores the single role uniqueness constraints in <span class="var">$SingleRoleUniquenessConstraints</span>.<br/>
						<span class="line">Line 55</span>
					</li>
					<li id="AlethicSingleRoleMandatoryConstraints">
						Stores the alethic single role mandatory constraints in <span class="var">$AlethicSingleRoleMandatoryConstraints</span>.<sup>
							<a href="#ftnt1">1</a>
						</sup><br/>
						<span class="line">Line 56</span>
					</li>
					<li id="AlethicSingleRoleUniquenessConstraints">
						Stores the alethic single role mandatory constraints in <span class="var">$AlethicSingleRoleUniquenessConstraints</span>.<sup>
							<a href="#ftnt1">1</a>
						</sup><br/>
						<span class="line">Line 57</span>
					</li>
				</ol><br/>
			</li>
			<!-- # 4 -->
			<li id="ObjectTypeInformation">
				For each object type in <span class="var">$Model/orm:Objects</span>, copies the object element and its attributes and then gets ObjectTypeInformation for each object (stored in <span class="var">$ObjectTypeInformation</span>):
				<ol class="lalpha">
					<li id="subtypeMetaFacts">
						Stores its SubtypeFacts where this object is a subtype in <span class="var">$subtypeMetaFacts</span>.<br />
						<span class="line">Line 291</span>
					</li>
					<li id="supertypeMetaFacts">
						Stores its SupertypeFacts where this object is a supertype in <span class="var">$supertypeMetaFacts</span>.<br/>
						<span class="line">Line 294</span>
					</li>
					<li id="directPlayedRoles">
						Stores all of this object's played roles in <span class="var">$directPlayedRoles</span>.<br/>
						<span class="line">Line 297</span>
					</li>
					<li id="inheritedPlayedRoles">
						Stores all direct and inherited roles played by a supertype of this object type in <span class="var">$inheritedPlayedRoles</span>. Calls the <span class="var">ObjectTypeInformation</span> template to get all the direct and inherited played roles of all its supertype.<br/>
						<span class="line">Lines 300 &ndash; 309</span>
					</li>
					<li id="directAndInheritedPlayedRoles">
						Combines <a href="#directPlayedRoles" class="var">$directPlayedRoles</a> and <a href="#inheritedPlayedRoles" class="var">$inheritedPlayedRoles</a> into <span class="var">$directAndInheritedPlayedRoles</span>.<br />
						<span class="line">Line 312</span>
					</li>
					<li id="inheritedFacts">
						Stores all fact types that contain at least one member of <a href="#inheritedPlayedRoles" class="var">$inheritedPlayedRoles</a> in <span class="var">$inheritedFacts</span>.<br/>
						<span class="line">Line 315</span>
					</li>
					<li id="directFacts">
						Stores all fact types that contain at least one member of <a href="#directPlayedRoles" class="var">$directPlayedRoles</a> in <span class="var">$directFacts</span>.<br/>
						<span class="line">Line 318</span>
					</li>
					<li id="directAndInheritedFacts">
						Combines <a href="#directFacts" class="var">$directFacts</a> and <a href="#indirectFacts" class="var">$indirectFacts</a> into <span class="var">$directAndInheritedFacts</span>.<br />
						<span class="line">Line 321</span>
					</li>
					<li id="directFactsOppositeRoles">
						Stores the roles opposite to <a href="#directPlayedRoles" class="var">$directPlayedRoles</a> in <a href="#directFacts" class="var">$directFacts</a> in <span class="var">$directFactsOppositeRoles</span>.<br/>
						<span class="line">Line 324</span>
					</li>
					<li id="preferredIdentifier">
						Stores the internal or external uniqueness constraint that marks the preferred identifier for this object type in <span class="var">$preferredIdentifier</span>.<br/>
						<span class="line">Line 327</span>
					</li>
					<li id="preferredIdentifierFacts">
						Stores the facts that <a href="#preferredIdentifier" class="var">$preferredIdentifier</a> constraints are on in <span class="var">$preferredIdentifierFacts</span>.<br/>
						<span class="line">Line 329</span>
					</li>
					<li id="nonPreferredIdentifierDirectFacts">
						Stores <a href="#directFacts" class="var">$directFacts</a> that are not <a href="#preferredIdentifierFacts" class="var">$preferredIdentifierFacts</a> in <span class="var">$nonPreferredIdentifierDirectFacts</span>.<br/>
						<span class="line">Line 332</span>
					</li>
					<li id="nonPreferredIdentifierInheritedFacts">
						Stores <a href="#inheritedFacts" class="var">$directFacts</a> that are not <a href="#preferredIdentifierFacts" class="var">$preferredIdentifierFacts</a> in <span class="var">$nonPreferredIdentifierInheritedFacts</span>.<br/>
						<span class="line">Line 335</span>
					</li>
					<li id="nonPreferredIdentifierDirectAndInheritedFacts">
						Stores <a href="#directAndInheritedFacts" class="var">$directAndInheritedFacts</a> that are not <a href="#preferredIdentifierFacts" class="var">$preferredIdentifierFacts</a> in <span class="var">$nonPreferredIdentifierDirectAndInheritedFacts</span>.<br/>
						<span class="line">Line 338</span>
					</li>
					<li id="mandatoryDirectPlayedRoles">
						Stores <a href="#directPlayedRoles" class="var">$directPlayedRoles</a> which have an alethic mandatory constraint on them (from the <a href="#AlethicSingleRoleMandatoryConstraints" class="var">$AlethicSingleRoleMandatoryConstraints</a> node-set) in <span class="var">$nonPreferredIdentifierDirectAndInheritedFacts</span>.<br/>
						<span class="line">Line 341</span>
					</li>
					<li id="mandatoryDirectFacts">
						Stores <a href="#directFacts" class="var">$directFacts</a> which contain at least one member of <a href="#mandatoryDirectPlayedRoles" class="var">$mandatoryDirectPlayedRoles</a> in <span class="var">$mandatoryDirectFacts</span>.<br/>
						<span class="line">Line 344</span>
					</li>
					<li id="mandatoryNonPreferredIdentifierDirectFacts">
						Stores <a href="#nonPreferredIdentifierFacts" class="var">$nonPreferredIdentifierFacts</a> which are also <a href="#mandatoryDirectFacts" class="var">$mandatoryDirectFacts</a> in <span class="var">$mandatoryNonPreferredIdentifierDirectFacts</span>.<br/>
						<span class="line">Line 347</span>
					</li>
					<!-- TODO: Once the TODO comment is taken out of the XSL, change the line numbers. -->
					<li id="dependentDirectFacts">
						Stores <a href="#directFacts" class="var">$directFacts</a> which this object type is functionally dependent on (using the <a href="#AlethicSingleRoleUniquenessConstraints" class="var">$AlethicSingleRoleUniquenessConstraints</a> node-set) in <span class="var">$dependentDirectFacts</span>.<br/>
						<span class="line">Line 351</span>
					</li>
					<li id="functionalDirectFacts">
						Stores <a href="#directFacts" class="var">$directFacts</a> which this object functionally determines (using the <a href="#AlethicSingleRoleUniquenessConstraints" class="var">$AlethicSingleRoleUniquenessConstraints</a> node-set) in <span class="var">$functionalDirectFacts</span>.<br/>
						<span class="line">Line 354</span>
					</li>
					<li id="mandatoryDependentFunctionalDirectFacts">
						Stores the intersection of <a href="#mandatoryDirectFacts" class="var">$mandatoryDirectFacts</a>, <a href="#dependentDirectFacts" class="var">$dependentDirectFacts</a>, and <a href="#functionalDirectFacts" class="var">$functionalDirectFacts</a> in <span class="var">$mandatoryDependentFunctionalDirectFacts</span>.<br/>
						<span class="line">Line 357</span>
					</li>
					<li id="functionalNonPreferredIdentifierDirectFacts">
						Stores <a href="#functionalDirectFacts" class="var">$functionalDirectFacts</a> that are not also <a href="#preferredIdentifierFacts" class="var">$preferredIdentifierFacts</a> in <span class="var">$functionalNonPreferredIdentifierDirectFacts</span>.<br/>
						<span class="line">Line 360</span>
					</li>
					<li id="nonDependentFunctionalNonPreferredIdentifierDirectFacts">
						Stores <a href="#functionalNonPreferredIdentifierDirectFacts" class="var">$functionalNonPreferredIdentifierDirectFacts</a> that are not also <a href="#dependentDirectFacts" class="var">$dependentDirectFacts</a> in <span class="var">$nonDependentFunctionalNonPreferredIdentifierDirectFacts</span>.<br/>
						<span class="line">Line 363</span>
					</li>
					<li id="mandatoryDependentFunctionalNonPreferredIdentifierDirectFacts">
						Stores the intersection of <a href="#mandatoryNonPreferredIdentifierDirectFacts" class="var">$mandatoryNonPreferredIdentifierDirectFacts</a>, <a href="#dependentDirectFacts" class="var">$dependentDirectFacts</a>, and <a href="#functionalNonPreferredIdentifierDirectFacts" class="var">$functionalNonPreferredIdentifierDirectFacts</a> in <span class="var">$mandatoryDependentFunctionalNonPreferredIdentifierDirectFacts</span>.<br/>
						<span class="line">Line 366</span>
					</li>
					<li>
						Outputs all of the above information in elements whose names are the names of the variables created in each section.<br/>
						<span class="line">Lines 368 &ndash; 438</span>
					</li>
				</ol><br/>
			</li>
			<!-- #5 -->
			<li>
				More diagnostics:
				<ol class="lalpha">
					<li id="IndependentObjectTypes">
						Stores the independent object types in <span class="var">$IndependentObjectTypes</span> using the information from <a href="#ObjectTypeInformation" class="var">$ObjectTypeInformation</a>.<br/>
						<span class="line">Line 75</span>
					</li>
					<li id="NonIndependentSubtypeObjectTypes">
						Stores the subtypes that are not independent in <span class="var">$NonIndependentSubtypeObjectTypes</span> using the information from <a href="#ObjectTypeInformation" class="var">$ObjectTypeInformation</a>.<br/>
						<span class="line">Line 77</span>
					</li>
					<li id="NonIndependentSubtypeSupertypeObjectTypes">
						Stores the supertypes that have at least one subtype that is not independent in <span class="var">$NonIndependentSubtypeSupertypeObjectTypes</span> by comparing the information from <a href="#ObjectTypeInformation" class="var">$ObjectTypeInformation</a> with the information from <a href="#NonIndependentSubtypeObjectTypes" class="var">$NonIndependentSubtypeObjectTypes</a>.<br/>
						<span class="line">Line 79</span>
					</li>
					<li>
						If <a href="#debug" class="var">$EnableAssertions</a> is true, then these lines check for spanning uniqueness constraints, implied facts from objectification, or any facts that are not binaries. If any of these exist, then the transform terminates and outputs an error message.<br/>
						<span class="line">Lines 81 &ndash; 89</span>
					</li>
				</ol><br/>
			</li>
			<!-- #6 -->
			<li id="FactTypeAbsorption">
				Fact type absorption algorithm to determine to which role player a one-to-one fact type will be absorbed. <strong>For each binary, one-to-one fact type in the diagram, the following steps are performed</strong>:<br/>
				<span class="line">Lines 91 &ndash; 178</span>
				<ol class="lalpha">
					<li id="factDiagnostics">
						Stores all the mandatory constraints on this fact type in <span class="var">$mandatories</span> using the <a href="#AlethicSingleRoleMandatoryConstraints" class="var">$AlethicSingleRoleMandatoryConstraints</a> node-set. Stores the number of those mandatory constraints in <span class="var">$countMandatories</span>. Stores the IDs of all the Roles in this fact type in <span class="var">$rolePlayerIds</span>. Stores the Role Players of those roles in <span class="var">$rolePlayers</span> using the <a href="#ObjectTypeInformation" class="var">$ObjectTypeInformation</a> node-set.<br/>
						<span class="line">Lines 94 &ndash; 97</span>
					</li>
					<li>
						Outputs an <span class="elem">&lt;AbsorbedFactType&gt;</span> element with a <span class="attr">ref</span> attribute, whose value is the ID of this fact type.<br/>
						<span class="line">Line 98</span>
					</li>
					<li>
						<strong>If</strong> there is only one mandatory role constraint, place the mandatory role player ID in <span class="var">$mandatoryRolePlayerId</span> and the non-mandatory role player (not the id) in <span class="var">$nonMandatoryRolePlayer</span>&hellip;<br/>
						<span class="line">Lines 99 &ndash; 103</span>
						<ol>
							<li id="firstTowardsId">
								<strong>If</strong> the potential absorber object type (the role player attached to the role without a mandatory role constraint) plays any functional roles (other than the current one) that are not part of its preferred identifier, then it is absorbed <span class="attr">towards</span> the <span class="var">$nonMandatoryRolePlayer</span> with an absorption <span class="attr">type</span> of 'fully' (i.e. all of the objects attached to the mandatory role player are absorbed into this object type). If <a href="#debug" class="var">$OutputDebugInformation</a> is true, we will also have the <span class="attr">towardsName</span> of the absorber Object.<br/>
								<span class="line">Lines 104 &ndash; 119</span>
							</li>
							<li>
								<strong>Otherwise</strong>, absorb <span class="attr">towards</span> the mandatory role player's <span class="var">$mandatoryRolePlayerId</span> with an absorption <span class="attr">type</span> of 'factOnly'. If <a href="#debug" class="var">$OutputDebugInformation</a> is true, we will also have the <span class="attr">towardsName</span> of the absorber Object from <a href="#factDiagnostics" class="var">$rolePlayers</a>.<br/>
								<span class="line">Lines 119 &ndash; 133</span>
							</li>
						</ol>
					</li>
					<li>
						<p id="towardsId">
							<strong>Otherwise, if zero or both roles are mandatory</strong>, store the first (by appearance in the XML file) role player in <span class="var">$firstRolePlayer</span>, the second role player in <span class="var">$secondRolePlayer</span>, a count of the first role player's <a href="#nonDependentFunctionalNonPreferredIdentifierDirectFacts" class="var">$nonDependentFunctionalNonPreferredIdentifierDirectFacts</a> in <span class="var">$firstRolePlayerCountNonDependentFunctionalNonPreferredIdentifierDirectFacts</span>, and a count of the second role player's <a href="#nonDependentFunctionalNonPreferredIdentifierDirectFacts" class="var">$nonDependentFunctionalNonPreferredIdentifierDirectFacts</a> in <span class="var">$secondRolePlayerCountNonDependentFunctionalNonPreferredIdentifierDirectFacts</span>. The role player which has more non-dependent, functional, non-preferred-identifier facts is the absorber, whose ID is stored in <span class="var">$towardsId</span>. If the numbers are equal, it is absorbed into the first role player by default.
						</p>
						<span class="line">Lines 135 &ndash; 149</span>
						<p>
							The value of <a href="#towardsId" class="var">$towardsId</a> is placed in the <span class="attr">towards</span> attribute. If there are zero mandatory role constraints, then the absorption <span class="attr">type</span> is 'factOnly'; if there are two, then the absorption <span class="type">type</span> is 'fully'. If neither constraint is fulfilled, then the transform terminates if <a href="#debug" class="var">$EnableAssertions</a> is true. If <a href="#debug" class="var">$OutputDebugInformation</a> is true, we will also have the <span class="attr">towardsName</span> of the absorber Object from <a href="#factDiagnostics" class="var">$rolePlayers</a>.
						</p>
						<span class="line">Lines 150 &ndash; 177</span>
					</li>
					<li>
						Makes a node-set out of the fragment created from the previous lines.<br/>
						<span class="line">Line 178</span>
					</li>
				</ol><br/>
			</li>
			<!-- #7 -->
			<li id="ObjectTypeAbsorption">
				Object type absorption algorithm to determine to which object types other object types get absorbed:<br/>
				<span class="line">Lines 180 &ndash; 214</span>
				<ol class="lalpha">
					<li>
						For each member in <a href="#NonIndependentSubtypeObjectTypes" class="var">$NonIndependentSubtypeObjectTypes</a>, find its supertype ID to store in <span class="var">$absorbingSupertypeId</span>, and then outputs an <span class="elem">&lt;AbsorbedObjectType&gt;</span> with <span class="attr">ref</span> (the current object type's ID) and <span class="attr">towards</span> (the <span class="var">$absorbingSupertypeId</span>). If <a href="#debug" class="var">$OutputDebugInformation</a> is true, then it also outputs the <span class="attr">refName</span> (the current object type's name) and <span class="attr">towardsName</span> (the supertype's name).<br/>
						<span class="line">Lines 181 &ndash; 193</span>
					</li>
					<li>
						For each object type that is non-independent, non-subtype that plays at least one mandatory functional role in a fact type on which that object type is functionally dependent (<a href="#mandatoryDependentFunctionalDirectFacts" class="var">$mandatoryDependentFunctionalDirectFacts</a>), the ID of the object type is stored in <span class="var">$specialCaseObjectTypeId</span>.<br/>
						<span class="line">Lines 195 &ndash; 196</span>
						<ol>
							<li>
								For each fact type in <a href="#FactTypeAbsorption" class="var">$FactTypeAbsorptions</a> that is a member of the <a href="#mandatoryDependentFunctionalDirectFacts" class="var">$mandatoryDependentFunctionalDirectFacts</a> of this object type, then make sure this is an absorption of type 'fully' and the object type is not absorbing itself. If so, an <span class="elem">&lt;AbsorbedObjectType&gt;</span> element is created with <span class="attr">ref</span> (the current object type's ID) and <span class="attr">towards</span> (the <a href="#firstTowardsId" class="var">$towards</a> of the FactTypeAbsorption). If <a href="#debug" class="var">$OutputDebugInformation</a> is true, then it also outputs the <span class="attr">refName</span> (the current object type's name) and <span class="attr">towardsName</span> (the name of the absorbing object type).<br/>
								<span class="line">Lines 197 &ndash; 212</span>
							</li>
						</ol>
					</li>
				</ol><br/>
			</li>
			<!-- #8 -->
			<li id="TopLevelTypes">
				Top level object type algorithm that determines what object types are "top-level," which means that they are directly mapped as direct children of the root node in the resulting OIAL document.<br/>
				<span class="line">Lines 217 &ndash; 228</span>
				<ol class="lalpha">
					<li>
						Gets the object types that are not independent, not subtypes, and play at least one functional role (not including roles on preferred identifier facts) or supertype meta role that isn't absorbed away from that object type. In other words, it has at least one member of <a href="#functionalDirectFacts" class="var">$functionalDirectFacts</a>, is not a member of <a href="#IndependentObjectTypes" class="var">$IndependentObjectTypes</a> or <a href="#NonIndependentSubtypeObjectTypes" class="var">$NonIndependentSubtypeObjectTypes</a> or object types that are absorbed (<a href="#ObjectTypeAbsorption" class="var">$ObjectTypeAbsorptions</a>).<br/>
						<span class="line">Line 218</span>
					</li>
					<li id="NonAbsorbedFunctionalRolePlayingObjectTypes">
						For each of those object types mentioned in the previous section, it stores a temporary variable of all members of <a href="#FactTypeAbsorption" class="var">$FactTypeAbsorptions</a> which are not absorbed toward the current object type in <span class="var">$factTypeAbsorptionsAwayFromThisObjectType</span>. If the object type is a member of <a href="#NonIndependentSubtypeSupertypeObjectTypes" class="var">$NonIndependentSubtypeSupertypeObjectTypes</a> or none of its <a href="#functionalNonPreferredIdentifierDirectFacts" class="var">$functionalNonPreferredIdentifierDirectFacts</a> are in the <span class="var">$factTypeAbsorptionsAwayFromThisObjectType</span> node-set, then it copies them into the <span class="var">$NonAbsorbedFunctionalRolePlayingObjectTypes</span>.<br/>
						<span class="line">Lines 219 &ndash; 225</span>
					</li>
					<li>
						Unions the <a href="#NonAbsorbedFunctionalRolePlayingObjectTypes" class="var">$NonAbsorbedFunctionalRolePlayingObjectTypes</a> and <a href="#IndependentObjectTypes" class="var">$IndependentObjectTypes</a> in the <span class="var">$TopLevelTypes</span> variable.<br/>
						<span class="line">Line 228</span>
					</li>
				</ol><br/>
			</li>
			<!-- #9 -->
			<li>
				Outputs the root element of the OIAL file, <span class="elem">&lt;oil:model&gt;</span> with <span class="attr">name</span> and <span class="attr">sourceRef</span> attributes, representing the name and ID of the <a href="#Model" class="var">$Model</a>, respectively.<br/>
				<span class="line">Line 230</span><br/><br/>
			</li>
			<!-- #10 -->
			<li>
				If <a href="#debug" class="var">$OutputDebugInformation</a> is true, it outputs a <span class="elem">&lt;DEBUG_INFORMATION&gt;</span> element whose contents include information from the <a href="#FactTypeAbsorption" class="var">$FactTypeAbsorptions</a>, <a href="#ObjectTypeAbsorption" class="var">$ObjectTypeAbsorptions</a>, and <a href="#TopLevelTypes" class="var">$TopLevelTypes</a>.<br/>
				<span class="line">Lines 232 &ndash; 260</span>
			</li>
		</ol>
		<!-- ############################# -->
		<hr/>
		<h4>Transformation Process: Interpretation Phase</h4>
		<ol>
			<!-- Interpretation #1 -->
			<li>
				<span class="elem">&lt;oil:informationTypeFormats&gt;</span> are generated for each Value Type object through the template for <span class="xpath">orm:ValueType</span> with mode "GenerateInformationTypeFormat" starting on Line 440, passing the <a href="#Model" class="var">$Model</a> variable as a parameter.<br/>
				<span class="line">Lines 262 &ndash; 268, 440 &ndash; 555</span>
				<ol class="lalpha">
					<li id="itfDiagnostics">
						<!-- TODO: Talk to Kevin about possibly invalid XPath for the modelValueRanges-->
						Stores the name of the Value Type in <span class="var">$dataTypeName</span>, the conceptual data type for this value type in <span class="var">$modelConceptualDataType</span>, the physical data type for this value type (based off the conceptual data type) in <span class="var">$modelDataType</span>, and the individual value restrictions (if any) in the <span class="var">$modelValueRanges</span> node-set. <span class="var">$length</span> and <span class="var">$scale</span> record the string-length and scale of the orm:conceptualDataType, respectively.<br/>
						<span class="line">Lines 440 &ndash; 447</span>
					</li>
					<li id="odtIdentity">
						<strong>If</strong> the <a href="#itfDiagnostics" class="var">$modelDataType</a> is an <span class="xpath">orm:AutoCounterNumericDataType</span> or a <span class="xpath">orm:RowIdOtherDataType</span>, then output an <span class="elem">&lt;odt:identity&gt;</span> element with a <span class="attr">name</span> whose value is the <a href="#itfDiagnostics" class="var">$dataTypeName</a>.<br/>
						<span class="line">Lines 449 &ndash; 452</span>
					</li>
					<li id="odtBoolean">
						<strong>Else if</strong> the <a href="#itfDiagnostics" class="var">$modelDataType</a> is an <span class="xpath">orm:TrueOrFalseLogicalDataType</span> or a <span class="xpath">orm:YesOrNoLogicalDataType</span>, then output an <span class="elem">&lt;odt:boolean&gt;</span> element with a <span class="attr">name</span> whose value is the <a href="#itfDiagnostics" class="var">$dataTypeName</a>. If there is a value constraint on it (<a href="#itfDiagnostics" class="var">$modelValueRanges</a>), then the MinValue will always equal the MaxValue of the individual restriction, so a <span class="attr">fixed</span> attribute is appended with the MinValue of the individual restriction.<br/>
						<span class="line">Lines 453 &ndash; 462</span>
					</li>
					<li id="odtDecimalNumber">
						<strong>Else if</strong> the <a href="#itfDiagnostics" class="var">$modelDataType</a> is an <span class="xpath">orm:SignedIntegerNumericDataType</span>, <span class="xpath">orm:UnsignedIntegerNumericDataType</span>, <span class="xpath">orm:DecimalNumericDataType</span>, or a <span class="xpath">orm:MoneyNumericDataType</span>, then output an <span class="elem">&lt;odt:decimalNumber&gt;</span> element with a <span class="attr">name</span> whose value is the <a href="#itfDiagnostics" class="var">$dataTypeName</a>. If there is a <a href="#itfDiagnostics" class="var">$length</a> that is not 0, then this maps to a <span class="attr">totalDigits</span> attribute which contains this value. The <span class="attr">fractionDigits</span> attribute will also exist and equal the <a href="#itfDiagnostics" class="var">$scale</a> if it is not equal to 0 and the current element is not an  <span class="xpath">orm:SignedIntegerNumericDataType</span> or <span class="xpath">orm:UnsignedIntegerNumericDataType</span>.<br/>
						<span class="line">Lines 463 &ndash; 484</span>
						<ol>
							<li id="ProcessValueRange">
								The template for <span class="xpath">orm:ValueRange</span> with mode "ProcessValueRange" is called to interpret the value constraints on this Information Type Format. <strong>If</strong> the <span class="xpath">MinValue</span> and <span class="xpath">MaxValue</span> are the same, then an <span class="elem">&lt;odt:enumeration&gt;</span> element is output with <span class="xpath">MinValue</span> inside the <span class="attr">value</span> attribute. <strong>Otherwise</strong>, outputs <span class="elem">&lt;odt:range&gt;</span> element, whose <span class="elem">&lt;odt:lowerBound&gt;</span> has the <span class="attr">value</span> equals the <span class="xpath">MinValue</span> and a <span class="attr">clusivity</span> attribute which calls the <a href="#GetClusivity" class="var">GetClusivity</a> template to get its information. It also does the same thing for an <span class="elem">&lt;odt:upperBound&gt;</span> that it does for a <span class="elem">&lt;odt:lowerBound&gt;</span> element.<br/>
								<span class="line">Lines 946 &ndash; 974</span>
							</li>
							<li id="GetClusivity">
								The template <span class="var">GetClusivity</span> is passed a parameter; this templates tests for when that parameter equals 'Open.' If it does, then it outputs 'exclusive'; otherwise, 'inclusive.'<br/>
								<span class="line">Lines 921 &ndash; 931</span>
							</li>
						</ol>
					</li>
					<li id="odtFloatingPoint">
						<strong>Else if</strong> the <a href="#itfDiagnostics" class="var">$modelDataType</a> is an <span class="xpath">orm:FloatingPointNumericDataType</span>, outputs a <span class="elem">&lt;odt:floatingPointNumber&gt;</span> element with a <span class="attr">name</span> whose value is the <a href="#itfDiagnostics" class="var">$dataTypeName</a> and a <span class="attr">precision</span> attribute with the value of the <a href="#itfDiagnostics" class="var">$scale</a>. It then processes the <a href="#ProcessValueRange" class="var">value range</a> for its inner elements.<br/>
						<span class="line">Lines 485 &ndash; 490</span>
					</li>
					<li id="odtString">
						<strong>Else if</strong> the <a href="#itfDiagnostics" class="var">$modelDataType</a> is an <span class="xpath">orm:FixedLengthTextDataType</span>, <span class="xpath">orm:VariableLengthTextDataType</span>, <span class="xpath">orm:LargeLengthTextDataType</span>, or a <span class="xpath">orm:MoneyNumericDataType</span>, then output an <span class="elem">&lt;odt:string&gt;</span> element with a <span class="attr">name</span> whose value is the <a href="#itfDiagnostics" class="var">$dataTypeName</a>. <strong>If</strong> the <a href="#itfDiagnostics" class="var">$length</a> is greater than 0, then the <span class="attr">maxLength</span> attribute will contain that value. If that is true and this fact is an <span class="xpath">orm:FixedLengthDataType</span>, then a <span class="attr">minLength</span> attribute will also contain that value. Then the <a href="#itfDiagnostics" class="var">$modelValueRanges</a> are processed. <strong>If</strong> the <span class="xpath">MinValue</span> and <span class="xpath">MaxValue</span> are the same, then an <span class="elem">&lt;odt:enumeration&gt;</span> element is output with <span class="xpath">MinValue</span> inside the <span class="attr">value</span> attribute. <strong>Otherwise</strong>, an <span class="elem">&lt;odt:pattern&gt;</span> element is output whose value is a RegEx Pattern in the format <span class="xpath">[@MinValue-@MaxValue]</span>.<br/>
						<span class="line">Lines 491 &ndash; 522</span>
					</li>
					<li id="odtBinary">
						<!-- TODO: Talk to Kevin about possible error on Line 524 -->
						<strong>Else if</strong> the <a href="#itfDiagnostics" class="var">$modelDataType</a> is an <span class="xpath">orm:FixedLengthRawDataDataType</span>, <span class="xpath">orm:VariableLengthRawDataDataType</span>, <span class="xpath">orm:LargeLengthRawDataDataType</span>, <span class="xpath">orm:PictureRawDataDataType</span>, or a <span class="xpath">orm:OleObjectRawDataDataType</span>, then output an <span class="elem">&lt;odt:binary&gt;</span> element with a <span class="attr">name</span> whose value is the <a href="#itfDiagnostics" class="var">$dataTypeName</a>. <strong>If</strong> the <a href="#itfDiagnostics" class="var">$length</a> is greater than 0, then the <span class="attr">maxLength</span> attribute will contain that value. If that is true and this fact is an <span class="xpath">orm:FixedLengthRawDataDataType</span>, then a <span class="attr">minLength</span> attribute will also contain that value.<br/>
						<span class="line">Lines 523 &ndash; 536</span>
					</li>
					<li id="odtTemporal">
						<strong>Else if</strong> the <a href="#itfDiagnostics" class="var">$modelDataType</a> is an <span class="xpath">orm:AutoTimestampTemporalDataType</span>, <span class="xpath">orm:TimeTemporalDataType</span>, <span class="xpath">orm:DateTemporalDataType</span>, <span class="xpath">orm:DateAndTimeTemporalDataType</span>, then output a message that ORM2 does not currently support those types, and instead output an <span class="elem">&lt;odt:decimalNumber&gt;</span> element with a <span class="attr">name</span> attribute whose value is the <a href="#itfDiagnostics" class="var">$dataTypeName</a> and <span class="attr">fractionDigits</span> attribute with value 0.<br/>
						<span class="line">Lines 537 &ndash; 543</span>
					</li>
					<li id="odtUnknown">
						<strong>Else</strong> output that the data type selected is not currently supported.<br/>
						<span class="line">Lines 544 &ndash; 555</span>
					</li>
				</ol><br/>
			</li>
			<!-- Interpretation #2: ConceptTypes -->
			<li>
				<span class="elem">&lt;oil:conceptType&gt;</span> elements are generated for each TopLevelType object through the template for <span class="xpath">orm:EntityType | orm:ValueType</span> with mode "GenerateConceptTypes" starting on Line 557, passing the <a href="#Model" class="var">$Model</a>, <a href="#SingleRoleMandatoryConstraints" class="var">$SingleRoleMandatoryConstraints</a>, <a href="#SingleRoleUniquenessConstraints" class="var">$SingleRoleUniquenessConstraints</a>, <a href="#SingleRoleUniquenessConstraints" class="var">$SingleRoleUniquenessConstraints</a>, <a href="#ObjectTypeInformation" class="var">$ObjectTypeInformation</a>, <a href="#FactTypeAbsorption" class="var">$FactTypeAbsorptions</a>, <a href="#ObjectTypeAbsorption" class="var">$ObjectTypeAbsorptions</a>, and <a href="#TopLevelTypes" class="var">$TopLevelTypes</a>.<br/>
				<span class="line">Lines 270 &ndash; 278</span>
				<ol class="lalpha">
					<li id="conceptDiagnostics">
						Receives parameters from the template and stores the current <span class="xpath">@id</span> in <span class="var">$thisObjectTypeId</span>, the <span class="xpath">@Name</span> in <span class="var">$thisObjectTypeName</span>, and the current node in <span class="var">$thisObjectTypeInformation</span>.<br/>
						<span class="line">Lines 557 &ndash; 570</span>
					</li>
					<li>
						Outputs an <span class="elem">&lt;oil:conceptType&gt;</span> element whose <span class="attr">name</span> is equal to <a href="#conceptDiagnostics" class="var">$thisObjectTypeName</a> and <span class="attr">sourceref</span> is equal to <a href="#conceptDiagnostics" class="var">$thisObjectTypeId</a>. If its <span class="xpath">$Mandatory</span> and <span class="xpath">$SourceRoleRef</span> parameters exist, attributes are generated for each of those parameters with the same name in Camel case.<br/>
						<span class="line">Lines 572 &ndash; 581</span>
					</li>
					<li>
						If the current object type in this template is an <span class="xpath">orm:ValueType</span>, we need to record an <span class="elem">&lt;oil:InformationType&gt;</span> to capture the data inside. This element has a <span class="attr">name</span> attribute which is <a href="#conceptDiagnostics" class="var">$thisObjectTypeName</a> + "Value," a <span class="attr">mandatory</span> attribute which is "alethic," a <span class="attr">sourceRef</span> attribute which is <a href="#conceptDiagnostics" class="var">$thisObjectTypeId</a>, and a <span class="attr">formatRef</span> attribute which is <a href="#conceptDiagnostics" class="var">$thisObjectTypeName</a>. Inside of this element is a <span class="elem">&lt;oil:singleRoleUniquenessConstraint&gt;</span>, which has a <span class="attr">name</span> attribute which is <a href="#conceptDiagnostics" class="var">$thisObjectTypeName</a> + "Value_Unique," a <span class="attr">modality</span> attribute which is "alethic," a <span class="attr">sourceRef</span> attribute which is <a href="#conceptDiagnostics" class="var">$thisObjectTypeId</a>, and an <span class="attr">isPreferred</span> attribute which is "true."<br/>
						<span class="line">Lines 584 &ndash; 588</span>
					</li>
					<li id="conceptFacts">
						Afterwards, we store the meta facts of subtypes that this object type is absorbing in <span class="var">$absorbedSubtypeMetaFacts</span> and the functional direct facts of this object type that are not absorbed away from this object type in <span class="var">$absorbedFunctionalDirectFacts</span>.<br/>
						<span class="line">Lines 591 &ndash; 594</span>
					</li>
					<li>
						<strong>For each Fact Type</strong> that is either a member of <a href="#conceptFacts" class="var">$absorbedSubtypeMetaFacts</a> or <a href="#conceptFacts" class="var">$absorbedFunctionalDirectFacts</a>, the following occurs&hellip;:<br/>
						<span class="line">Lines 597 &ndash; 722</span>
						<ol>
							<li id="conceptInits">
								Initializes the following the variables: <span class="var">$thisRole</span> as the role that this object type plays in the current fact type, <span class="var">$thisRoleId</span> as the ID of this role, <span class="var">$oppositeRole</span> as the role that this object type does not play in the current fact type, <span class="var">$oppositeRoleId</span> as the ID of the opposite role, <span class="var">$oppositeRolePlayerId</span> as the ID of the object type that plays that opposite role, <span class="var">$oppositeRolePlayer</span> as the object type that plays that opposite role, and <span class="var">$oppositeRolePlayerName</span> as the name of the object type that plays that opposite role. We next try to determine what object type the opposite role player will ultimately be absorbed into by using the <span class="xpath">GetTopLevelId</span> template, passing <a href="#ObjectTypeAbsorption" class="var">$ObjectTypeAbsorptions</a>, <a href="#TopLevelTypes" class="var">$TopLevelTypes</a>, <a href="#conceptFacts" class="var">$oppositeRolePlayerId</a>, and <a href="#DesiredParentId" class="var">$thisObjectTypeId</a> and then store the result in <span class="var">$oppositeRolePlayerDesiredParentOrTopLevelTypeId</span>:<br/>
								<span class="line">Lines 598 &ndash; 612</span>
								<ol class="lalpha">
									<li id="GetTopLevelId">
										The <span class="xpath">GetTopLevelId</span> template receives the parameters for <span class="xpath">ObjectTypeAbsorptions</span>, <span class="xpath">TopLevelTypes</span>, <span class="xpath">TargetId</span>, and optionally, <span class="xpath">DesiredParentId</span>.<br/>
										<span class="line">Lines 885 &ndash; 890</span>
									</li>
									<li id="topLevelTowards">
										Next it stores the ID of the object type into which this current object type is absorbed in <span class="var">$towardsId</span> by examining <a href="#ObjectTypeAbsorption" class="var">$ObjectTypeAbsorptions</a>.<br/>
										<span class="line">Line 891</span>
									</li>
									<li>
										The next test is whether the <span class="var">$TargetId</span> exists. <strong>If</strong> it doesn't, nothing is done and control resumes in the previous template.<br/>
										<strong>If</strong> the <span class="var">$TargetId</span> is the ID of a top-level object type, then output that ID and resume control in the previous template.<br/>
										<strong>If</strong> the <a href="#topLevelTowards" class="var">$towardsId</a> is equal to the <a href="#topLevelTowards" class="var">$DesiredParentId</a>, then output that ID and resume control in the previous template.<br/>
										<strong>Otherwise</strong>, call this <a href="#topLevelTowards" class="var">template</a> recursively, setting the <span class="xpath">TargetId</span> parameter as <a href="#topLevelTowards" class="var">$towardsId</a> until a top-level object type is found.<br/>
										<span class="line">Lines 892 &ndash; 909</span>
									</li>
								</ol>
							</li>
							<li>
								Initializes another variable called <span class="var">$mandatory</span>. To find the value for this variable, another variable&mdash;<span class="var">$simpleMandatoryConstraint</span>&mdash;is created and initialized with the mandatory role constraint from <a href="#conceptInits" class="var">$thisRoleId</a> (if it exists). If it exists, it calls the <span class="xpath">GetModality</span> template to retrieve the modality of the constraint. Otherwise its value is set to 'false.'<br/>
								<span class="line">Lines 613 &ndash; 625</span>
								<ol class="lalpha">
									<li id="GetModality">
										The <span class="xpath">GetModality</span> template accepts a parameter called <span class="xpath">Target</span> which should be a constraint. If the target's <span class="xpath">@Modality</span> is 'Deontic,' it returns 'Deontic.' Otherwise, it returns 'Alethic.'<br/>
										<span class="line">Lines 910 &ndash; 920</span>
									</li>
								</ol>
							</li>
							<li>
								Initializes yet another two variables called <span class="var">$name</span> and <span class="var">$oppositeName</span>. <span class="var">$name</span> holds the <span class="xpath">@Name</span> of the <a href="#conceptInits" class="var">$oppositeRole</a> if it exists. If not, then it holds the <a href="#conceptInits" class="var">$oppositeRolePlayerName</a>. The same processing is done for <span class="var">$oppositeName</span>; however, it looks for the <span class="xpath">@Name</span> of <a href="#conceptInits" class="var">$thisRole</a> or <a href="#conceptDiagnostics" class="var">$thisObjectTypeName</a>.<br/>
								<span class="line">Lines 626 &ndash; 645</span>
							</li>
							<li id="conceptUniqueness">
								Another variable, <span class="var">$oppositeOilUniquenessConstraint</span>, is initialized to contain a <span class="elem">&lt;oil:singleRoleUniquenessConstraint&gt;</span> if a variable called <span class="var">$uniquenessConstraint</span>, which looks a single uniqueness constraint on the <a href="#conceptInits" class="var">$oppositeRole</a>, exists. If it does exist, <span class="attr">modality</span> is added from the result from the <a href="#GetModality" class="var">GetModality</a> template, and the <span class="attr">isPreferred</span> checks the <a href="#preferredIdentifier" class="var">$preferredIdentifier</a> list of constraints for whether the current constraint is there. If so, it is true; otherwise, false.<br/>
								<span class="line">Lines 646 &ndash; 660</span>
							</li>
							<li id="conceptConstraints">
								In addition to the uniqueness constraint variable, other constraints have to be handled. Frequency constraints are currently not stored anywhere, but they will be stored in <span class="var">$oppositeOilFrequencyConstraint</span>. Value constraints for both this role and the opposite role will be stored in <span class="var">$thisOilValueConstraint</span> and <span class="var">$oppositeOilValueConstraint</span>, respectively. This calls the <span class="xpath">GetOilValueConstraint</span> template:<br/>
								<span class="line">Lines 661 &ndash; 675</span>
								<ol class="lalpha">
									<li id="GetOilValueConstraint">
										The <span class="xpath">GetOilValueConstraint</span> template accepts a parameter called <span class="xpath">Role</span> and <span class="xpath">AppliesTo</span> which should be a constraint. The <span class="xpath">Role</span> parameter is used to find any RoleValueConstraints that exist on that Role. For each of those RoleValueConstraints, an <span class="elem">&lt;oil:ValueConstraint&gt;</span> element is output with a <span class="attr">name</span> attribute (containing <span class="xpath">@Name</span> of the Role), <span class="attr">sourceRef</span> attribute (containing <span class="xpath">@id</span> of the Role), and <span class="attr">appliesTo</span> attribute (containing <span class="xpath">AppliesTo</span> parameter value). This also uses the <a href="#GetModality" class="var">GetModality</a> template to append a <span class="attr">modality</span> attribute. Finally it uses the <a href="#ProcessValueRange" class="var">ProcessValueRange</a> template to append the details of its RoleValueConstraints.<br/>
										<span class="line">Lines 932 &ndash; 945</span>
									</li>
								</ol>
							</li>
							<li id="conceptCoreConstraints">
								All of these constraints are fully copied into an <span class="var">$oilConstraints</span> variable.<br/>
								<span class="line">Lines 676 &ndash; 683</span>
							</li>
							<li>
								<strong>If</strong> an <a href="#conceptDiagnostics" class="var">$oppositeRolePlayerDesiredParentOrTopLevelTypeId</a> does not exist in the current context, then we call the template <span class="xpath">GetOilInformationTypes</span>:<br/>
								<span class="line">Lines 683 &ndash; 696</span>
								<ol class="lalpha">
									<li id="GetOilInformationTypes">
										The <span class="xpath">GetOilInformationTypes</span> template receives the following parameters: <span class="xpath">Model</span> (the ORMModel), <span class="xpath">ObjectTypeInformation</span> (<a href="#ObjectTypeInformation" class="var">$ObjectTypeInformation</a>), <span class="xpath">RolePlayer</span>, <span class="xpath">Mandatory</span>, <span class="xpath">SourceRoleRef</span>, <span class="xpath">BaseName</span>, and <span class="xpath">OilConstraints</span>. Next this template calls the <span class="xpath">GetOilInformationTypesInternal</span> template, with the same parameters that it received<br/>
										<span class="line">Lines 977 &ndash; 984</span>
										<ol>
											<li id="GetOilInformationTypesInternal">
												The <span class="xpath">GetOilInformationTypesInternal</span> accepts the same parameters as its sister template except for the addition of one, <span class="xpath">IsFirst</span>, which defaults to true. This last parameter is used for determining the name of the InformationType being generated. If it's true, then we will use the original $BaseName; otherwise we will concatenate the BaseName with the name of the next Role Player in the object model (<em>e.g.</em> <strong>ModelingLanguage</strong>_<strong>ModelingLanguage_Name</strong>). These kinds of formations are done by recursive calls to the template.<br/>
												<span class="line">Lines 1009 &ndash; 1018</span>
											</li>
											<li>
												<strong>If</strong> the passed <a href="#GetOilInformationTypesInternal" class="var">$RolePlayer</a> is a ValueType, then <strong>if</strong> <a href="#GetOilInformationTypesInternal" class="var">$IsFirst</a> is true, it stores the value of <a href="#GetOilInformationTypesInternal" class="var">$BaseName</a> in a new variable <span class="var">$name</span>. <strong>Otherwise</strong>, the value of <span class="var">$name</span> is <span class="xpath">$BaseName</span> + "_" + <span class="xpath">$RolePlayer/@Name</span>. An <span class="elem">&lt;oil:InformationType&gt;</span> element is created with the following attributes: <span class="attr">name</span> which is <span class="var">$name</span>, <span class="attr">mandatory</span> which is <span class="xpath">$Mandatory</span>, a <span class="attr">sourceRef</span> attribute which is <span class="xpath">@id</span> of the element that called this template, a <span class="attr">sourceRoleRef</span> which equals the <span class="xpath">$SourceRoleRef</span> parameter passed to this template, and a <span class="attr">formatRef</span> attribute which is <a href="#conceptDiagnostics" class="var">$thisObjectTypeName</a> (this links this information type with an appropriate information type format).<br/>
												<span class="line">Lines 1019 &ndash; 1034</span>
											</li>
											<li>
												<strong>Otherwise</strong>, if the passed <a href="#GetOilInformationTypesInternal" class="var">$RolePlayer</a> is not a ValueType, it creates a <span class="var">$newBaseName</span> which concatenates the name of the role players over which it has navigated to get from the Top Level Type to the current Object Type. It then calls the GetOilInformationTypesInternal template for each preferred identifier fact that the current object type plays in order to get a name that suitably represents the path to the identifier object type.<br/>
												<span class="line">Lines 1035 &ndash; 1066</span>
											</li>
										</ol>
									</li>
									<li>
										These information types are copied directly to the result document. If there is more than one information type (which implies that the <a href="conceptInits" class="var">$oppositeRolePlayer</a> had more information that it absorbed) and they are not all alethicly mandatory, then we must spit an equality constraint for those information types.<br/>
										<span class="line">Lines 999 &ndash; 1007</span>
									</li>
								</ol>
							</li>
							<li>
								<strong>Otherwise, if</strong> the <a href="#conceptInits" class="var">$oppositeRolePlayerDesiredParentOrTopLevelTypeId</a> does equal <a href="#conceptInits" class="var">$thisObjectTypeId</a>, which means that there is an AbsorbedObjectType in <a href="#ObjectTypeAbsorption" class="var">$ObjectTypeAbsorptions</a> which represents that relationship, then the <a href="#conceptInits" class="var">$oppositeRolePlayer</a> is also a concept type, and we must call this template again to generate its information types.<br/>
								<span class="line">Lines 697 &ndash; 710</span>
							</li>
							<li>
								<strong>Otherwise, if</strong> the <a href="#conceptInits" class="var">$oppositeRolePlayer</a> is a <a href="#TopLevelTypes" class="var">$TopLevelTypes</a> or is absorbed through an <a href="#ObjectTypeAbsorption" class="var">$ObjectTypeAbsorptions</a> element, then we generate a <span class="elem">&lt;oil:conceptTypeRef&gt;</span> element with attributes for <span class="attr">name</span>, <span class="attr">target</span>, <span class="attr">oppositeName</span>, <span class="attr">mandatory</span>, and <span class="attr">sourceRoleRef</span> <!-- TODO: Elaborate on these attributes.-->.<br/>
								<span class="line">Lines 711 &ndash; 715</span>
							</li>
							<li>
								<strong>Otherwise, </strong> an error occurs and the transform terminates.<br/>
								<span class="line">Lines 716 &ndash; 720</span>
							</li>
						</ol>
					</li>
					<li>
						The final process is to transform the external constraints for more processing later on. <strong>For each</strong> constraint that spans more than two roles and span at least one role which is a member of <a href="#directFactsOppositeRoles" class="var">$directFactsOppositeRoles</a>, do the following:<br/>
						<span class="line">Line 725</span>
						<ol>
							<li id="roleSequence">
								Deemed unstable and in need of work...<br/>
								<span class="line">Lines 727 &ndash; 795</span>
							</li>
							<li>
								<strong>If</strong> the current element is an <span class="xpath">orm:UniquenessConstraint</span>, then add an <span class="elem">&lt;oil:roleSequenceUniquenessConstraint&gt;</span> element with attributes for <span class="attr">name</span> (<span class="xpath">@Name</span>), <span class="attr">modality</span> (<span class="xpath">$modality</span>), and <span class="attr">sourceRef</span> (<span class="xpath">@sourceRef</span>). It then determines whether the external uniqueness constraint is a preferred identifer and displays it with the <span class="attr">isPreferred</span> attribute. It then copies what <a href="#roleSequence" class="var">$roleSequences</a> exist into the current element.<br/>
								<span class="line">Lines 806 &ndash; 813</span>
							</li>
						</ol>
					</li>
				</ol>
			</li>
		</ol>
		<hr/>
		<h4>OIAL Constructs</h4>
		<ol>
			<li id="cttInformationTypeFormats">
				<strong>Information Type Formats</strong>
				<br/>
				<br/>
				Information Type Formats are an independent collection of "base data types" that all Information Types use as their data types. The main mapping for information types is to create one for each value type on the diagram. For example:
				<div style="text-align:center">
					<img alt="First Demo Information Type Formats" src="oial_demo_one.png"/>
				</div>
				In this diagram, there are 4 value types: A_Name, B_ID, C_Money, E_Picture, and T. All of these are directly mapped to Information Type Formats. Assuming that their names represent their types, A_Name is mapped to an <span class="elem">&lt;odt:string&gt;</span>; B_ID is mapped to an <span class="elem">&lt;odt:identity&gt;</span>; C_Money is mapped to <span class="elem">&lt;odt:decimalNumber&gt;</span>; E_Picture is mapped to <span class="elem">&lt;odt:binary&gt;</span>; and T is mapped to <span class="elem">&lt;odt:decimalNumber&gt;</span>.
				<br/><br/>
			</li>
			<li id="cttConceptType">
				<strong>Concept Type</strong>
				<br/><br/>
				Any top level type will automatically map to a concept type.<br/><br/>
				Additionally, any object types that are absorbed into any other concept type (via the <a href="#ObjectTypeAbsorption" class="var">$ObjectTypeAbsorptions</a> variable) are also considered concept types, even though they are not top level. For example:<br/>
				<div style="text-align:center">
					<img alt="First Demo Concept Types" src="oial_demo_one.png"/>
				</div>
				In this diagram, <strong>B</strong> and <strong>T</strong> are the <em>only</em> top-level types in the diagram, so everything will be absorbed into B and T. As a result, B and T are automatically concept types. However, A is also a concept type because it is recorded as being absorbed into B through an ObjectTypeAbsorption. Additionally, D is a concept type because it is also recorded as being absorbed into A, another concept type, through an ObjectTypeAbsorption. In the case where we have a value type which is also a top level type, as for T, we must generate an <a href="#cttInformationType" class="var">Information Type</a> for it.<br/><br/>
			</li>
			<li id="cttInformationType">
				<strong>Information Type</strong>
				<br/>
				<br/>
				Information Types are generated as the "columns" for <a href="cttConceptType" class="var">Concept Types</a>. To find these information types for each <a href="#cttConceptType" class="var">Concept Type</a>, we look at the <em>absorbed</em> facts that the Concept Type functionally determines. If we find opposite role players that are not Value Types for those fact types, then we drill down further into the object model to find the reference mode of that object. For example:<br/>
				<div style="text-align:center">
					<img alt="First Demo Information Types" src="oial_demo_one.png"/>
				</div>
				In this diagram, after we've recorded B, A, and D as concept types, we must look for information types for each of them. D functionally determines E, so the FactType connecting them counts as an absorbed functional direct fact. We look at the opposite role player, E. Is it a Value Type? No. So we drill down further and look for E's reference mode, E_Picture. Is that a value type? Yes. E_Picture is used as an information type which references the odt:binary Information Type Format allocated to it (The name of the Information Type will be E_E_Picture to document the path through the model). Next we look at A's information types. It contains the concept type D and is absorbed into B, so the only functional direct fact it absorbs is its relationship with its primary identifier, so since A_Name is a ValueType, it is mapped as a Information Type. This process continues and we find that B, in addition containing concept type A, contains information types B_ID and C_C_Money. T also has an Information Type generated for it because even though it in and of itself is a <a href="cttConceptType" class="var">Concept Type</a>, it is still represented by an Information Type.<br/><br/>
			</li>
			<li id="cttConceptTypeRef">
				<strong>Concept Type Ref</strong>
				<br/>
				<br/>
				Concept Type Refs are spit when there are direct relationships between two <a href="cttConceptType" class="var">Concept Types</a>. For example, consider the following diagram:<br/>
				<div style="text-align:center">
					<img alt="First Demo Information Types" src="oial_demo_one.png"/>
				</div>
				Both T and B are <a href="cttConceptType" class="var">Concept Types</a>, and there is no recorded FactTypeAbsorption or ObjectTypeAbsorptions based on their relationship to each other. Because there is nothing recorded about that fact, T holds a reference to B (because it would be absorbed onto T's side had B not been top-level), which maps to a Concept Type Ref in the OIAL implementation.
			</li>
		</ol>
		<hr />
		<h4>Footnotes</h4>
		<ol>
			<li id="ftnt1">
				Since Modality is an optional attribute and its default is "Alethic," checking for Alethic constraints involves XPath like <span class="xpath">&hellip;[not(@Modality) or @Modality='Alethic']</span>	
			</li>
		</ol>
	</body>
</html>
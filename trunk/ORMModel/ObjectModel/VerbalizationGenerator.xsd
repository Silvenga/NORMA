<?xml version="1.0" encoding="utf-8"?>
<xs:schema
	attributeFormDefault="unqualified"
	elementFormDefault="qualified"
	targetNamespace="http://schemas.neumont.edu/ORM/SDK/CoreVerbalizationGenerator"
	xmlns="http://schemas.neumont.edu/ORM/SDK/CoreVerbalizationGenerator"
	xmlns:cvg="http://schemas.neumont.edu/ORM/SDK/CoreVerbalizationGenerator"
	xmlns:ve="http://schemas.neumont.edu/ORM/SDK/Verbalization"
	xmlns:xs="http://www.w3.org/2001/XMLSchema">
	<xs:annotation>
		<xs:appinfo source="Common Public License Copyright Notice">
			Neumont Object-Role Modeling Architect for Visual Studio

			Copyright © Neumont University. All rights reserved.

			The use and distribution terms for this software are covered by the
			Common Public License 1.0 (http://opensource.org/licenses/cpl) which
			can be found in the file CPL.txt at the root of this distribution.
			By using this software in any fashion, you are agreeing to be bound by
			the terms of this license.

			You must not remove this notice, or any other, from this software.
		</xs:appinfo>
	</xs:annotation>
	<xs:import namespace="http://schemas.neumont.edu/ORM/SDK/Verbalization" schemaLocation="VerbalizationCoreSnippets/VerbalizationCoreSnippets.xsd"/>
	<xs:simpleType name="PassEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="first"/>
			<xs:enumeration value="notFirst"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="SpanEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="all"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ConstraintTypeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="UniquenessConstraint"/>
			<xs:enumeration value="MandatoryConstraint"/>
			<xs:enumeration value="FrequencyConstraint"/>
			<xs:enumeration value="RingConstraint"/>
			<xs:enumeration value="SubsetConstraint"/>
			<xs:enumeration value="ExclusionConstraint"/>
			<xs:enumeration value="EqualityConstraint"/>
			<xs:enumeration value="RoleValueConstraint">
				<xs:annotation>
					<xs:documentation>Verbalizes value range constraints on roles.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ValueTypeValueConstraint">
				<xs:annotation>
					<xs:documentation>Verbalizes value range constraints on value types.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="DefaultBinaryMissingUniquenessVerbalizer">
				<xs:annotation>
					<xs:documentation>Helper class for verbalizing default binary conditions. The childHelperFor attribute should be set to FactType.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="CombinedMandatoryUniqueVerbalizer">
				<xs:annotation>
					<xs:documentation>Helper class for verbalizing combinations of uniqueness and mandatory constraints on binaries. The childHelperFor attribute should be set to FactType.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ImpliedUniqueVerbalizer">
				<xs:annotation>
					<xs:documentation>Helper class for verbalizing implied single-role internal uniqueness constraints. The childHelperFor attribute should be set to FactType.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ImpliedMandatoryVerbalizer">
				<xs:annotation>
					<xs:documentation>Helper class for verbalizing implied simple mandatory constraints. The childHelperFor attribute should be set to FactType.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ChildHelperForEnum">
		<xs:annotation>
			<xs:documentation>Used to specify child helper classes as nested classes inside this type.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="FactType">
				<xs:annotation>
					<xs:documentation>Use with the DefaultBinaryMissingUniquenessVerbalizer and CombinedMandatoryUniqueVerbalizer types</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ObjectType">
				<xs:annotation>
					<xs:documentation>Use with the ObjectTypeInstanceVerbalizer</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ConstraintPatternGroupEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="InternalConstraint"/>
			<xs:enumeration value="SetConstraint"/>
			<xs:enumeration value="SetComparisonConstraint"/>
			<xs:enumeration value="RoleValueConstraint">
				<xs:annotation>
					<xs:documentation>Verbalizes role value constraints.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ValueTypeValueConstraint">
				<xs:annotation>
					<xs:documentation>Verbalizes value type value constraints.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ReadingChoicePreferSingleMatchWithContextEnum">
		<xs:restriction base="xs:string">
			<!-- Allowable options are {Context|Prefer[Non][Primary]LeadReading[NoFrontText]} -->
			<xs:enumeration value="Context">
				<xs:annotation>
					<xs:documentation>Use the reading from the current ReadingChoice or ReadingContext elements</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="PreferLeadReading"/>
			<xs:enumeration value="PreferNonLeadReading"/>
			<xs:enumeration value="PreferPrimaryLeadReading"/>
			<xs:enumeration value="PreferNonPrimaryLeadReading"/>
			<xs:enumeration value="PreferLeadReadingNoFrontText"/>
			<xs:enumeration value="PreferNonLeadReadingNoFrontText"/>
			<xs:enumeration value="PreferPrimaryLeadReadingNoFrontText"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingNoFrontText"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ReadingChoicePreferSingleMatchEnum">
		<xs:restriction base="xs:string">
			<!-- Allowable options are {Prefer[Non][Primary]LeadReading[NoFrontText]} -->
			<xs:enumeration value="PreferLeadReading"/>
			<xs:enumeration value="PreferNonLeadReading"/>
			<xs:enumeration value="PreferPrimaryLeadReading"/>
			<xs:enumeration value="PreferNonPrimaryLeadReading"/>
			<xs:enumeration value="PreferLeadReadingNoFrontText"/>
			<xs:enumeration value="PreferNonLeadReadingNoFrontText"/>
			<xs:enumeration value="PreferPrimaryLeadReadingNoFrontText"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingNoFrontText"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ReadingChoiceFullRequiredMatchEnum">
		<xs:restriction base="xs:string">
			<!-- Allowable options are {Require[All][Non][Primary]LeadReading[NoFrontText]} -->
			<xs:enumeration value="RequireLeadReading"/>
			<xs:enumeration value="RequireNonLeadReading"/>
			<xs:enumeration value="RequirePrimaryLeadReading"/>
			<xs:enumeration value="RequireNonPrimaryLeadReading"/>
			<xs:enumeration value="RequireLeadReadingNoFrontText"/>
			<xs:enumeration value="RequireNonLeadReadingNoFrontText"/>
			<xs:enumeration value="RequirePrimaryLeadReadingNoFrontText"/>
			<xs:enumeration value="RequireNonPrimaryLeadReadingNoFrontText"/>
			<xs:enumeration value="RequireAllLeadReading"/>
			<xs:enumeration value="RequireAllNonLeadReading"/>
			<xs:enumeration value="RequireAllPrimaryLeadReading"/>
			<xs:enumeration value="RequireAllNonPrimaryLeadReading"/>
			<xs:enumeration value="RequireAllLeadReadingNoFrontText"/>
			<xs:enumeration value="RequireAllNonLeadReadingNoFrontText"/>
			<xs:enumeration value="RequireAllPrimaryLeadReadingNoFrontText"/>
			<xs:enumeration value="RequireAllNonPrimaryLeadReadingNoFrontText"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ListStyleEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="CompactSimpleList"/>
			<xs:enumeration value="CompoundList"/>
			<xs:enumeration value="IdentityEqualityList"/>
			<xs:enumeration value="IndentedCompoundList"/>
			<xs:enumeration value="IndentedList"/>
			<xs:enumeration value="IndentedLogicalAndList"/>
			<xs:enumeration value="IndentedLogicalOrList"/>
			<xs:enumeration value="ObjectTypeInstanceList"/>
			<xs:enumeration value="SimpleList"/>
			<xs:enumeration value="SimpleLogicalAndList"/>
			<xs:enumeration value="SimpleLogicalOrList"/>
			<xs:enumeration value="TopLevelIndentedLogicalAndList"/>
			<xs:enumeration value="TopLevelIndentedLogicalOrList"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ListStyleEnumOrNull">
		<xs:union memberTypes="ListStyleEnum">
			<xs:simpleType>
				<xs:restriction base="xs:token">
					<xs:enumeration value="null"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:union>
	</xs:simpleType>
	<xs:simpleType name="RoleIteratorContextMatchEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="included"/>
			<xs:enumeration value="excluded"/>
			<xs:enumeration value="primary"/>
			<xs:enumeration value="secondary"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="IterateRolesMatchEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="all"/>
			<xs:enumeration value="included"/>
			<xs:enumeration value="excluded"/>
			<xs:enumeration value="setConstraintRoles"/>
			<xs:enumeration value="preferredIdentifier"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:attributeGroup name="FactArityAttributes">
		<xs:attribute name="factCount" type="xs:unsignedByte" use="optional"/>
		<xs:attribute name="factArity" type="xs:unsignedByte" use="optional"/>
		<xs:attribute name="constraintArity" type="xs:unsignedByte" use="optional"/>
		<xs:attribute name="minFactArity" type="xs:unsignedByte" use="optional"/>
		<xs:attribute name="maxFactArity" type="xs:unsignedByte" use="optional"/>
	</xs:attributeGroup>
	<xs:complexType name="SnippetLeafType">
		<xs:attribute name="ref" use="required">
			<xs:simpleType>
				<xs:union memberTypes="ve:SnippetTypeEnum">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="null"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:union>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="reverseSign" use="optional"/>
	</xs:complexType>
	<xs:complexType name="SnippetLeafTypeWithConditionalMatch">
		<xs:complexContent>
			<xs:extension base="SnippetLeafType">
				<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="ConditionalBlockContextType">
		<xs:annotation>
			<xs:documentation>Provide an extension point for adding extra context code at the beginning of a conditional block.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:token">
			<xs:enumeration value="ObjectifiedFactType">
				<xs:annotation>
					<xs:documentation>Used when object type is objectified fact type.</xs:documentation>
				</xs:annotation>				
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ConditionalMatchPatternType">
		<xs:annotation>
			<xs:documentation>Provide an extension point for conditionally including snippets.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:token">
			<xs:enumeration value="IsEntityType">
				<xs:annotation>
					<xs:documentation>True if the IsValueType property for the current object type is false.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="IsValueType">
				<xs:annotation>
					<xs:documentation>True if the IsValueType property for the current object type is true.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="IsObjectifiedFactType">
				<xs:annotation>
					<xs:documentation>True if the IsValueType property for the current object type is true.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="HasPortableDataType">
				<xs:annotation>
					<xs:documentation>True if the current object type has portable data type.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="HasNotes">
				<xs:annotation>
					<xs:documentation>True if the current object type has notes associated with it.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="IsIndependent">
				<xs:annotation>
					<xs:documentation>True if the current object type is independent.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="HasReferenceMode">
				<xs:annotation>
					<xs:documentation>True if the current object type has a reference mode.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="HasPreferredIdentifier">
				<xs:annotation>
					<xs:documentation>True if the current object type has preferred identifier.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="IsPersonal">
				<xs:annotation>
					<xs:documentation>True if the IsPersonal property for the current role player is true.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="IsPreferredIdentifier">
				<xs:annotation>
					<xs:documentation>True if the current constraint is a preferred identifier.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="BinaryWithRoleName">
				<xs:annotation>
					<xs:documentation>True if the current role is named and is playing a role within a binary fact type.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="RolePlayerHasReferenceScheme">
				<xs:annotation>
					<xs:documentation>True if the current role player has a reference scheme</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="IsSingleValue">
				<xs:annotation>
					<xs:documentation>
						True if the value range collection has only one value range whose
						min value is equal to the max value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinEqualsMax">
				<xs:annotation>
					<xs:documentation>
						Matches a value range whose min value is equal to the max value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinClosedMaxUnbounded">
				<xs:annotation>
					<xs:documentation>
						Matches a value range with a closed minimum value and an unbounded maximum value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinOpenMaxUnbounded">
				<xs:annotation>
					<xs:documentation>
						Matches a value range with an open minimum value and an unbounded maximum value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinUnboundedMaxClosed">
				<xs:annotation>
					<xs:documentation>
						Matches a value range with an unbounded minimum value and a closed maximum value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinUnboundedMaxOpen">
				<xs:annotation>
					<xs:documentation>
						Matches a value range with an unbounded minimum value and an open maximum value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinClosedMaxClosed">
				<xs:annotation>
					<xs:documentation>
						Matches a value range with a closed minimum value and an open maximum value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinClosedMaxOpen">
				<xs:annotation>
					<xs:documentation>
						Matches a value range with a closed minimum value and an open maximum value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinOpenMaxClosed">
				<xs:annotation>
					<xs:documentation>
						Matches a value range with an open minimum value and an open maximum value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinOpenMaxOpen">
				<xs:annotation>
					<xs:documentation>
						Matches a value range with an open minimum value and an open maximum value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="SnippetType">
		<xs:complexContent>
			<xs:extension base="SnippetLeafType">
				<xs:group ref="ReplacementElementsGroup" minOccurs="0" maxOccurs="unbounded"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:group name="ReplacementElementsGroup">
		<xs:choice>
			<xs:element name="Snippet" type="SnippetType"/>
			<xs:element name="ObjectTypeName" type="ObjectTypeNameType"/>
			<xs:element name="NoteText" type="NoteTextType"/>
			<xs:element name="ReferenceMode" type="ReferenceModeType"/>
			<xs:element name="PortableDataType" type="PortableDataTypeType"/>
			<xs:element name="Notes" type="NotesType"/>
			<xs:element name="IterateRoles" type="IterateRolesType"/>
			<xs:element name="CompositeList" type="CompositeListType"/>
			<xs:element name="Fact" type="FactType"/>
			<xs:element name="IterateFacts" type="IterateFactsType"/>
			<xs:element name="ReferenceScheme" type="ReferenceSchemeType"/>
			<xs:element name="ConditionalReplacement" type="ConditionalReplacementType"/>
			<xs:element name="IterateValueRanges" type="IterateValueRangesType"/>
			<xs:element name="MinValue" type="MinValueType"/>
			<xs:element name="MaxValue" type="MaxValueType"/>
			<xs:element name="IterateContextRoles" type="IterateContextRolesType"/>
			<xs:element name="RoleName" type="RoleNameType"/>
			<xs:element name="RolePlayer" type="RolePlayerType"/>
			<xs:element name="RolePlayerReferenceMode" type="RolePlayerReferenceModeType"/>
			<xs:element name="ValueRangeValueTypeName" type="ValueRangeValueTypeNameType"/>
		</xs:choice>
	</xs:group>
	<xs:group name="ReplacementElementsWithConditionalMatchGroup">
		<xs:annotation>
			<xs:documentation>The elements listed in ReplacementElementsGroup with a
			conditionalMatch attribute added. Used inside the ConditionalReplacements element.</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="Snippet" type="SnippetTypeWithConditionalMatch"/>
			<xs:element name="IterateRoles">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="IterateRolesType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="CompositeList">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="CompositeListType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="ReferenceScheme">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="ReferenceSchemeType"/>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="Fact">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="FactType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="IterateFacts">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="IterateFactsType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="ConditionalReplacement">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="ConditionalReplacementType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="ReadingContext">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="ReadingContextType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="ConditionalReading">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="ConditionalReadingType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="IterateValueRanges">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="IterateValueRangesType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="MinValue">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="MinValueType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="MaxValue">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="MaxValueType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="IterateContextRoles">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="IterateContextRolesType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="RoleName">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="RoleNameType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="RolePlayer">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="RolePlayerType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="RolePlayerReferenceMode">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="RolePlayerReferenceModeType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
		</xs:choice>
	</xs:group>
	
	<xs:complexType name="SnippetTypeWithConditionalMatch">
		<xs:complexContent>
			<xs:extension base="SnippetType">
				<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
				<xs:attribute name="conditionalBlockContext" use="optional" type="ConditionalBlockContextType"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ConditionalSnippetType">
		<xs:annotation>
			<xs:documentation>
				Provides a commonly matchable pattern.  The ConditionalSnippet holds multiple potential
				Snippets with match conditions, plus a fallback snippet.  The SnippetReplacements section
				contains the replacement fields that will be used for all snippets.
			</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="1" maxOccurs="unbounded">
			<xs:element name="Snippet" type="SnippetLeafTypeWithConditionalMatch"/>
			<xs:element name="SnippetReplacements" type="SnippetReplacementsType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="SnippetReplacementsType">
		<xs:annotation>
			<xs:documentation>
				Holds potential replacement fields for the conditional snippets listed above.
				There must be at least as many replacement fields here as there are in the conditional snippet
				which requires the most replacement fields.
			</xs:documentation>
		</xs:annotation>
		<xs:group ref="ReplacementElementsGroup" minOccurs="0" maxOccurs="unbounded"/>
	</xs:complexType>
	<xs:complexType name="ConditionalReplacementType">
		<xs:annotation>
			<xs:documentation>
				Provides a commonly matchable pattern similar to ConditionalSnippet.  ConditionalReplacements
				are only allowed within SnippetReplacement tags, and they allow a conditional selection of
				replacement contents for the replacement fields in the ConditionalSnippet.
			</xs:documentation>
		</xs:annotation>
		<xs:group ref="ReplacementElementsWithConditionalMatchGroup" minOccurs="1" maxOccurs="unbounded"/>
	</xs:complexType>
	<xs:complexType name="IterateValueRangesType">
		<xs:annotation>
			<xs:documentation>
				Iterates a value range collection.
			</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="1" maxOccurs="unbounded">
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType"/>
		</xs:choice>
		<xs:attribute name="listStyle" type="ListStyleEnum"/>
	</xs:complexType>
	<xs:complexType name="ValueRangeValueTypeNameType">
		<xs:annotation>
			<xs:documentation>
				Returns the name of the value type.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="PortableDataTypeType">
		<xs:annotation>
			<xs:documentation>
				Returns the portable data type of the object type.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="NotesType">
		<xs:annotation>
			<xs:documentation>
				Returns the notes of the object type.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="ObjectTypeNameType">
		<xs:annotation>
			<xs:documentation>
				Returns the name of the object type.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="ObjectTypeInstanceValueType">
		<xs:annotation>
			<xs:documentation>
				Returns the value of the Object Type Instance
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="NoteTextType">
		<xs:annotation>
			<xs:documentation>
				Returns the notes of the object type.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="ReferenceModeType">
		<xs:annotation>
			<xs:documentation>
				Returns the reference mode of the object type.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="MinValueType">
		<xs:annotation>
			<xs:documentation>
				Returns the minimum value of a value range constraint.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="MaxValueType">
		<xs:annotation>
			<xs:documentation>
				Returns the maximum value of a value range constraint.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="RoleNameType">
		<xs:annotation>
			<xs:documentation>
				Returns the name of a role.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="RolePlayerType">
		<xs:annotation>
			<xs:documentation>
				Returns the name of the current role player role.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="RolePlayerReferenceModeType">
		<xs:annotation>
			<xs:documentation>
				Returns the reference mode scheme of the attached role player.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="PredicateReplacementType">
		<xs:choice minOccurs="1" maxOccurs="1">
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType"/>
			<xs:element name="Snippet" type="SnippetLeafType"/>
		</xs:choice>
		<xs:attribute name="match" use="optional" type="RoleIteratorContextMatchEnum"/>
		<xs:attribute name="pass" use="optional" type="PassEnum"/>
	</xs:complexType>
	<xs:complexType name="FactConstructType">
		<!-- Nothing here yet, this is for the top-level verbalization of a Fact -->
	</xs:complexType>
	<xs:complexType name="NoteConstructType">
		<xs:annotation>
			<xs:documentation>Returns the verbalization for the notes associated with an objectType.</xs:documentation>
		</xs:annotation>
		<xs:choice maxOccurs="unbounded">
			<xs:element name="Snippet" type="SnippetTypeWithConditionalMatch" />
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType" />
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ObjectConstructType">
		<xs:annotation>
			<xs:documentation>Returns the full verbalization for an entity, value, or objectified fact type.</xs:documentation>
		</xs:annotation>
		<xs:choice maxOccurs="unbounded">
			<xs:element name="Snippet" type="SnippetTypeWithConditionalMatch" />
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType" />
			<xs:element name="IterateInstances" type="IterateInstancesType" />
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="FactType">
		<xs:annotation>
			<xs:documentation>
				Returns the full verbalization for a fact type, i.e, Company provides Product to Company.
			</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0" maxOccurs="1">
			<xs:element name="PredicateReplacement" type="PredicateReplacementType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="readingChoice" use="optional" type="ReadingChoicePreferSingleMatchWithContextEnum"/>
	</xs:complexType>
	<xs:complexType name="ReferenceSchemeType">
		<xs:annotation>
			<xs:documentation>
				Returns the reference scheme for an object, e.g. Country has CountryCode etc.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="IterateRolesNoListType">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="Fact" type="FactType"/>
			<xs:element name="Snippet" type="SnippetType"/>			
			<xs:element name="IterateContextRoles" type="IterateContextRolesType"/>
			<xs:element name="RolePlayer" type="RolePlayerType"/>
		</xs:choice>
		<xs:attribute name="match" type="IterateRolesMatchEnum" default="all"/>
		<xs:attributeGroup ref="FactArityAttributes"/>
		<xs:attribute name="pass" use="optional" type="PassEnum"/>
		<xs:attribute name="hyphenBind" type="xs:boolean" default="false"/>
	</xs:complexType>
	<xs:complexType name="IterateRolesType">
		<xs:complexContent>
			<xs:extension base="IterateRolesNoListType">
				<xs:attribute name="listStyle" use="required" type="ListStyleEnumOrNull"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IterateInstancesType">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="ObjectTypeInstanceValue" type="ObjectTypeInstanceValueType"/>
		</xs:choice>
		<xs:attribute name="listStyle" use="required" type="ListStyleEnumOrNull"/>
	</xs:complexType>
	<xs:complexType name="IterateFactsType">
		<xs:annotation>
			<xs:documentation>
				Returns the full verbalization for a list of fact types with the specified list style.
			</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0" maxOccurs="1">
			<xs:element name="PredicateReplacement" type="PredicateReplacementType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="listStyle" use="required" type="ListStyleEnumOrNull"/>
		<xs:attribute name="readingChoice" use="optional" type="ReadingChoicePreferSingleMatchEnum"/>
	</xs:complexType>
	<xs:complexType name="IterateContextRolesNoListType">
		<xs:group ref="ReplacementElementsGroup" minOccurs="0" maxOccurs="unbounded"/>
		<xs:attribute name="match" type="RoleIteratorContextMatchEnum" use="optional"/>
		<xs:attribute name="pass" use="optional" type="PassEnum"/>
	</xs:complexType>
	<xs:complexType name="IterateContextRolesType">
		<xs:complexContent>
			<xs:extension base="IterateContextRolesNoListType">
				<xs:attribute name="listStyle" type="ListStyleEnumOrNull" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BaseReadingContextType">
		<xs:choice minOccurs="1" maxOccurs="unbounded">
			<xs:element name="Fact" type="FactType"/>
			<xs:element name="Snippet" type="SnippetType"/>
			<xs:element name="CompositeList" type="CompositeListType"/>
			<xs:element name="IterateRoles" type="IterateRolesType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ReadingChoiceType">
		<xs:complexContent>
			<xs:extension base="BaseReadingContextType">
				<xs:attribute name="match" use="optional" type="ReadingChoiceFullRequiredMatchEnum"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ConditionalReadingType">
		<xs:sequence>
			<xs:element name="ReadingChoice" type="ReadingChoiceType" minOccurs="2" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ReadingContextType">
		<xs:complexContent>
			<xs:extension base="BaseReadingContextType">
				<xs:attribute name="match" use="optional" type="ReadingChoicePreferSingleMatchEnum"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CompositeListType">
		<xs:choice>
			<xs:element name="IterateRoles" type="IterateRolesNoListType" minOccurs="2" maxOccurs="unbounded"/>
			<xs:element name="IterateContextRoles" type="IterateContextRolesNoListType" minOccurs="2" maxOccurs="unbounded"/>
		</xs:choice>
		<xs:attribute name="listStyle" type="ListStyleEnum" use="required"/>
	</xs:complexType>
	<xs:complexType name="ConstraintsConstructType">
		<xs:sequence>
			<xs:element name="Constraint" type="ConstraintType" minOccurs="1" maxOccurs="unbounded">
				<xs:unique name="ConstrainedRolesFilter">
					<xs:selector xpath="cvg:ConstrainedRoles"/>
					<xs:field xpath="@span"/>
					<xs:field xpath="@factArity"/>
					<xs:field xpath="@minFactArity"/>
					<xs:field xpath="@maxFactArity"/>
				</xs:unique>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="SampleInstancesConstructType">
		<xs:annotation>
			<xs:documentation>
				Allows for generation of Verbalizers for Instances
			</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="SampleInstance" type="SampleInstanceType"/>
			<xs:element name="SingleSnippet" type="SingleSnippetType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="EnableSubscriptsType">
		<xs:attribute name="minFactArity" type="xs:positiveInteger" use="required"/>
	</xs:complexType>
	<xs:simpleType name="RingTypeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="Irreflexive"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="ConstraintType">
		<xs:choice minOccurs="1" maxOccurs="unbounded">
			<xs:element name="EnableSubscripts" type="EnableSubscriptsType"/>
			<xs:element name="ConstrainedRoles">
				<xs:complexType>
					<xs:choice minOccurs="1" maxOccurs="unbounded">
						<xs:element name="Snippet" type="SnippetTypeWithConditionalMatch"/>
						<xs:element name="IterateRoles" type="IterateRolesType"/>
						<xs:element name="CompositeList" type="CompositeListType"/>
						<xs:element name="ConditionalSnippet" type="ConditionalSnippetType"/>
						<xs:element name="ConditionalReading" type="ConditionalReadingType">
							<xs:unique name="ConditionalReadingReadingChoice">
								<xs:selector xpath="cvg:ReadingChoice"/>
								<xs:field xpath="@match"/>
							</xs:unique>
						</xs:element>
						<xs:element name="ReadingContext" type="ReadingContextType"/>
					</xs:choice>
					<xs:attribute name="span" type="SpanEnum" use="optional"/>
					<xs:attribute name="sign" type="ve:SignEnum" use="optional"/>
					<xs:attribute name="ringType" type="RingTypeEnum" use="optional"/>
					<xs:attribute name="columnArity" type="xs:positiveInteger" use="optional"/>
					<xs:attributeGroup ref="FactArityAttributes"/>
				</xs:complexType>
			</xs:element>
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType"/>
		</xs:choice>
		<xs:attribute name="type" type="ConstraintTypeEnum" use="required"/>
		<xs:attribute name="patternGroup" type="ConstraintPatternGroupEnum" use="required"/>
		<xs:attribute name="compatibleColumns" type="xs:boolean" default="false"/>
		<xs:attribute name="childHelperFor" type="ChildHelperForEnum" use="optional"/>
	</xs:complexType>
	<xs:complexType name="SampleInstanceType">
		<xs:annotation>
			<xs:documentation>
				Constructs IVerbalizer implementations for Sample Instance Data
			</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="1" maxOccurs="1">
			<xs:element name="IterateInstances" type="IterateInstancesType"/>
			<xs:element name="Fact">
				<xs:complexType>
					<xs:choice minOccurs="1" maxOccurs="1">
						<xs:element name="InstanceRoleReplacement"/>
					</xs:choice>
				</xs:complexType>
			</xs:element>
		</xs:choice>
		<xs:attribute name="type" use="required"/>
		<xs:attribute name="childHelperFor" type="ChildHelperForEnum" use="optional"/>
	</xs:complexType>
	<xs:complexType name="SingleSnippetType">
		<xs:annotation>
			<xs:documentation>
				Constructs IVerbalizer implementation to verbalize a single snippet
			</xs:documentation>
		</xs:annotation>
		<xs:attribute name="type" use="required"/>
		<xs:attribute name="childHelperFor" type="ChildHelperForEnum" use="optional"/>
		<xs:attribute name="snippetRef" use="required" type="ve:SnippetTypeEnum"/>
	</xs:complexType>
	<xs:element name="VerbalizationRoot">
		<xs:complexType>
			<xs:sequence>
				<xs:element name="Copyright" minOccurs="0">
					<xs:annotation>
						<xs:documentation>Copyright notice.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:element name="CopyrightLine" type="xs:string" maxOccurs="unbounded"/>
						</xs:sequence>
						<xs:attribute name="name" type="xs:string" use="required"/>
					</xs:complexType>
				</xs:element>
				<xs:element name="Constructs" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:all>
							<xs:element name="FactType" type="FactConstructType"/>
							<xs:element name="Constraints" type="ConstraintsConstructType"/>
							<xs:element name="SampleInstances" type="SampleInstancesConstructType"/>
							<xs:element name="ObjectType" type="ObjectConstructType" />
							<xs:element name="Note" type="NoteConstructType" />
						</xs:all>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			<xs:attribute name="snippetsLocation" type="xs:string" use="required">
				<xs:annotation>
					<xs:documentation>The relative location of the file containing the snippets</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
</xs:schema>

<?xml version="1.0" encoding="utf-8"?>
<xs:schema
	attributeFormDefault="unqualified"
	elementFormDefault="qualified"
	targetNamespace="http://schemas.neumont.edu/ORM/SDK/Verbalization"
	xmlns="http://schemas.neumont.edu/ORM/SDK/Verbalization"
	xmlns:ve="http://schemas.neumont.edu/ORM/SDK/Verbalization"
	xmlns:xs="http://www.w3.org/2001/XMLSchema">
	<xs:import namespace="http://www.w3.org/XML/1998/namespace"/>
	<xs:simpleType name="ModalityEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="alethic"/>
			<xs:enumeration value="deontic"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="SignEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="positive"/>
			<xs:enumeration value="negative"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="PassEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="first"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="SpanEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="all"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="SnippetTypeEnum">
		<xs:restriction base="xs:NMTOKEN">
			<xs:enumeration value="ObjectType"/>
			<xs:enumeration value="ObjectTypeWithSubscript"/>
			<xs:enumeration value="ObjectTypeMissing"/>
			<xs:enumeration value="ImpersonalPronoun"/>
			<xs:enumeration value="PersonalPronoun"/>
			<xs:enumeration value="UniversalQuantifier"/>
			<xs:enumeration value="AtMostOneQuantifier"/>
			<xs:enumeration value="EachInstanceQuantifier"/>
			<xs:enumeration value="ForEachCompactQuantifier"/>
			<xs:enumeration value="ForEachQuantifier"/>
			<xs:enumeration value="ExistentialQuantifier"/>
			<xs:enumeration value="IdentityReferenceQuantifier"/>
			<xs:enumeration value="ImpliedModalNecessityOperator">
				<xs:annotation>
					<xs:documentation>No text for alethic, same as ModalNecessityOperator otherwise.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MoreThanOneQuantifier"/>
			<xs:enumeration value="ModalPossibilityOperator"/>
			<xs:enumeration value="ModalNecessityOperator"/>
			<xs:enumeration value="NegativeReadingForUnaryOnlyDisjunctiveMandatory"/>
			<xs:enumeration value="CompoundListOpen"/>
			<xs:enumeration value="CompoundListPairSeparator"/>
			<xs:enumeration value="CompoundListSeparator"/>
			<xs:enumeration value="CompoundListFinalSeparator"/>
			<xs:enumeration value="CompoundListClose"/>
			<xs:enumeration value="IndentedListOpen"/>
			<xs:enumeration value="IndentedListPairSeparator"/>
			<xs:enumeration value="IndentedListSeparator"/>
			<xs:enumeration value="IndentedListFinalSeparator"/>
			<xs:enumeration value="IndentedListClose"/>
			<xs:enumeration value="IndentedOrListOpen"/>
			<xs:enumeration value="IndentedOrListPairSeparator"/>
			<xs:enumeration value="IndentedOrListSeparator"/>
			<xs:enumeration value="IndentedOrListFinalSeparator"/>
			<xs:enumeration value="IndentedOrListClose"/>
			<xs:enumeration value="TopLevelIndentedOrListOpen"/>
			<xs:enumeration value="TopLevelIndentedOrListPairSeparator"/>
			<xs:enumeration value="TopLevelIndentedOrListSeparator"/>
			<xs:enumeration value="TopLevelIndentedOrListFinalSeparator"/>
			<xs:enumeration value="TopLevelIndentedOrListClose"/>
			<xs:enumeration value="SimpleListOpen"/>
			<xs:enumeration value="SimpleListPairSeparator"/>
			<xs:enumeration value="SimpleListSeparator"/>
			<xs:enumeration value="SimpleListFinalSeparator"/>
			<xs:enumeration value="SimpleListClose"/>
			<xs:enumeration value="CompactSimpleListOpen"/>
			<xs:enumeration value="CompactSimpleListPairSeparator"/>
			<xs:enumeration value="CompactSimpleListSeparator"/>
			<xs:enumeration value="CompactSimpleListFinalSeparator"/>
			<xs:enumeration value="CompactSimpleListClose"/>
			<xs:enumeration value="CloseVerbalizationSentence"/>
			<xs:enumeration value="CombinationIdentifier"/>
			<xs:enumeration value="OccursInPopulation"/>
			<xs:enumeration value="OneQuantifier"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ConstraintTypeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="InternalUniquenessConstraint"/>
			<xs:enumeration value="ExternalUniquenessConstraint"/>
			<xs:enumeration value="DisjunctiveMandatoryConstraint"/>
			<xs:enumeration value="SimpleMandatoryConstraint"/>
			<xs:enumeration value="FrequencyConstraint"/>
			<xs:enumeration value="RingConstraint"/>
			<xs:enumeration value="SubsetConstraint"/>
			<xs:enumeration value="ExclusionConstraint"/>
			<xs:enumeration value="EqualityConstraint"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ConstraintPatternGroupEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="InternalConstraint"/>
			<xs:enumeration value="SingleColumnExternalConstraint"/>
			<xs:enumeration value="MultiColumnExternalConstraint"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ReadingChoicePreferSingleMatchEnum">
		<xs:restriction base="xs:string">
			<!-- Allowable options are {Conditional|Prefer[Non][Primary]LeadReading[NoForwardText]} -->
			<xs:enumeration value="Conditional"/>
			<xs:enumeration value="PreferLeadReading"/>
			<xs:enumeration value="PreferNonLeadReading"/>
			<xs:enumeration value="PreferPrimaryLeadReading"/>
			<xs:enumeration value="PreferNonPrimaryLeadReading"/>
			<xs:enumeration value="PreferLeadReadingNoForwardText"/>
			<xs:enumeration value="PreferNonLeadReadingNoForwardText"/>
			<xs:enumeration value="PreferPrimaryLeadReadingNoForwardText"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingNoForwardText"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ReadingChoiceFullRequiredMatchEnum">
		<xs:restriction base="xs:string">
			<!-- Allowable options are {Require[All][Non][Primary]LeadReading[NoForwardText]} -->
			<xs:enumeration value="RequireLeadReading"/>
			<xs:enumeration value="RequireNonLeadReading"/>
			<xs:enumeration value="RequirePrimaryLeadReading"/>
			<xs:enumeration value="RequireNonPrimaryLeadReading"/>
			<xs:enumeration value="RequireLeadReadingNoForwardText"/>
			<xs:enumeration value="RequireNonLeadReadingNoForwardText"/>
			<xs:enumeration value="RequirePrimaryLeadReadingNoForwardText"/>
			<xs:enumeration value="RequireNonPrimaryLeadReadingNoForwardText"/>
			<xs:enumeration value="RequireAllLeadReading"/>
			<xs:enumeration value="RequireAllNonLeadReading"/>
			<xs:enumeration value="RequireAllPrimaryLeadReading"/>
			<xs:enumeration value="RequireAllNonPrimaryLeadReading"/>
			<xs:enumeration value="RequireAllLeadReadingNoForwardText"/>
			<xs:enumeration value="RequireAllNonLeadReadingNoForwardText"/>
			<xs:enumeration value="RequireAllPrimaryLeadReadingNoForwardText"/>
			<xs:enumeration value="RequireAllNonPrimaryLeadReadingNoForwardText"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ListStyleEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="CompactSimpleList"/>
			<xs:enumeration value="SimpleList"/>
			<xs:enumeration value="IndentedList"/>
			<xs:enumeration value="CompoundList"/>
			<xs:enumeration value="IndentedOrList"/>
			<xs:enumeration value="TopLevelIndentedOrList"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="PredicateReplacementMatchEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="included"/>
			<xs:enumeration value="excluded"/>
			<xs:enumeration value="primary"/>
			<xs:enumeration value="secondary"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="IterateRolesMatchEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="all"/>
			<xs:enumeration value="included"/>
			<xs:enumeration value="excluded"/>
			<xs:enumeration value="singleColumnConstraintRoles"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:attributeGroup name="FactArityAttributes">
		<xs:attribute name="factArity" type="xs:unsignedByte" use="optional"/>
		<xs:attribute name="minFactArity" type="xs:unsignedByte" use="optional"/>
		<xs:attribute name="maxFactArity" type="xs:unsignedByte" use="optional"/>
	</xs:attributeGroup>
	<xs:complexType name="SnippetLeafType">
		<xs:attribute name="ref" use="required">
			<xs:simpleType>
				<xs:union memberTypes="SnippetTypeEnum">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="null"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:union>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="SnippetType">
		<xs:complexContent>
			<xs:extension base="SnippetLeafType">
				<xs:choice minOccurs="1" maxOccurs="unbounded">
					<xs:element name="Snippet" type="SnippetType"/>
					<xs:element name="IterateRoles" type="IterateRolesType"/>
					<xs:element name="CompositeList" type="CompositeListType"/>
					<xs:element name="Fact" type="FactType"/>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="PredicateReplacementType">
		<xs:sequence>
			<xs:element name="Snippet" type="SnippetLeafType" minOccurs="0" maxOccurs="1"/>
		</xs:sequence>
		<xs:attribute name="match" use="optional" type="PredicateReplacementMatchEnum"/>
		<xs:attribute name="pass" use="optional" type="PassEnum"/>
	</xs:complexType>
	<xs:complexType name="FactConstructType">
		<!-- Nothing here yet, this is for the top-level verbalization of a Fact -->
	</xs:complexType>
	<xs:complexType name="FactType">
		<xs:sequence minOccurs="0" maxOccurs="1">
			<xs:element name="PredicateReplacement" type="PredicateReplacementType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="readingChoice" use="optional" type="ReadingChoicePreferSingleMatchEnum"/>
	</xs:complexType>
	<xs:complexType name="IterateRolesNoListType">
		<xs:sequence>
			<xs:element name="Fact" type="FactType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="match" type="IterateRolesMatchEnum" default="all"/>
		<xs:attributeGroup ref="FactArityAttributes"/>
		<xs:attribute name="pass" use="optional" type="PassEnum"/>
	</xs:complexType>
	<xs:complexType name="IterateRolesType">
		<xs:complexContent>
			<xs:extension base="IterateRolesNoListType">
				<xs:attribute name="listStyle" type="ListStyleEnum" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ReadingChoiceType">
		<xs:choice minOccurs="1" maxOccurs="unbounded">
			<xs:element name="Fact" type="FactType"/>
			<xs:element name="Snippet" type="SnippetType"/>
			<xs:element name="CompositeList" type="CompositeListType"/>
			<xs:element name="IterateRoles" type="IterateRolesType"/>
		</xs:choice>
		<xs:attribute name="match" use="optional" type="ReadingChoiceFullRequiredMatchEnum"/>
	</xs:complexType>
	<xs:complexType name="ConditionalReadingType">
		<xs:sequence>
			<xs:element name="ReadingChoice" type="ReadingChoiceType" minOccurs="2" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="CompositeListType">
		<xs:sequence>
			<xs:element name="IterateRoles" type="IterateRolesNoListType" minOccurs="1" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="listStyle" type="ListStyleEnum" use="required"/>
	</xs:complexType>
	<xs:complexType name="LanguageType">
		<xs:sequence>
			<xs:element name="Snippets" minOccurs="1" maxOccurs="1">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Snippet" minOccurs="1" maxOccurs="unbounded">
							<xs:complexType>
								<xs:simpleContent>
									<xs:extension base="xs:string">
										<xs:attribute name="type" type="SnippetTypeEnum" use="required"/>
										<xs:attribute name="modality" type="ModalityEnum" use="optional"/>
										<xs:attribute name="sign" type="SignEnum" use="optional"/>
									</xs:extension>
								</xs:simpleContent>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attribute ref="xml:lang" use="required"/>
	</xs:complexType>
	<xs:complexType name="ConstraintsConstructType">
		<xs:sequence>
			<xs:element name="Constraint" type="ConstraintType" minOccurs="1" maxOccurs="unbounded">
				<xs:unique name="ConstrainedRolesFilter">
					<xs:selector xpath="ve:ConstrainedRoles"/>
					<xs:field xpath="@span"/>
					<xs:field xpath="@factArity"/>
					<xs:field xpath="@minFactArity"/>
					<xs:field xpath="@maxFactArity"/>
				</xs:unique>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ConstraintType">
		<xs:sequence>
			<xs:element name="ConstrainedRoles" minOccurs="1" maxOccurs="unbounded" >
				<xs:complexType>
					<xs:choice minOccurs="1" maxOccurs="unbounded">
						<xs:element name="Snippet" type="SnippetType"/>
						<xs:element name="IterateRoles" type="IterateRolesType"/>
						<xs:element name="CompositeList" type="CompositeListType"/>
						<xs:element name="ConditionalReading" type="ConditionalReadingType">
							<xs:unique name="ConditionalReadingReadingChoice">
								<xs:selector xpath="ve:ReadingChoice"/>
								<xs:field xpath="@match"/>
							</xs:unique>
						</xs:element>
					</xs:choice>
					<xs:attribute name="span" type="SpanEnum" use="optional"/>
					<xs:attribute name="sign" type="SignEnum" use="optional"/>
					<xs:attributeGroup ref="FactArityAttributes"/>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="type" type="ConstraintTypeEnum" use="required"/>
		<xs:attribute name="patternGroup" type="ConstraintPatternGroupEnum" use="required"/>
	</xs:complexType>
	<xs:element name="VerbalizationRoot">
		<xs:complexType>
			<xs:sequence>
				<xs:element name="Languages" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:sequence>
							<xs:element name="Language" type="LanguageType" minOccurs="1" maxOccurs="unbounded"/>
						</xs:sequence>
					</xs:complexType>
					<xs:key name="LanguageCodeKey">
						<xs:selector xpath="ve:Language"/>
						<xs:field xpath="@xml:lang"/>
					</xs:key>
				</xs:element>
				<xs:element name="Constructs" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:all>
							<xs:element name="FactType" type="FactConstructType"/>
							<xs:element name="Constraints" type="ConstraintsConstructType"/>
						</xs:all>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
</xs:schema>
<?xml version="1.0" encoding="utf-8"?>
<xs:schema
	attributeFormDefault="unqualified"
	elementFormDefault="qualified"
	targetNamespace="http://schemas.neumont.edu/ORM/SDK/CoreVerbalizationGenerator"
	xmlns="http://schemas.neumont.edu/ORM/SDK/CoreVerbalizationGenerator"
	xmlns:cvg="http://schemas.neumont.edu/ORM/SDK/CoreVerbalizationGenerator"
	xmlns:ve="http://schemas.neumont.edu/ORM/SDK/Verbalization"
	xmlns:xs="http://www.w3.org/2001/XMLSchema">
	<xs:annotation>
		<xs:appinfo source="Common Public License Copyright Notice">
			Natural Object-Role Modeling Architect for Visual Studio

			Copyright © Neumont University. All rights reserved.
			Copyright © ORM Solutions, LLC. All rights reserved.

			The use and distribution terms for this software are covered by the
			Common Public License 1.0 (http://opensource.org/licenses/cpl) which
			can be found in the file CPL.txt at the root of this distribution.
			By using this software in any fashion, you are agreeing to be bound by
			the terms of this license.

			You must not remove this notice, or any other, from this software.
		</xs:appinfo>
	</xs:annotation>
	<xs:import namespace="http://schemas.neumont.edu/ORM/SDK/Verbalization" schemaLocation="VerbalizationCoreSnippets/VerbalizationCoreSnippets.xsd"/>
	<xs:simpleType name="PassEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="first"/>
			<xs:enumeration value="notFirst"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="SpanEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="all"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ConstraintTypeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="UniquenessConstraint"/>
			<xs:enumeration value="MandatoryConstraint"/>
			<xs:enumeration value="FrequencyConstraint"/>
			<xs:enumeration value="RingConstraint"/>
			<xs:enumeration value="SubsetConstraint"/>
			<xs:enumeration value="ExclusionConstraint"/>
			<xs:enumeration value="EqualityConstraint"/>
			<xs:enumeration value="RoleValueConstraint">
				<xs:annotation>
					<xs:documentation>Verbalizes value range constraints on roles.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ValueTypeValueConstraint">
				<xs:annotation>
					<xs:documentation>Verbalizes value range constraints on value types.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="NearestValueConstraintVerbalizer">
				<xs:annotation>
					<xs:documentation>Verbalizes value range constraints on entity types.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="DefaultBinaryMissingUniquenessVerbalizer">
				<xs:annotation>
					<xs:documentation>Helper class for verbalizing default binary conditions. The childHelperFor attribute should be set to FactType.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="CombinedMandatoryUniqueVerbalizer">
				<xs:annotation>
					<xs:documentation>Helper class for verbalizing combinations of uniqueness and mandatory constraints on binaries. The childHelperFor attribute should be set to FactType.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ImpliedUniqueVerbalizer">
				<xs:annotation>
					<xs:documentation>Helper class for verbalizing implied single-role internal uniqueness constraints. The childHelperFor attribute should be set to FactType.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ImpliedMandatoryVerbalizer">
				<xs:annotation>
					<xs:documentation>Helper class for verbalizing implied simple mandatory constraints. The childHelperFor attribute should be set to FactType.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="AcyclicRingVerbalizer">
				<xs:annotation>
					<xs:documentation>Individual ring verbalization. The childHelperFor attribute should be set to RingConstraint.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="AntisymmetricRingVerbalizer">
				<xs:annotation>
					<xs:documentation>Individual ring verbalization. The childHelperFor attribute should be set to RingConstraint.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="AsymmetricRingVerbalizer">
				<xs:annotation>
					<xs:documentation>Individual ring verbalization. The childHelperFor attribute should be set to RingConstraint.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="IntransitiveRingVerbalizer">
				<xs:annotation>
					<xs:documentation>Individual ring verbalization. The childHelperFor attribute should be set to RingConstraint.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="IrreflexiveRingVerbalizer">
				<xs:annotation>
					<xs:documentation>Individual ring verbalization. The childHelperFor attribute should be set to RingConstraint.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="SymmetricRingVerbalizer">
				<xs:annotation>
					<xs:documentation>Individual ring verbalization. The childHelperFor attribute should be set to RingConstraint.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ChildHelperForEnum">
		<xs:annotation>
			<xs:documentation>Used to specify child helper classes as nested classes inside this type.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:string">
			<xs:enumeration value="FactType">
				<xs:annotation>
					<xs:documentation>Use with the DefaultBinaryMissingUniquenessVerbalizer and CombinedMandatoryUniqueVerbalizer types</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ObjectType">
				<xs:annotation>
					<xs:documentation>Use with the ObjectTypeInstanceVerbalizer</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="RingConstraint">
				<xs:annotation>
					<xs:documentation>Use for individual ringtype verbalizers.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ConstraintPatternGroupEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="InternalConstraint"/>
			<xs:enumeration value="SetConstraint"/>
			<xs:enumeration value="SetComparisonConstraint"/>
			<xs:enumeration value="RoleValueConstraint">
				<xs:annotation>
					<xs:documentation>Verbalizes role value constraints.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ValueTypeValueConstraint">
				<xs:annotation>
					<xs:documentation>Verbalizes value type value constraints.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="NearestValueConstraint">
				<xs:annotation>
					<xs:documentation>Verbalizes entity type value constraints.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ReadingChoicePreferSingleMatchWithContextEnum">
		<xs:restriction base="xs:string">
			<!-- Allowable options are {Context|Prefer[Non][Primary]LeadReading[NoFrontText][NotHyphenBound]} -->
			<xs:enumeration value="Context">
				<xs:annotation>
					<xs:documentation>Use the reading from the current ReadingChoice or ReadingContext elements</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ConditionalContext">
				<xs:annotation>
					<xs:documentation>Use the reading specified with the IterateRoles/@conditionalReading attribute.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="PreferLeadReading"/>
			<xs:enumeration value="PreferLeadReadingNoFrontText"/>
			<xs:enumeration value="PreferLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="PreferLeadReadingNotHyphenBound"/>
			<xs:enumeration value="PreferNonLeadReading"/>
			<xs:enumeration value="PreferNonLeadReadingNoFrontText"/>
			<xs:enumeration value="PreferNonLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="PreferNonLeadReadingNotHyphenBound"/>
			<xs:enumeration value="PreferNonPrimaryLeadReading"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingNoFrontText"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingNotHyphenBound"/>
			<xs:enumeration value="PreferPrimaryLeadReading"/>
			<xs:enumeration value="PreferPrimaryLeadReadingNoFrontText"/>
			<xs:enumeration value="PreferPrimaryLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="PreferPrimaryLeadReadingNotHyphenBound"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ReadingChoicePreferSingleMatchEnum">
		<xs:restriction base="xs:string">
			<!-- Allowable options are {Prefer[Non][Primary]LeadReading[NoFrontText][NotHyphenBound]} -->
			<xs:enumeration value="PreferLeadReading"/>
			<xs:enumeration value="PreferLeadReadingNoFrontText"/>
			<xs:enumeration value="PreferLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="PreferLeadReadingNotHyphenBound"/>
			<xs:enumeration value="PreferNonLeadReading"/>
			<xs:enumeration value="PreferNonLeadReadingNoFrontText"/>
			<xs:enumeration value="PreferNonLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="PreferNonLeadReadingNotHyphenBound"/>
			<xs:enumeration value="PreferNonPrimaryLeadReading"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingNoFrontText"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingNotHyphenBound"/>
			<xs:enumeration value="PreferPrimaryLeadReading"/>
			<xs:enumeration value="PreferPrimaryLeadReadingNoFrontText"/>
			<xs:enumeration value="PreferPrimaryLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="PreferPrimaryLeadReadingNotHyphenBound"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ReadingChoiceFullRequiredMatchEnum">
		<xs:restriction base="xs:string">
			<!-- Allowable options are {Require[All][Non][Primary]LeadReading[NoFrontText][NotHyphenBound]} -->
			<xs:enumeration value="RequireLeadReading"/>
			<xs:enumeration value="RequireLeadReadingNoFrontText"/>
			<xs:enumeration value="RequireLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="RequireLeadReadingNotHyphenBound"/>
			<xs:enumeration value="RequireNonLeadReading"/>
			<xs:enumeration value="RequireNonLeadReadingNoFrontText"/>
			<xs:enumeration value="RequireNonLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="RequireNonLeadReadingNotHyphenBound"/>
			<xs:enumeration value="RequirePrimaryLeadReading"/>
			<xs:enumeration value="RequirePrimaryLeadReadingNoFrontText"/>
			<xs:enumeration value="RequirePrimaryLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="RequirePrimaryLeadReadingNotHyphenBound"/>
			<xs:enumeration value="RequireNonPrimaryLeadReading"/>
			<xs:enumeration value="RequireNonPrimaryLeadReadingNoFrontText"/>
			<xs:enumeration value="RequireNonPrimaryLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="RequireNonPrimaryLeadReadingNotHyphenBound"/>
			<xs:enumeration value="RequireAllLeadReading"/>
			<xs:enumeration value="RequireAllLeadReadingNoFrontText"/>
			<xs:enumeration value="RequireAllLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="RequireAllLeadReadingNotHyphenBound"/>
			<xs:enumeration value="RequireAllNonLeadReading"/>
			<xs:enumeration value="RequireAllNonLeadReadingNoFrontText"/>
			<xs:enumeration value="RequireAllNonLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="RequireAllNonLeadReadingNotHyphenBound"/>
			<xs:enumeration value="RequireAllNonPrimaryLeadReading"/>
			<xs:enumeration value="RequireAllNonPrimaryLeadReadingNoFrontText"/>
			<xs:enumeration value="RequireAllNonPrimaryLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="RequireAllNonPrimaryLeadReadingNotHyphenBound"/>
			<xs:enumeration value="RequireAllPrimaryLeadReading"/>
			<xs:enumeration value="RequireAllPrimaryLeadReadingNoFrontText"/>
			<xs:enumeration value="RequireAllPrimaryLeadReadingNoFrontTextNotHyphenBound"/>
			<xs:enumeration value="RequireAllPrimaryLeadReadingNotHyphenBound"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ListStyleEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="CompactSimpleList"/>
			<xs:enumeration value="CompoundList"/>
			<xs:enumeration value="FactTypeList"/>
			<xs:enumeration value="IdentityEqualityList"/>
			<xs:enumeration value="IndentedCompoundList"/>
			<xs:enumeration value="IndentedList"/>
			<xs:enumeration value="IndentedLogicalAndList"/>
			<xs:enumeration value="IndentedLogicalOrList"/>
			<xs:enumeration value="MultilineIndentedCompoundList"/>
			<xs:enumeration value="ObjectTypeInstanceList"/>
			<xs:enumeration value="SimpleList"/>
			<xs:enumeration value="SimpleLogicalAndList"/>
			<xs:enumeration value="SimpleLogicalOrList"/>
			<xs:enumeration value="TopLevelIndentedLogicalAndList"/>
			<xs:enumeration value="TopLevelIndentedLogicalOrList"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ListStyleEnumOrNull">
		<xs:union memberTypes="ListStyleEnum">
			<xs:simpleType>
				<xs:restriction base="xs:token">
					<xs:enumeration value="null"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:union>
	</xs:simpleType>
	<xs:simpleType name="RoleIteratorContextMatchEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="included"/>
			<xs:enumeration value="excluded"/>
			<xs:enumeration value="primary"/>
			<xs:enumeration value="secondary"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="IterateRolesMatchEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="all"/>
			<xs:enumeration value="included"/>
			<xs:enumeration value="excluded"/>
			<xs:enumeration value="constraintRoles"/>
			<xs:enumeration value="preferredIdentifier"/>
			<xs:enumeration value="playedRoles"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:attributeGroup name="FactArityAttributes">
		<xs:attribute name="factCount" type="xs:unsignedByte" use="optional"/>
		<xs:attribute name="factArity" type="xs:unsignedByte" use="optional"/>
		<xs:attribute name="constraintArity" type="xs:unsignedByte" use="optional"/>
		<xs:attribute name="minConstraintArity" type="xs:unsignedByte" use="optional"/>
		<xs:attribute name="minFactArity" type="xs:unsignedByte" use="optional"/>
		<xs:attribute name="maxFactArity" type="xs:unsignedByte" use="optional"/>
	</xs:attributeGroup>
	<xs:complexType name="SnippetLeafType">
		<xs:attribute name="ref" use="required">
			<xs:simpleType>
				<xs:union memberTypes="ve:SnippetTypeEnum">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="null"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:union>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="alternateSign" use="optional">
			<xs:annotation>
				<xs:documentation>Retrieve a snippet with a sign other than the one specified by the caller.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:token">
					<xs:enumeration value="opposite">
						<xs:annotation>
							<xs:documentation>Use the opposite of the requested sign.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="positive">
						<xs:annotation>
							<xs:documentation>Use a positively-signed snippet.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="negative">
						<xs:annotation>
							<xs:documentation>Use a negatively-signed snippet.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="SnippetLeafTypeWithConditionalMatch">
		<xs:complexContent>
			<xs:extension base="SnippetLeafType">
				<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="ConditionalBlockContextType">
		<xs:annotation>
			<xs:documentation>Provide an extension point for adding extra context code at the beginning of a conditional block.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:token">
			<xs:enumeration value="ObjectifiedFactType">
				<xs:annotation>
					<xs:documentation>Used when object type is objectified fact type.</xs:documentation>
				</xs:annotation>				
			</xs:enumeration>
			<xs:enumeration value="BinaryLeadReading">
				<xs:annotation>
					<xs:documentation>Used to determine whether binary lead readings are available for some column of a two-column of a two-column SetComparisonConstraint.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="SubtypeFactRolePlayers">
				<xs:annotation>
					<xs:documentation>Declare subtype and supertype variables for a SubtypeFact context.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="PreferredFor">
				<xs:annotation>
					<xs:documentation>Declare a preferredFor variable for a UniquenessConstraint context.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ConditionalMatchPatternType">
		<xs:annotation>
			<xs:documentation>Provide an extension point for conditionally including snippets.</xs:documentation>
		</xs:annotation>
		<xs:restriction base="xs:token">
			<xs:enumeration value="IsEntityType">
				<xs:annotation>
					<xs:documentation>True if the IsValueType property for the current object type is false.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="IsValueType">
				<xs:annotation>
					<xs:documentation>True if the IsValueType property for the current object type is true.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="IsObjectifiedFactType">
				<xs:annotation>
					<xs:documentation>True if the IsValueType property for the current object type is true.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="HasPortableDataType">
				<xs:annotation>
					<xs:documentation>True if the current object type has portable data type.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="HasNotes">
				<xs:annotation>
					<xs:documentation>True if the current object type has notes associated with it.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="IsIndependent">
				<xs:annotation>
					<xs:documentation>True if the current object type is independent.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="HasReferenceMode">
				<xs:annotation>
					<xs:documentation>True if the current object type has a reference mode.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="HasPreferredIdentifier">
				<xs:annotation>
					<xs:documentation>True if the current object type has preferred identifier.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="HasUnobjectifiedPreferredIdentifier">
				<xs:annotation>
					<xs:documentation>True if the current object type has a preferred identifier that is not an internal constraint on an objectified fact type.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="IsPersonal">
				<xs:annotation>
					<xs:documentation>True if the IsPersonal property for the current role player is true.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="IsPreferredIdentifier">
				<xs:annotation>
					<xs:documentation>True if the current constraint is a preferred identifier.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="BinaryWithRoleName">
				<xs:annotation>
					<xs:documentation>True if the current role is named and is playing a role within a binary fact type.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="RolePlayerHasReferenceScheme">
				<xs:annotation>
					<xs:documentation>True if the current role player has a reference scheme</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="IsPositive">
				<xs:annotation>
					<xs:documentation>
						Matches if creating a positive verbalization.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="IsNegative">
				<xs:annotation>
					<xs:documentation>
						Matches if creating a negative verbalization.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="IsSingleValue">
				<xs:annotation>
					<xs:documentation>
						True if the value range collection has only one value range whose
						min value is equal to the max value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="IsText">
				<xs:annotation>
					<xs:documentation>
						True if the current ValueConstraint has a text data type.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="IsBinaryLeadReading">
				<xs:annotation>
					<xs:documentation>
						True if non-hyphenated lead readings start at lead column roles are available in a 2x2 set comparison constraint.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="IsBinaryLeadReadingReverse">
				<xs:annotation>
					<xs:documentation>
						True if non-hyphenated lead readings start at trailing column roles are available in a 2x2 set comparison constraint.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ExclusionIsExclusiveOrConstraint">
				<xs:annotation>
					<xs:documentation>
						True if the Exclusion constraint is an Exclusive Or Constraint
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinEqualsMax">
				<xs:annotation>
					<xs:documentation>
						Matches a value range whose min value is equal to the max value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinClosedMaxUnbounded">
				<xs:annotation>
					<xs:documentation>
						Matches a value range with a closed minimum value and an unbounded maximum value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinOpenMaxUnbounded">
				<xs:annotation>
					<xs:documentation>
						Matches a value range with an open minimum value and an unbounded maximum value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinUnboundedMaxClosed">
				<xs:annotation>
					<xs:documentation>
						Matches a value range with an unbounded minimum value and a closed maximum value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinUnboundedMaxOpen">
				<xs:annotation>
					<xs:documentation>
						Matches a value range with an unbounded minimum value and an open maximum value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinClosedMaxClosed">
				<xs:annotation>
					<xs:documentation>
						Matches a value range with a closed minimum value and an open maximum value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinClosedMaxOpen">
				<xs:annotation>
					<xs:documentation>
						Matches a value range with a closed minimum value and an open maximum value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinOpenMaxClosed">
				<xs:annotation>
					<xs:documentation>
						Matches a value range with an open minimum value and an open maximum value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinOpenMaxOpen">
				<xs:annotation>
					<xs:documentation>
						Matches a value range with an open minimum value and an open maximum value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="FrequencyRangeExact">
				<xs:annotation>
					<xs:documentation>
						Matches a frequency range where the minimum and maximum frequencies are equal.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="FrequencyRangeMaxUnbounded">
				<xs:annotation>
					<xs:documentation>
						Matches a frequency range with no upper bound.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="FrequencyRangeMinUnbounded">
				<xs:annotation>
					<xs:documentation>
						Matches a frequency range where the minimum is one.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="SingleRoleRoleSequence">
				<xs:annotation>
					<xs:documentation>
						Matches a role sequence with exactly one role.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="ObjectifyingInstance">
				<xs:annotation>
					<xs:documentation>
						The FactTypeInstance has an objectifying identifier that should be displayed
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="VerbalizeFactTypesWithBrowserObjectType">
				<xs:annotation>
					<xs:documentation>
						Verbalize only if we're writing to the verbalization browser and have the correct option set.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="SnippetType">
		<xs:complexContent>
			<xs:extension base="SnippetLeafType">
				<xs:group ref="ReplacementElementsGroup" minOccurs="0" maxOccurs="unbounded"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:group name="ReplacementElementsGroup">
		<xs:choice>
			<xs:element name="Snippet" type="SnippetType"/>
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType"/>
			<xs:element name="ContextName" type="ContextNameType"/>
			<xs:element name="ObjectifyingInstanceIdentifierName" type="ObjectifyingInstanceIdentifierNameType"/>
			<xs:element name="ContextId" type="ElementIdType"/>
			<xs:element name="NoteText" type="NoteTextType"/>
			<xs:element name="ReferenceMode" type="ReferenceModeType"/>
			<xs:element name="PortableDataType" type="PortableDataTypeType"/>
			<xs:element name="Notes" type="NotesType"/>
			<xs:element name="IterateRoles" type="IterateRolesType"/>
			<xs:element name="IterateSequences" type="IterateSequencesType"/>
			<xs:element name="CompositeList" type="CompositeListType"/>
			<xs:element name="Fact" type="FactType"/>
			<xs:element name="IterateFacts" type="IterateFactsType"/>
			<xs:element name="ReferenceScheme" type="ReferenceSchemeType"/>
			<xs:element name="ConditionalReplacement" type="ConditionalReplacementType"/>
			<xs:element name="IterateValueRanges" type="IterateValueRangesType"/>
			<xs:element name="MinValue" type="MinValueType"/>
			<xs:element name="MaxValue" type="MaxValueType"/>
			<xs:element name="MinFrequencyValue" type="MinFrequencyValueType"/>
			<xs:element name="MaxFrequencyValue" type="MaxFrequencyValueType"/>
			<xs:element name="IterateContextRoles" type="IterateContextRolesType"/>
			<xs:element name="PreferredIdentifierFor" type="PreferredIdentifierForType"/>
			<xs:element name="PreferredIdentifierForId" type="ElementIdType"/>
			<xs:element name="RoleName" type="RoleNameType"/>
			<xs:element name="RolePlayer" type="RolePlayerType"/>
			<xs:element name="RolePlayerReferenceMode" type="RolePlayerReferenceModeType"/>
			<xs:element name="SubtypeName" type="SubtypeNameType"/>
			<xs:element name="SubtypeId" type="ElementIdType"/>
			<xs:element name="SupertypeName" type="SupertypeNameType"/>
			<xs:element name="SupertypeId" type="ElementIdType"/>
			<xs:element name="ValueRangeValueTypeName" type="ValueRangeValueTypeNameType"/>
			<xs:element name="ValueRangeValueTypeId" type="ElementIdType"/>
		</xs:choice>
	</xs:group>
	<xs:group name="ReplacementElementsWithConditionalMatchGroup">
		<xs:annotation>
			<xs:documentation>The elements listed in ReplacementElementsGroup with a
			conditionalMatch attribute added. Used inside the ConditionalReplacements element.</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="Snippet" type="SnippetTypeWithConditionalMatch"/>
			<xs:element name="IterateRoles">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="IterateRolesType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="CompositeList">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="CompositeListType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="ReferenceScheme">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="ReferenceSchemeType"/>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="Fact">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="FactType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="IterateFacts">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="IterateFactsType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="IterateSequences">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="IterateSequencesType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="ConditionalReplacement">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="ConditionalReplacementType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="ReadingContext">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="ReadingContextType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="ConditionalReading">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="ConditionalReadingType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="IterateValueRanges">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="IterateValueRangesType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="MinValue">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="MinValueType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="MaxValue">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="MaxValueType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="MinFrequencyValue">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="MinFrequencyValueType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="MaxFrequencyValue">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="MaxFrequencyValueType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="IterateContextRoles">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="IterateContextRolesType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="RoleName">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="RoleNameType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="RolePlayer">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="RolePlayerType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="RolePlayerReferenceMode">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="RolePlayerReferenceModeType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
		</xs:choice>
	</xs:group>
	
	<xs:complexType name="SnippetTypeWithConditionalMatch">
		<xs:complexContent>
			<xs:extension base="SnippetType">
				<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
				<xs:attribute name="conditionalBlockContext" use="optional" type="ConditionalBlockContextType"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ConditionalSnippetType">
		<xs:annotation>
			<xs:documentation>
				Provides a commonly matchable pattern.  The ConditionalSnippet holds multiple potential
				Snippets with match conditions, plus a fallback snippet.  The SnippetReplacements section
				contains the replacement fields that will be used for all snippets.
			</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="1" maxOccurs="unbounded">
			<xs:element name="Snippet" type="SnippetLeafTypeWithConditionalMatch"/>
			<xs:element name="SnippetReplacements" type="SnippetReplacementsType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="SnippetReplacementsType">
		<xs:annotation>
			<xs:documentation>
				Holds potential replacement fields for the conditional snippets listed above.
				There must be at least as many replacement fields here as there are in the conditional snippet
				which requires the most replacement fields.
			</xs:documentation>
		</xs:annotation>
		<xs:group ref="ReplacementElementsGroup" minOccurs="0" maxOccurs="unbounded"/>
	</xs:complexType>
	<xs:complexType name="ConditionalReplacementType">
		<xs:annotation>
			<xs:documentation>
				Provides a commonly matchable pattern similar to ConditionalSnippet.  ConditionalReplacements
				are only allowed within SnippetReplacement tags, and they allow a conditional selection of
				replacement contents for the replacement fields in the ConditionalSnippet.
			</xs:documentation>
		</xs:annotation>
		<xs:group ref="ReplacementElementsWithConditionalMatchGroup" minOccurs="1" maxOccurs="unbounded"/>
	</xs:complexType>
	<xs:complexType name="IterateValueRangesType">
		<xs:annotation>
			<xs:documentation>
				Iterates a value range collection.
			</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="1" maxOccurs="unbounded">
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType"/>
		</xs:choice>
		<xs:attribute name="listStyle" type="ListStyleEnum"/>
	</xs:complexType>
	<xs:complexType name="ValueRangeValueTypeNameType">
		<xs:annotation>
			<xs:documentation>
				Returns the name of the value type.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="PortableDataTypeType">
		<xs:annotation>
			<xs:documentation>
				Returns the portable data type of the object type.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="NotesType">
		<xs:annotation>
			<xs:documentation>
				Returns the notes of the object type.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="ContextNameType">
		<xs:annotation>
			<xs:documentation>
				Returns the name of the context (this) element.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="ObjectifyingInstanceIdentifierNameType">
		<xs:annotation>
			<xs:documentation>
				Returns the IdentifierName for an ObjectTypeInstance.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="ElementIdType">
		<xs:annotation>
			<xs:documentation>
				Returns the hyphenated string form of the id for the object type.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="PreferredIdentifierForType">
		<xs:annotation>
			<xs:documentation>
				Returns the name of the identified ObjectType from the context of a UniquenessConstraint
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="ObjectTypeInstanceValueType">
		<xs:annotation>
			<xs:documentation>
				Returns the value of the Object Type Instance
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="SubtypeNameType">
		<xs:annotation>
			<xs:documentation>
				Returns the name of the sub type role player.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="SupertypeNameType">
		<xs:annotation>
			<xs:documentation>
				Returns the name of the sub type role player.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="NoteTextType">
		<xs:annotation>
			<xs:documentation>
				Returns the notes of the object type.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="ReferenceModeType">
		<xs:annotation>
			<xs:documentation>
				Returns the reference mode of the object type.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="MinValueType">
		<xs:annotation>
			<xs:documentation>
				Returns the minimum value of a value range constraint.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="MaxValueType">
		<xs:annotation>
			<xs:documentation>
				Returns the maximum value of a value range constraint.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="MinFrequencyValueType">
		<xs:annotation>
			<xs:documentation>
				Returns the minimum value of a frequency constraint.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="MaxFrequencyValueType">
		<xs:annotation>
			<xs:documentation>
				Returns the maximumu value of a frequency constraint.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="RoleNameType">
		<xs:annotation>
			<xs:documentation>
				Returns the name of a role.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="RoleIndexType">
		<xs:annotation>
			<xs:documentation>Returns the index of the current role player in a context reading order. A context reading is required.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="RolePlayerType">
		<xs:annotation>
			<xs:documentation>
				Returns the name of the current role player role.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="RolePlayerReferenceModeType">
		<xs:annotation>
			<xs:documentation>
				Returns the reference mode scheme of the attached role player.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="PredicateReplacementType">
		<xs:choice minOccurs="1" maxOccurs="1">
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType"/>
			<xs:element name="Snippet" type="SnippetType">
				<xs:annotation>
					<xs:documentation>The {0} replacement field for this snippet always corresponds to the role player name. Contained snippets are used as replacements for subsequent fields.</xs:documentation>
				</xs:annotation>
			</xs:element>
		</xs:choice>
		<xs:attribute name="match" use="optional" type="RoleIteratorContextMatchEnum"/>
		<xs:attribute name="alternateRolePlayer">
			<xs:annotation>
				<xs:documentation>Use with a binary constraint to use a role player other than the current role player.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:token">
					<xs:enumeration value="other">
						<xs:annotation>
							<xs:documentation>Use the role player for the other constraint role.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="primary">
						<xs:annotation>
							<xs:documentation>Use the role player for the primary role. This is equivalent to 'other' for the secondary role, but is easier to calculate because it is already tracked.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="subscript" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Explicitly use (or don't use) subscripts for this predicate replacement. Overrides the context EnableSubscripts/@custom or IterateRoles/@subscript values.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="overflowSubscript" type="xs:nonNegativeInteger">
			<xs:annotation>
				<xs:documentation>Add a subscript incremented beyond the normal required count for the factType. The specified value is added to the number of role players with this role player type that exist in the context fact type.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="pass" use="optional" type="PassEnum"/>
	</xs:complexType>
	<xs:complexType name="FactConstructType">
		<!-- Nothing here yet, this is for the top-level verbalization of a Fact -->
	</xs:complexType>
	<xs:complexType name="SubtypeConstructType">
		<xs:annotation>
			<xs:documentation>
				Returns the full verbalization for a subtype fact, i.e, Man is a subtype of Person.
			</xs:documentation>
		</xs:annotation>
		<xs:choice maxOccurs="unbounded">
			<xs:element name="Snippet" type="SnippetTypeWithConditionalMatch" />
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType" />
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="NoteConstructType">
		<xs:annotation>
			<xs:documentation>Returns the verbalization for the notes associated with an objectType.</xs:documentation>
		</xs:annotation>
		<xs:choice maxOccurs="unbounded">
			<xs:element name="Snippet" type="SnippetTypeWithConditionalMatch" />
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType" />
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ModelConstructType">
		<xs:annotation>
			<xs:documentation>Returns the verbalization for the ORMModel.</xs:documentation>
		</xs:annotation>
		<xs:choice maxOccurs="unbounded">
			<xs:element name="Snippet" type="SnippetTypeWithConditionalMatch" />
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType" />
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ObjectConstructType">
		<xs:annotation>
			<xs:documentation>Returns the full verbalization for an entity, value, or objectified fact type.</xs:documentation>
		</xs:annotation>
		<xs:choice maxOccurs="unbounded">
			<xs:element name="Snippet" type="SnippetTypeWithConditionalMatch" />
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType" />
			<xs:element name="ErrorReportHere" type="ErrorReportHereType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ErrorReportHereType">
		<xs:annotation>
			<xs:documentation>Add this tag between top-level snippets to indidate that the error report should be placed here instead of at the end.</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="FactType">
		<xs:annotation>
			<xs:documentation>
				Returns the full verbalization for a fact type, i.e, Company provides Product to Company.
			</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0" maxOccurs="1">
			<xs:element name="PredicateReplacement" type="PredicateReplacementType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="readingChoice" use="optional" type="ReadingChoicePreferSingleMatchWithContextEnum"/>
		<xs:attribute name="subtypeMetaReading" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Use the 'Each A is an instance of B' meta reading for subtype facts instead of the 'A is B' instance reading.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="closeSentence" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Capitalize and punctuation the fact statement. Not applicable for top-level elements.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="ReferenceSchemeType">
		<xs:annotation>
			<xs:documentation>
				Returns the reference scheme for an object, e.g. Country has CountryCode etc.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="IterateRolesNoListType">
		<xs:choice>
			<xs:sequence>
				<xs:element name="ReadingContext">
					<xs:annotation>
						<xs:documentation>If hyphenBind="true" on the parent and the pattern group contains multiple facts, then an additional ReadingContext needs to be set to support binding a reading of the current fact.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:attribute name="match" use="optional" type="ReadingChoicePreferSingleMatchEnum"/>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			<xs:choice minOccurs="0" maxOccurs="unbounded">
				<xs:element name="Fact" type="FactType"/>
				<xs:element name="Snippet" type="SnippetType"/>
				<xs:element name="IterateContextRoles" type="IterateContextRolesType"/>
				<xs:element name="RolePlayer" type="RolePlayerType"/>
				<xs:element name="RoleIndex" type="RoleIndexType"/>
			</xs:choice>
		</xs:choice>
		<xs:attribute name="match" type="IterateRolesMatchEnum" default="all"/>
		<xs:attributeGroup ref="FactArityAttributes"/>
		<xs:attribute name="pass" use="optional" type="PassEnum"/>
		<xs:attribute name="hyphenBind" type="xs:boolean" default="false"/>
		<xs:attribute name="subscript" type="xs:boolean">
			<xs:annotation>
				<xs:documentation>Explicitly use (or don't use) subscripts for predicate replacements in this contect. Overrides the context EnableSubscripts/@custom value.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="conditionalReading">
			<xs:annotation>
				<xs:documentation>A filter based on the availability of the required reading for the specified context. Use with pass="first" to use a single reading only. The readingChoice for a nested Fact element should be ConditionalContext.</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:union memberTypes="ReadingChoicePreferSingleMatchEnum ReadingChoiceFullRequiredMatchEnum"/>
			</xs:simpleType>
		</xs:attribute>
		<xs:attribute name="uniqueFactType" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Set to true if a visited FactTypes should be tracked. If this is set, then a later role with the same FactType will be ignored.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="verifyCanVerbalizeFactType" type="xs:boolean" default="false">
			<xs:annotation>
				<xs:documentation>Set to true if the FactType has not already been verified as have sufficient state to support verbalization.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="IterateRolesType">
		<xs:complexContent>
			<xs:extension base="IterateRolesNoListType">
				<xs:attribute name="listStyle" use="required" type="ListStyleEnumOrNull"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IterateSequencesType">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="Snippet" type="SnippetType"/>
			<xs:element name="IterateRoles" type="IterateRolesType"/>
		</xs:choice>
		<xs:attributeGroup ref="FactArityAttributes"/>
		<xs:attribute name="pass" use="optional" type="PassEnum"/>
		<xs:attribute name="listStyle" use="required" type="ListStyleEnumOrNull"/>
		<xs:attribute name="compositeList" type="xs:boolean" fixed="true">
			<xs:annotation>
				<xs:documentation>The listStyle represents a composite list. Ignored if listStyle is null. false is not currently supported.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
		<xs:attribute name="hyphenBind" type="xs:boolean" default="false"/>
	</xs:complexType>
	<xs:complexType name="IterateInstancesType">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="ObjectTypeInstanceValue" type="ObjectTypeInstanceValueType"/>
		</xs:choice>
		<xs:attribute name="listStyle" use="required" type="ListStyleEnumOrNull"/>
	</xs:complexType>
	<xs:complexType name="IterateFactsType">
		<xs:annotation>
			<xs:documentation>
				Returns the full verbalization for a list of fact types with the specified list style.
			</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0" maxOccurs="1">
			<xs:element name="PredicateReplacement" type="PredicateReplacementType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="listStyle" use="required" type="ListStyleEnumOrNull"/>
		<xs:attribute name="readingChoice" use="optional" type="ReadingChoicePreferSingleMatchEnum"/>
	</xs:complexType>
	<xs:complexType name="IterateContextRolesNoListType">
		<xs:group ref="ReplacementElementsGroup" minOccurs="0" maxOccurs="unbounded"/>
		<xs:attribute name="match" type="RoleIteratorContextMatchEnum" use="optional"/>
		<xs:attribute name="pass" use="optional" type="PassEnum"/>
	</xs:complexType>
	<xs:complexType name="IterateContextRolesType">
		<xs:complexContent>
			<xs:extension base="IterateContextRolesNoListType">
				<xs:attribute name="listStyle" type="ListStyleEnumOrNull" use="required"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="BaseReadingContextType">
		<xs:choice minOccurs="1" maxOccurs="unbounded">
			<xs:element name="Fact" type="FactType"/>
			<xs:element name="Snippet" type="SnippetType"/>
			<xs:element name="CompositeList" type="CompositeListType"/>
			<xs:element name="IterateRoles" type="IterateRolesType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="ReadingChoiceType">
		<xs:complexContent>
			<xs:extension base="BaseReadingContextType">
				<xs:attribute name="match" use="optional" type="ReadingChoiceFullRequiredMatchEnum"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ConditionalReadingType">
		<xs:sequence>
			<xs:element name="ReadingChoice" type="ReadingChoiceType" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ReadingContextType">
		<xs:complexContent>
			<xs:extension base="BaseReadingContextType">
				<xs:attribute name="match" use="optional" type="ReadingChoicePreferSingleMatchEnum"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="CompositeListType">
		<xs:choice>
			<xs:element name="IterateRoles" type="IterateRolesNoListType" minOccurs="2" maxOccurs="unbounded"/>
			<xs:element name="IterateContextRoles" type="IterateContextRolesNoListType" minOccurs="2" maxOccurs="unbounded"/>
		</xs:choice>
		<xs:attribute name="listStyle" type="ListStyleEnum" use="required"/>
	</xs:complexType>
	<xs:complexType name="ConstraintsConstructType">
		<xs:sequence>
			<xs:element name="Constraint" type="ConstraintType" minOccurs="1" maxOccurs="unbounded">
				<xs:unique name="ConstrainedRolesFilter">
					<xs:selector xpath="cvg:ConstrainedRoles"/>
					<xs:field xpath="@span"/>
					<xs:field xpath="@factArity"/>
					<xs:field xpath="@minFactArity"/>
					<xs:field xpath="@maxFactArity"/>
				</xs:unique>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="SampleInstancesConstructType">
		<xs:annotation>
			<xs:documentation>
				Allows for generation of Verbalizers for Instances
			</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="SampleInstance" type="SampleInstanceType"/>
			<xs:element name="SingleSnippet" type="SingleSnippetType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="EnableSubscriptsType">
		<xs:attribute name="minFactArity" type="xs:positiveInteger"/>
		<xs:attribute name="maxFactArity" type="xs:positiveInteger"/>
		<xs:attribute name="factArity" type="xs:positiveInteger"/>
		<xs:attribute name="factCount" type="xs:positiveInteger"/>
		<xs:attribute name="minFactCount" type="xs:positiveInteger"/>
		<xs:attribute name="maxFactCount" type="xs:positiveInteger"/>
		<xs:attribute name="nonOptimizedFrequencyPattern" type="xs:boolean"/>
		<xs:attribute name="custom">
			<xs:annotation>
				<xs:documentation>Should replacement fields be generated for both subscripted and non-subscripted names?</xs:documentation>
			</xs:annotation>
			<xs:simpleType>
				<xs:restriction base="xs:token">
					<xs:enumeration value="defaultPlain">
						<xs:annotation>
							<xs:documentation>By default, use predicate replacements values without subscripts.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
					<xs:enumeration value="defaultSubscript">
						<xs:annotation>
							<xs:documentation>By default, use predicate replacements values with subscripts.</xs:documentation>
						</xs:annotation>
					</xs:enumeration>
				</xs:restriction>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:simpleType name="RingTypeEnum">
		<xs:restriction base="xs:token">
			<xs:enumeration value="Acyclic"/>
			<xs:enumeration value="Antisymmetric"/>
			<xs:enumeration value="Asymmetric"/>
			<xs:enumeration value="Intransitive"/>
			<xs:enumeration value="Irreflexive"/>
			<xs:enumeration value="Symmetric"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="FrequencyRangePatternEnum">
		<xs:restriction base="xs:token">
			<xs:enumeration value="Exact">
				<xs:annotation>
					<xs:documentation>The min and max frequency are equal</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinUnbounded">
				<xs:annotation>
					<xs:documentation>The min frequency is default (1, maps to no explicit bound)</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MaxUnbounded">
				<xs:annotation>
					<xs:documentation>The max frequency is unbounded</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="Both">
				<xs:annotation>
					<xs:documentation>The min and max frequency are both specified to non-default values</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="ConstraintType">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="EnableSubscripts" type="EnableSubscriptsType"/>
			<xs:element name="ConstrainedRoles">
				<xs:complexType>
					<xs:choice minOccurs="1" maxOccurs="unbounded">
						<xs:element name="Snippet" type="SnippetTypeWithConditionalMatch"/>
						<xs:element name="IterateRoles" type="IterateRolesType"/>
						<xs:element name="CompositeList" type="CompositeListType"/>
						<xs:element name="ConditionalSnippet" type="ConditionalSnippetType"/>
						<xs:element name="ConditionalReading" type="ConditionalReadingType">
							<xs:unique name="ConditionalReadingReadingChoice">
								<xs:selector xpath="cvg:ReadingChoice"/>
								<xs:field xpath="@match"/>
							</xs:unique>
						</xs:element>
						<xs:element name="ReadingContext" type="ReadingContextType"/>
					</xs:choice>
					<xs:attribute name="span" type="SpanEnum" use="optional"/>
					<xs:attribute name="sign" type="ve:SignEnum" use="optional"/>
					<xs:attribute name="ringType" type="RingTypeEnum" use="optional"/>
					<xs:attribute name="columnArity" type="xs:positiveInteger" use="optional"/>
					<xs:attribute name="sameConstraintRolePlayers" type="xs:boolean" use="optional">
						<xs:annotation>
							<xs:documentation>Used for a constraint with two roles that have the same role players. Use after a constraintArity attribute of 2.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute name="rolePlayerLimitedToConstraintRoles" type="xs:boolean" use="optional">
						<xs:annotation>
							<xs:documentation>Used to verify that the role players for the constraint roles are not used elsewhere in the fact type. Use after sameConstraintRolePlayers.</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attribute name="frequencyRangePattern" type="FrequencyRangePatternEnum" use="optional">
						<xs:annotation>
							<xs:documentation>The frequency range pattern to check</xs:documentation>
						</xs:annotation>
					</xs:attribute>
					<xs:attributeGroup ref="FactArityAttributes"/>
				</xs:complexType>
			</xs:element>
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType"/>
		</xs:choice>
		<xs:attribute name="type" type="ConstraintTypeEnum" use="required"/>
		<xs:attribute name="patternGroup" type="ConstraintPatternGroupEnum" use="required"/>
		<xs:attribute name="compatibleColumns" type="xs:boolean" default="false"/>
		<xs:attribute name="childHelperFor" type="ChildHelperForEnum" use="optional"/>
		<xs:attribute name="deferMatchesTo" type="xs:string">
			<xs:annotation>
				<xs:documentation>Perform standard error handling, but defer all pattern matches to the specified function. Designed to work with either fully custom verbalization, or with wrapper code around generated helper classes.</xs:documentation>
			</xs:annotation>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="SampleInstanceType">
		<xs:annotation>
			<xs:documentation>
				Constructs IVerbalizer implementations for Sample Instance Data
			</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="1" maxOccurs="1">
			<xs:element name="IterateInstances" type="IterateInstancesType"/>
			<xs:sequence>
				<xs:element name="FactInstance">
					<xs:complexType/>
				</xs:element>
				<xs:element name="Snippet" type="SnippetTypeWithConditionalMatch"/>
			</xs:sequence>
		</xs:choice>
		<xs:attribute name="type" use="required"/>
		<xs:attribute name="childHelperFor" type="ChildHelperForEnum" use="optional"/>
	</xs:complexType>
	<xs:complexType name="SingleSnippetType">
		<xs:annotation>
			<xs:documentation>
				Constructs IVerbalizer implementation to verbalize a single snippet
			</xs:documentation>
		</xs:annotation>
		<xs:attribute name="type" use="required"/>
		<xs:attribute name="childHelperFor" type="ChildHelperForEnum" use="optional"/>
		<xs:attribute name="snippetRef" use="required" type="ve:SnippetTypeEnum"/>
	</xs:complexType>
	<xs:element name="VerbalizationRoot">
		<xs:complexType>
			<xs:sequence>
				<xs:element name="Copyright" minOccurs="0">
					<xs:annotation>
						<xs:documentation>Copyright notice.</xs:documentation>
					</xs:annotation>
					<xs:complexType>
						<xs:sequence>
							<xs:element name="CopyrightLine" type="xs:string" maxOccurs="unbounded"/>
						</xs:sequence>
						<xs:attribute name="name" type="xs:string" use="required"/>
					</xs:complexType>
				</xs:element>
				<xs:element name="Constructs" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:all>
							<xs:element name="FactType" type="FactConstructType"/>
							<xs:element name="SubtypeFact" type="SubtypeConstructType"/>
							<xs:element name="Constraints" type="ConstraintsConstructType"/>
							<xs:element name="SampleInstances" type="SampleInstancesConstructType"/>
							<xs:element name="ObjectType" type="ObjectConstructType" />
							<xs:element name="Definition" type="NoteConstructType" />
							<xs:element name="Note" type="NoteConstructType" />
							<xs:element name="ORMModel" type="ModelConstructType" />
						</xs:all>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
			<xs:attribute name="snippetsLocation" type="xs:string" use="required">
				<xs:annotation>
					<xs:documentation>The relative location of the file containing the snippets</xs:documentation>
				</xs:annotation>
			</xs:attribute>
		</xs:complexType>
	</xs:element>
</xs:schema>

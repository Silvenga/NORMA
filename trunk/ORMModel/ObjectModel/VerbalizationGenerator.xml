<?xml version="1.0" encoding="utf-8"?>
<VerbalizationRoot
	xmlns="http://schemas.neumont.edu/ORM/SDK/CoreVerbalizationGenerator"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://schemas.neumont.edu/ORM/SDK/CoreVerbalizationGenerator VerbalizationGenerator.xsd"
	snippetsLocation="VerbalizationCoreSnippets/VerbalizationCoreSnippets.xml">
	<Copyright name="Common Public License Copyright Notice">
		<CopyrightLine>/**************************************************************************\</CopyrightLine>
		<CopyrightLine>* Neumont Object-Role Modeling Architect for Visual Studio                 *</CopyrightLine>
		<CopyrightLine>*                                                                          *</CopyrightLine>
		<CopyrightLine>* Copyright © Neumont University. All rights reserved.                     *</CopyrightLine>
		<CopyrightLine>*                                                                          *</CopyrightLine>
		<CopyrightLine>* The use and distribution terms for this software are covered by the      *</CopyrightLine>
		<CopyrightLine>* Common Public License 1.0 (http://opensource.org/licenses/cpl) which     *</CopyrightLine>
		<CopyrightLine>* can be found in the file CPL.txt at the root of this distribution.       *</CopyrightLine>
		<CopyrightLine>* By using this software in any fashion, you are agreeing to be bound by   *</CopyrightLine>
		<CopyrightLine>* the terms of this license.                                               *</CopyrightLine>
		<CopyrightLine>*                                                                          *</CopyrightLine>
		<CopyrightLine>* You must not remove this notice, or any other, from this software.       *</CopyrightLine>
		<CopyrightLine>\**************************************************************************/</CopyrightLine>
	</Copyright>
	<Constructs>
		<!-- Generate FactType verbalization along with constraints -->
		<FactType/>
		<!-- Generate ObjectType verbalization along with constraints -->
		<ObjectType>
			<ConditionalSnippet>
				<Snippet ref="EntityTypeVerbalization" conditionalMatch="IsEntityType"/>
				<Snippet ref="ValueTypeVerbalization"/>
				<SnippetReplacements>
					<Snippet ref="ObjectType">
						<ObjectTypeName/>
					</Snippet>
				</SnippetReplacements>
			</ConditionalSnippet>
			<Snippet ref="ObjectifiesFactTypeVerbalization" conditionalMatch="IsObjectifiedFactType" conditionalBlockContext="ObjectifiedFactType">
				<Snippet ref="ObjectType">
					<ObjectTypeName/>
				</Snippet>
				<Fact/>
			</Snippet>
			<Snippet ref="ReferenceSchemeVerbalization" conditionalMatch="HasPreferredIdentifier">
				<IterateRoles match="preferredIdentifier" listStyle="CompoundList">
					<Fact/>
				</IterateRoles>
			</Snippet>
			<Snippet ref="ReferenceModeVerbalization" conditionalMatch="HasReferenceMode">
				<ReferenceMode/>
			</Snippet>
			<Snippet ref="IndependentVerbalization" conditionalMatch="IsIndependent">
				<Snippet ref="ObjectType">
					<ObjectTypeName/>
				</Snippet>
			</Snippet>
			<Snippet ref="PortableDataTypeVerbalization" conditionalMatch="HasPortableDataType">
				<PortableDataType/>
			</Snippet>
		</ObjectType>
		<Note>
			<Snippet ref="NotesVerbalization">
				<NoteText/>
			</Snippet>
		</Note>
		<!-- Generate constraint verbalizations -->
		<Constraints>
			<!-- Implied single-role internal uniqueness constraint on proxy role of implied binary fact -->
			<Constraint type="ImpliedUniqueVerbalizer" childHelperFor="FactType" patternGroup="InternalConstraint">
				<ConstrainedRoles constraintArity="1" factArity="2" sign="positive">
					<ConditionalReading>
						<ReadingChoice match="RequireLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="OneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles listStyle="SimpleList" match="included" hyphenBind="true"/>
								<Snippet ref="ImpliedModalNecessityOperator">
									<Fact>
										<PredicateReplacement match="included">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="OneQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
					<Snippet ref="ConstraintProvidesPreferredIdentifier" conditionalMatch="IsPreferredIdentifier">
						<IterateRoles listStyle="null" match="included"/>
						<IterateRoles listStyle="null" match="excluded"/>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles constraintArity="1" factArity="2">
					<!-- sign="negative" is implied by the previous element -->
					<!-- The pattern is the same whether or not we have a lead reading, so don't use ConditionalReading here -->
					<ReadingContext match="PreferLeadReading">
						<Snippet ref="ForEachCompactQuantifier">
							<IterateRoles match="included" listStyle="CompactSimpleList" hyphenBind="true"/>
							<Snippet ref="ModalPossibilityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="excluded">
										<Snippet ref="OneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</Snippet>
					</ReadingContext>
				</ConstrainedRoles>
			</Constraint>
			<!-- Implied simple mandatory on constraint on proxy role of implied binary fact -->
			<Constraint type="ImpliedMandatoryVerbalizer" childHelperFor="FactType" patternGroup="InternalConstraint">
				<!-- 3.1.2 binary predicate -->
				<ConstrainedRoles factArity="2">
					<ConditionalReading>

						<!-- mandatory constraint starts reading relational style -->
						<!-- Each A R some B -->
						<ReadingChoice match="RequireLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>

						<!-- mandatory role does NOT start reading -->
						<!-- For each A, some B S that A -->
						<ReadingChoice>
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles match="included" listStyle="SimpleList" hyphenBind="true"/>
								<Snippet ref="ImpliedModalNecessityOperator">
									<Fact>
										<PredicateReplacement match="included">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			<!-- FactType.DefaultBinaryMissingUniquenessVerbalizer -->
			<Constraint type="DefaultBinaryMissingUniquenessVerbalizer" childHelperFor="FactType" patternGroup="InternalConstraint">
				<!-- The context here is an alethic constraint covering the opposite single role -->
				<ConstrainedRoles factArity="2" sign="positive">
					<Snippet ref="ModalPossibilityOperator">
						<Fact readingChoice="PreferNonLeadReading">
							<PredicateReplacement match="included">
								<Snippet ref="MoreThanOneQuantifier"/>
							</PredicateReplacement>
							<PredicateReplacement>
								<Snippet ref="IdentityReferenceQuantifier"/>
							</PredicateReplacement>
						</Fact>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<!-- FactType.CombinedMandatoryUniqueVerbalizer -->
			<Constraint type="CombinedMandatoryUniqueVerbalizer" childHelperFor="FactType" patternGroup="InternalConstraint">
				<!-- 3.1.2 binary predicate -->
				<ConstrainedRoles factArity="2" sign="positive">
					<ConditionalReading>

						<!-- mandatory constraint starts reading relational style -->
						<!-- Each A R some B -->
						<ReadingChoice match="RequireLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExactlyOneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>

						<!-- mandatory role does NOT start reading -->
						<!-- For each A, some B S that A -->
						<ReadingChoice>
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles match="included" listStyle="SimpleList" hyphenBind="true"/>
								<Snippet ref="ImpliedModalNecessityOperator">
									<Fact>
										<PredicateReplacement match="included">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExactlyOneQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="MandatoryConstraint" patternGroup="SetConstraint" compatibleColumns="true">
				<!-- Handle internal constraint patterns first -->
				<!-- 3.1.1 unary predicate -->
				<!-- Each A R -->
				<ConstrainedRoles constraintArity="1" factArity="1" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="UniversalQuantifier">
							<Fact/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>

				<!-- 3.1.2 binary predicate -->
				<ConstrainedRoles constraintArity="1" factArity="2" maxFactArity="2">
					<ConditionalReading>

						<!-- mandatory constraint starts reading relational style -->
						<!-- Each A R some B -->
						<ReadingChoice match="RequireLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>

						<!-- mandatory role does NOT start reading -->
						<!-- For each A, some B S that A -->
						<ReadingChoice>
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles match="included" listStyle="SimpleList" hyphenBind="true"/>
								<Snippet ref="ImpliedModalNecessityOperator">
									<Fact>
										<PredicateReplacement match="included">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>

				<!-- mandatory constraint starts reading attribute style -->
				<!-- Each A R some B -->
				<!-- not doing this time around -->

				<!-- 3.1.3 n-ary predicate -->
				<ConstrainedRoles constraintArity="1" minFactArity="3">
					<ConditionalReading>
						<!-- mandatory role starts reading -->
						<!-- Each A R some B1 ... some Bn -->
						<ReadingChoice match="RequireLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>

						<!-- mandatory role does NOT start reading-->
						<!-- For each A,
							some B1 R ... that A ... some Bn -->
						<ReadingChoice>
							<Snippet ref="ForEachIndentedQuantifier">
								<IterateRoles match="included" listStyle="SimpleList" hyphenBind="true"/>
								<Snippet ref="ImpliedModalNecessityOperator">
									<Fact>
										<PredicateReplacement match="included">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>

				<!-- Start disjunctive mandatory constraints -->
				<!-- Unaries are the only reading choice that has an optional negative reading -->
				<ConstrainedRoles sign="negative" maxFactArity="1">
					<Snippet ref="ModalPossibilityOperator">
						<Snippet ref="NegativeReadingForUnaryOnlyDisjunctiveMandatory">
							<IterateRoles listStyle="null" match="setConstraintRoles" pass="first"/>
							<IterateFacts listStyle="IndentedCompoundList"/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles sign="positive" maxFactArity="1">
					<ConditionalReading>
						<ReadingChoice match="RequireAllLeadReadingNoFrontText">
							<Snippet ref="ImpliedModalNecessityOperator">
								<IterateRoles listStyle="TopLevelIndentedLogicalOrList"  match="setConstraintRoles">
									<Fact readingChoice="Context">
										<PredicateReplacement match="primary" pass="first">
											<Snippet ref="UniversalQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement match="primary">
											<Snippet ref="null"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles listStyle="null" pass="first" match="setConstraintRoles"/>
								<Snippet ref="ImpliedModalNecessityOperator">
									<IterateRoles listStyle="SimpleLogicalOrList" match="setConstraintRoles">
										<Fact readingChoice="PreferPrimaryLeadReadingNoFrontText">
											<PredicateReplacement match="included">
												<Snippet ref="DefiniteArticle"/>
											</PredicateReplacement>
										</Fact>
									</IterateRoles>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
				<ConstrainedRoles sign="positive">
					<ConditionalReading>
						<ReadingChoice match="RequireAllPrimaryLeadReadingNoFrontText">
							<Snippet ref="ImpliedModalNecessityOperator">
								<CompositeList listStyle="TopLevelIndentedLogicalOrList">
									<IterateRoles minFactArity="2" match="setConstraintRoles">
										<Fact readingChoice="Context">
											<PredicateReplacement match="primary" pass="first">
												<Snippet ref="UniversalQuantifier"/>
											</PredicateReplacement>
											<PredicateReplacement match="primary">
												<Snippet ref="null"/>
											</PredicateReplacement>
											<PredicateReplacement>
												<Snippet ref="ExistentialQuantifier"/>
											</PredicateReplacement>
										</Fact>
									</IterateRoles>
									<IterateRoles factArity="1" match="setConstraintRoles">
										<Fact readingChoice="Context">
											<PredicateReplacement>
												<Snippet ref="null"/>
											</PredicateReplacement>
										</Fact>
									</IterateRoles>
								</CompositeList>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles match="setConstraintRoles" pass="first" listStyle="SimpleList"/>
								<Snippet ref="ImpliedModalNecessityOperator">
									<CompositeList listStyle="IndentedLogicalOrList">
										<IterateRoles match="setConstraintRoles" minFactArity="2">
											<Fact readingChoice="PreferPrimaryLeadReadingNoFrontText">
												<PredicateReplacement match="included">
													<Snippet ref="DefiniteArticle"/>
												</PredicateReplacement>
												<PredicateReplacement match="excluded">
													<Snippet ref="ExistentialQuantifier"/>
												</PredicateReplacement>
											</Fact>
										</IterateRoles>
										<IterateRoles factArity="1" match="setConstraintRoles">
											<Fact>
												<PredicateReplacement>
													<Snippet ref="DefiniteArticle"/>
												</PredicateReplacement>
											</Fact>
										</IterateRoles>
									</CompositeList>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
				<!-- Exclusive-Or Constraint (Exclusion 6.1.2)-->
				<!--<ConstrainedRoles columnArity="1">
					
				</ConstrainedRoles>-->
			</Constraint>
			<!-- Start Uniqueness Constraint-->
			<Constraint type="UniquenessConstraint" patternGroup="SetConstraint">
				<!-- Internal constraints -->
				<ConstrainedRoles factCount="1" factArity="1" sign="positive">
					<!-- span='all' is implicit in the other conditions. 0 arity includedRoles is blocked. -->
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="OccursInPopulation">
							<Snippet ref="UniversalQuantifier">
								<IterateRoles match="included" listStyle="SimpleList"/>
							</Snippet>
							<Fact/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1" factArity="1">
					<!-- span="all" sign="negative" is implicit in the other conditions are previous element-->
					<ReadingContext>
						<Snippet ref="ModalPossibilityOperator">
							<Snippet ref="OccursInPopulation">
								<Snippet ref="IdentityReferenceQuantifier">
									<IterateRoles match="included" listStyle="SimpleList" hyphenBind="true"/>
								</Snippet>
								<Fact readingChoice="Context"/>
							</Snippet>
						</Snippet>
					</ReadingContext>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1" span="all" sign="positive">
					<!-- UNDONE: Subscripting requirements specify on for binary, off for n-ary. Currently
						 they are always on. We need to see if there are any verbalizations where subscripts are
						 required in some places but not others before designing the xml and generating from it.
						 If subscripts are required in all places in any verbalization pattern that uses them, then
						 the following would be a potential tag for this location (we'd have subscripts off by default). -->
					<!--<EnableSubscripts minFactArity="3"/>-->
					<Snippet ref="ModalPossibilityOperator">
						<IterateRoles listStyle="TopLevelIndentedLogicalAndList">
							<Fact readingChoice="PreferPrimaryLeadReading">
								<PredicateReplacement match="primary">
									<Snippet ref="MoreThanOneQuantifier"/>
								</PredicateReplacement>
								<PredicateReplacement>
									<Snippet ref="IdentityReferenceQuantifier"/>
								</PredicateReplacement>
							</Fact>
						</IterateRoles>
					</Snippet>
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="OccursInPopulation">
							<Snippet ref="CombinationIdentifier">
								<Snippet ref="UniversalQuantifier">
									<IterateRoles match="included" listStyle="CompactSimpleList"/>
								</Snippet>
							</Snippet>
							<Fact/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1" span="all">
					<!-- sign="negative" is implied by the previous element -->
					<ReadingContext>
						<Snippet ref="ModalPossibilityOperator">
							<Snippet ref="OccursInPopulation">
								<Snippet ref="CombinationIdentifier">
									<Snippet ref="IdentityReferenceQuantifier">
										<IterateRoles match="included" listStyle="CompactSimpleList" hyphenBind="true"/>
									</Snippet>
								</Snippet>
								<Fact readingChoice="Context"/>
							</Snippet>
						</Snippet>
					</ReadingContext>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1" factArity="2" sign="positive">
					<ConditionalReading>
						<ReadingChoice match="RequireLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="OneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles listStyle="SimpleList" match="included" hyphenBind="true"/>
								<Snippet ref="ImpliedModalNecessityOperator">
									<Fact>
										<PredicateReplacement match="included">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="OneQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
					<Snippet ref="ConstraintProvidesPreferredIdentifier" conditionalMatch="IsPreferredIdentifier">
						<IterateRoles listStyle="null" match="included"/>
						<IterateRoles listStyle="null" match="excluded"/>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1" factArity="2">
					<!-- sign="negative" is implied by the previous element -->
					<!-- The pattern is the same whether or not we have a lead reading, so don't use ConditionalReading here -->
					<ReadingContext match="PreferLeadReading">
						<Snippet ref="ForEachCompactQuantifier">
							<IterateRoles match="included" listStyle="CompactSimpleList" hyphenBind="true"/>
							<Snippet ref="ModalPossibilityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="excluded">
										<Snippet ref="OneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</Snippet>
					</ReadingContext>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1" sign="negative">
					<Snippet ref="ModalPossibilityOperator">
						<Fact>
							<PredicateReplacement match="included">
								<Snippet ref="IdentityReferenceQuantifier"/>
							</PredicateReplacement>
							<PredicateReplacement>
								<Snippet ref="MoreThanOneQuantifier"/>
							</PredicateReplacement>
						</Fact>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1">
					<!-- sign="positive" is implied by the previous element -->
					<ReadingContext>
						<Snippet ref="ForEachIndentedQuantifier">
							<IterateRoles match="included" listStyle="SimpleList" hyphenBind="true"/>
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="excluded">
										<Snippet ref="OneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</Snippet>
					</ReadingContext>
				</ConstrainedRoles>

				<!-- External constraints -->
				<!-- Positive Reading -->
				<ConstrainedRoles sign="positive" minFactArity="2" maxFactArity="2">
					<ConditionalReading>
						<ReadingChoice match="RequireAllNonLeadReadingNoFrontText">
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles match="setConstraintRoles" listStyle="SimpleList" hyphenBind="true">
									<ReadingContext match="PreferNonPrimaryLeadReadingNoFrontText"/>
								</IterateRoles>
								<IterateRoles match="setConstraintRoles" listStyle="IndentedList">
									<Fact readingChoice="Context">
										<PredicateReplacement match="excluded" pass="first">
											<Snippet ref="AtMostOneQuantifier" />
										</PredicateReplacement>
										<PredicateReplacement match="excluded">
											<Snippet ref="null" />
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ContextScope">
								<!--Need to add the fact reading in "" after Context: "Room is in Building; Room has RoomNr"-->
								<IterateFacts listStyle="CompoundList"/>
							</Snippet>
							<Snippet ref="ContextScopeReference">
								<Snippet ref="ImpliedModalNecessityOperator">
									<Snippet ref="UniversalQuantifier">
										<Snippet ref="CombinationAssociation">
											<IterateRoles match="setConstraintRoles" listStyle="CompactSimpleList"/>
											<Snippet ref="OneQuantifier">
												<IterateRoles match="setConstraintRoles" pass="first" listStyle="null">
													<IterateContextRoles match="excluded" listStyle="SimpleList"/>
												</IterateRoles>
											</Snippet>
										</Snippet>
									</Snippet>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
				<!-- Negative Reading for External Uniqueness Constraint-->
				<ConstrainedRoles sign="negative" minFactArity="2" maxFactArity="2">
					<ConditionalReading>
						<ReadingChoice match="RequireAllNonLeadReadingNoFrontText">
							<Snippet ref="ModalPossibilityOperator">
								<IterateRoles match="setConstraintRoles" listStyle="SimpleList">
									<Fact readingChoice="Context">
										<PredicateReplacement match="excluded" pass="first">
											<Snippet ref="MoreThanOneQuantifier" />
										</PredicateReplacement>
										<PredicateReplacement match="excluded">
											<Snippet ref="null" />
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="IdentityReferenceQuantifier" />
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ContextScope">
								<!--Need to add the fact reading in "" after Context: "Room is in Building; Room has RoomNr"-->
								<IterateFacts listStyle="CompoundList"/>
							</Snippet>
							<Snippet ref="ContextScopeReference">
								<Snippet ref="ModalPossibilityOperator">
									<Snippet ref="CombinationAssociation">
										<Snippet ref="IdentityReferenceQuantifier">
											<IterateRoles match="setConstraintRoles" listStyle="CompactSimpleList"/>
										</Snippet>
										<Snippet ref="MoreThanOneQuantifier">
											<IterateRoles match="setConstraintRoles" pass="first" listStyle="null">
												<IterateContextRoles match="excluded" listStyle="SimpleList"/>
											</IterateRoles>
										</Snippet>
									</Snippet>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			<!-- End Uniqueness Constraint  -->
			<!-- Begin Role Value Constraint -->
			<Constraint patternGroup="RoleValueConstraint" type="RoleValueConstraint">
				<ConditionalSnippet>
					<!-- Determine whether the range is degenerate. -->
					<Snippet ref="SingleValueValueConstraint" conditionalMatch="IsSingleValue"/>
					<Snippet ref="MultiValueValueConstraint"/>
					<SnippetReplacements>
						<ConditionalReplacement>
							<!-- BinaryWithRoleName matches this pattern: The values of [OpposingRolePlayerName.]roleName[(RolePlayerRefMode)] are value-spec. -->
							<IterateRoles match="included" listStyle="null" conditionalMatch="BinaryWithRoleName">
								<Snippet ref="PeriodSeparator">
									<IterateContextRoles match="excluded" listStyle="null"/>
									<ConditionalReplacement>
										<Snippet ref="ReferenceScheme" conditionalMatch="RolePlayerHasReferenceScheme">
											<RoleName/>
											<RolePlayerReferenceMode/>
										</Snippet>
										<RoleName/>
									</ConditionalReplacement>
								</Snippet>
							</IterateRoles>
							<!-- The fallback pattern is: The values of RolePlayer[sub] in Full Fact Verbalization are value-spec. -->
							<ReadingContext>
								<Snippet ref="InQuantifier">
									<IterateRoles match="included" listStyle="null" hyphenBind="true"/>
									<Fact readingChoice="Context"/>
								</Snippet>
							</ReadingContext>
						</ConditionalReplacement>
						<IterateValueRanges listStyle="CompactSimpleList">
							<ConditionalSnippet>
								<!-- Match one of the nine possible value range patterns.  MinUnboundedMaxUnbounded is not a valid value range pattern. -->
								<Snippet ref="SelfReference" conditionalMatch="MinEqualsMax"/>
								<Snippet ref="MinClosedMaxUnbounded" conditionalMatch="MinClosedMaxUnbounded"/>
								<Snippet ref="MinOpenMaxUnbounded" conditionalMatch="MinOpenMaxUnbounded"/>
								<Snippet ref="MinUnboundedMaxClosed" conditionalMatch="MinUnboundedMaxClosed"/>
								<Snippet ref="MinUnboundedMaxOpen" conditionalMatch="MinUnboundedMaxOpen"/>
								<Snippet ref="MinClosedMaxClosed" conditionalMatch="MinClosedMaxClosed"/>
								<Snippet ref="MinClosedMaxOpen" conditionalMatch="MinClosedMaxOpen"/>
								<Snippet ref="MinOpenMaxClosed" conditionalMatch="MinOpenMaxClosed"/>
								<Snippet ref="MinOpenMaxOpen" conditionalMatch="MinOpenMaxOpen"/>
								<SnippetReplacements>
									<MinValue/>
									<MaxValue/>
								</SnippetReplacements>
							</ConditionalSnippet>
						</IterateValueRanges>
					</SnippetReplacements>
				</ConditionalSnippet>
			</Constraint>
			<!-- End Role Value Constraint-->
			<!-- Begin Value Type Value Constraint -->
			<Constraint patternGroup="ValueTypeValueConstraint" type="ValueTypeValueConstraint">
				<ConditionalSnippet>
					<!-- Determine whether the range is degenerate. -->
					<Snippet ref="SingleValueValueConstraint" conditionalMatch="IsSingleValue"/>
					<Snippet ref="MultiValueValueConstraint"/>
					<SnippetReplacements>
						<Snippet ref="ObjectType">
							<ValueRangeValueTypeName/>
						</Snippet>
						<IterateValueRanges listStyle="CompactSimpleList">
							<ConditionalSnippet>
								<!-- Match one of the nine possible value range patterns.  MinUnboundedMaxUnbounded is not a valid value range pattern. -->
								<Snippet ref="SelfReference" conditionalMatch="MinEqualsMax"/>
								<Snippet ref="MinClosedMaxUnbounded" conditionalMatch="MinClosedMaxUnbounded"/>
								<Snippet ref="MinOpenMaxUnbounded" conditionalMatch="MinOpenMaxUnbounded"/>
								<Snippet ref="MinUnboundedMaxClosed" conditionalMatch="MinUnboundedMaxClosed"/>
								<Snippet ref="MinUnboundedMaxOpen" conditionalMatch="MinUnboundedMaxOpen"/>
								<Snippet ref="MinClosedMaxClosed" conditionalMatch="MinClosedMaxClosed"/>
								<Snippet ref="MinClosedMaxOpen" conditionalMatch="MinClosedMaxOpen"/>
								<Snippet ref="MinOpenMaxClosed" conditionalMatch="MinOpenMaxClosed"/>
								<Snippet ref="MinOpenMaxOpen" conditionalMatch="MinOpenMaxOpen"/>
								<SnippetReplacements>
									<MinValue/>
									<MaxValue/>
								</SnippetReplacements>
							</ConditionalSnippet>
						</IterateValueRanges>
					</SnippetReplacements>
				</ConditionalSnippet>
			</Constraint>
			<Constraint type="RingConstraint" patternGroup="SetConstraint">
				<EnableSubscripts minFactArity="3"/>
				<ConstrainedRoles constraintArity="2" factCount="1" ringType="Irreflexive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<IterateRoles match="included" listStyle="null" pass="first">
							<Fact readingChoice="PreferLeadReading">
								<PredicateReplacement match="primary">
									<Snippet ref="ExistentialQuantifier" reverseSign="true"/>
								</PredicateReplacement>
								<PredicateReplacement match="secondary">
									<Snippet ref="IdentityReferenceQuantifier"/>
								</PredicateReplacement>
							</Fact>
						</IterateRoles>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="SubsetConstraint" patternGroup="SetComparisonConstraint">
				<ConstrainedRoles columnArity="1">
					<ConditionalReading>
						<ReadingChoice match="RequireAllPrimaryLeadReading">
							<Snippet ref="Conditional">
								<IterateSequences match="setConstraintRoles" listStyle="null" pass="first">
									<IterateSequenceFacts listStyle="null">
										<Fact>
											<PredicateReplacement>
												<Snippet ref="ExistentialQuantifier"/>
											</PredicateReplacement>
										</Fact>
									</IterateSequenceFacts>
									<IterateSequenceFacts listStyle="null">
										<Fact>
											<PredicateReplacement>
												<Snippet ref="ExistentialQuantifier"/>
											</PredicateReplacement>
										</Fact>
									</IterateSequenceFacts>
								</IterateSequences>
								<IterateSequences match="setConstraintRoles" listStyle="null" pass="notFirst">
									<IterateSequenceFacts match="setConstraintRoles" listStyle="null">
										<Fact>
											<PredicateReplacement match="included">
												<Snippet ref="DefiniteArticle"/>
											</PredicateReplacement>
											<PredicateReplacement pass="notFirst">
												<Snippet ref="ExistentialQuantifier"/>
											</PredicateReplacement>
										</Fact>
									</IterateSequenceFacts>
								</IterateSequences>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ForEachIndentedQuantifier">
								<IterateSequences listStyle="null" pass="first">
									<IterateSequenceFacts match="included" listStyle="SimpleLogicalAndList">
										<RolePlayer/>
									</IterateSequenceFacts>
								</IterateSequences>
								<Snippet ref="Conditional">
									<IterateSequences match="setConstraintRoles" listStyle="null" pass="first">
										<IterateSequenceFacts match="setConstraintRoles" listStyle="null" pass="first">
											<Fact readingChoice="PreferLeadReading">
												<PredicateReplacement match="included">
													<Snippet ref="DefiniteArticle"/>
												</PredicateReplacement>
												<PredicateReplacement>
													<Snippet ref="ExistentialQuantifier"/>
												</PredicateReplacement>
											</Fact>
										</IterateSequenceFacts>
									</IterateSequences>
									<IterateSequences match="setConstraintRoles" listStyle="null" pass="notFirst">
										<IterateSequenceFacts match="setConstraintRoles" listStyle="null">
											<Fact readingChoice="PreferLeadReading">
												<PredicateReplacement match="included">
													<Snippet ref="DefiniteArticle"/>
												</PredicateReplacement>
												<PredicateReplacement pass="notFirst">
													<Snippet ref="ExistentialQuantifier"/>
												</PredicateReplacement>
											</Fact>
										</IterateSequenceFacts>
									</IterateSequences>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
				<ConstrainedRoles>
					<ConditionalReading>
						<ReadingChoice match="RequireAllPrimaryLeadReading">
							<Snippet ref="Conditional">
								<IterateSequences match="setConstraintRoles" listStyle="null" pass="first">
									<IterateSequenceFacts listStyle="CompoundList">
										<Fact>
											<PredicateReplacement>
												<Snippet ref="ExistentialQuantifier"/>
											</PredicateReplacement>
										</Fact>
									</IterateSequenceFacts>
								</IterateSequences>
								<IterateSequences match="setConstraintRoles" listStyle="null">
									<IterateSequenceFacts listStyle="CompoundList">
										<Fact>
											<PredicateReplacement match="included">
												<Snippet ref="DefiniteArticle"/>
											</PredicateReplacement>
											<PredicateReplacement>
												<Snippet ref="ExistentialQuantifier"/>
											</PredicateReplacement>
										</Fact>
									</IterateSequenceFacts>
								</IterateSequences>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice match="RequireAllNonPrimaryLeadReading">
							<Snippet ref="Conditional">
								<IterateSequences match="setConstraintRoles" listStyle="null" pass="first">
									<IterateSequenceFacts listStyle="CompoundList">
										<Fact>
											<PredicateReplacement>
												<Snippet ref="ExistentialQuantifier"/>
											</PredicateReplacement>
										</Fact>
									</IterateSequenceFacts>
								</IterateSequences>
								<IterateSequences match="setConstraintRoles" listStyle="null">
									<IterateSequenceFacts listStyle="CompoundList">
										<Fact>
											<PredicateReplacement match="included">
												<Snippet ref="DefiniteArticle"/>
											</PredicateReplacement>
											<PredicateReplacement>
												<Snippet ref="ExistentialQuantifier"/>
											</PredicateReplacement>
										</Fact>
									</IterateSequenceFacts>
								</IterateSequences>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="EqualityConstraint" patternGroup="SetComparisonConstraint">
				<ConstrainedRoles columnArity="1" constraintArity="2">
					<Snippet ref="ForEachIndentedQuantifier">
						<IterateSequences listStyle="null" pass="first">
							<IterateSequenceFacts match="included" listStyle="SimpleLogicalAndList">
								<RolePlayer/>
							</IterateSequenceFacts>
						</IterateSequences>
						<Snippet ref="Equality">
							<IterateSequences match="setConstraintRoles" listStyle="null" pass="first">
								<IterateSequenceFacts match="setConstraintRoles" listStyle="null" pass="first">
									<Fact>
										<PredicateReplacement match="included">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</IterateSequenceFacts>
							</IterateSequences>
							<IterateSequences match="setConstraintRoles" listStyle="null" pass="notFirst">
								<IterateSequenceFacts match="setConstraintRoles" listStyle="null">
									<Fact>
										<PredicateReplacement match="included">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement pass="notFirst">
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</IterateSequenceFacts>
							</IterateSequences>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles constraintArity="2">
					<Snippet ref="ForEachIndentedQuantifier">
						<IterateSequences listStyle="null" pass="first">
							<IterateSequenceFacts match="included" listStyle="SimpleLogicalAndList">
								<RolePlayer/>
							</IterateSequenceFacts>
						</IterateSequences>
						<Snippet ref="Equality">
							<IterateSequences match="setConstraintRoles" listStyle="null" pass="first">
								<IterateSequenceFacts match="included" listStyle="null" pass="first">
									<Fact>
										<PredicateReplacement match="included">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</IterateSequenceFacts>
							</IterateSequences>
							<IterateSequences match="setConstraintRoles" listStyle="null" pass="notFirst">
								<IterateSequenceFacts match="included" listStyle="null">
									<Fact>
										<PredicateReplacement match="included">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</IterateSequenceFacts>
							</IterateSequences>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles minConstraintArity="3">
					<Snippet ref="EqualityForEachIndentedQuantifier">
						<IterateSequences listStyle="null" pass="first">
							<IterateSequenceFacts match="included" listStyle="SimpleLogicalAndList">
								<RolePlayer/>
							</IterateSequenceFacts>
						</IterateSequences>
						<IterateSequences match="setConstraintRoles" listStyle="SemiColonList">
							<IterateSequenceFacts match="included" listStyle="null">
								<Fact>
									<PredicateReplacement match="included">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateSequenceFacts>
						</IterateSequences>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<!-- 
				6.1.1: Exclusion constraint but no inclusive-or constraint over the same roles 
				6.1.2: Exclusion plus Inclusive-or constraint over the same roles
			-->
			<Constraint type="ExclusionConstraint" patternGroup="SetComparisonConstraint">
				<ConstrainedRoles columnArity="1" minConstraintArity="2">
					<ConditionalSnippet>
						<Snippet conditionalMatch="ExclusionIsExclusiveOrConstraint" ref="ExclusiveOrForEachIndentedQuantifier"/>
						<Snippet ref="ExclusionForEachIndentedQuantifier"/>
						<SnippetReplacements>
							<IterateSequences listStyle="null" pass="first">
								<IterateSequenceFacts match="included" listStyle="SimpleLogicalAndList">
									<RolePlayer/>
								</IterateSequenceFacts>
							</IterateSequences>
							<IterateSequences match="setConstraintRoles" listStyle="SemiColonList">
								<IterateSequenceFacts match="included" listStyle="null">
									<Fact>
										<PredicateReplacement match="included">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</IterateSequenceFacts>
							</IterateSequences>
						</SnippetReplacements>
					</ConditionalSnippet>
				</ConstrainedRoles>
				<ConstrainedRoles columnArity="2" constraintArity="2">
					<ConditionalSnippet>
						<Snippet conditionalMatch="IsBinaryLeadReading" ref="ExclusionBinaryLeadReading"/>
						<Snippet ref="ExclusionForEachIndentedQuantifier"/>
						<SnippetReplacements>
							<ConditionalReplacement>
								<Snippet ref="ExclusionCombined" conditionalMatch="IsBinaryLeadReading">
									<IterateSequences listStyle="null" pass="first">
										<IterateSequenceFacts listStyle="null" match="included">
											<RolePlayer pass="first"/>
										</IterateSequenceFacts>
									</IterateSequences>
									<IterateSequences listStyle="SimpleLogicalAndList">
										<IterateSequenceFacts match="included" listStyle="null">
											<Fact>
												<PredicateReplacement>
													<Snippet ref="null"/>
												</PredicateReplacement>
											</Fact>
										</IterateSequenceFacts>
									</IterateSequences>
								</Snippet>
								<IterateSequences listStyle="null" pass="first">
									<IterateSequenceFacts listStyle="SimpleLogicalAndList" match="included">
										<RolePlayer/>
									</IterateSequenceFacts>
								</IterateSequences>
							</ConditionalReplacement>
							<ConditionalReplacement>
								<IterateSequences listStyle="null" pass="first" conditionalMatch="IsBinaryLeadReading">
									<IterateSequenceFacts listStyle="null" match="included">
										<RolePlayer pass="notFirst"/>
									</IterateSequenceFacts>
								</IterateSequences>
								<IterateSequences match="setConstraintRoles" listStyle="SemiColonList">
									<IterateSequenceFacts match="included" listStyle="null">
										<Fact>
											<PredicateReplacement match="included">
												<Snippet ref="DefiniteArticle"/>
											</PredicateReplacement>
											<PredicateReplacement>
												<Snippet ref="ExistentialQuantifier"/>
											</PredicateReplacement>
										</Fact>
									</IterateSequenceFacts>
								</IterateSequences>
							</ConditionalReplacement>
						</SnippetReplacements>
					</ConditionalSnippet>
				</ConstrainedRoles>
				<ConstrainedRoles minConstraintArity="2">
					<Snippet ref="ExclusionForEachIndentedQuantifier">
						<IterateSequences listStyle="null" pass="first">
							<IterateSequenceFacts match="included" listStyle="SimpleLogicalAndList">
								<RolePlayer/>
							</IterateSequenceFacts>
						</IterateSequences>
						<IterateSequences match="setConstraintRoles" listStyle="SemiColonList">
							<IterateSequenceFacts match="included" listStyle="null">
								<Fact>
									<PredicateReplacement match="included">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateSequenceFacts>
						</IterateSequences>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
		</Constraints>
		<SampleInstances>
			<SingleSnippet type="FactTypeInstanceBlockStart" childHelperFor="FactType" snippetRef="FactTypeInstanceBlockStart"/>
			<SingleSnippet type="FactTypeInstanceBlockEnd" childHelperFor="FactType" snippetRef="FactTypeInstanceBlockEnd"/>
			<SampleInstance type="FactTypeInstanceVerbalizer" childHelperFor="FactType">
				<Fact>
					<InstanceRoleReplacement/>
				</Fact>
			</SampleInstance>
			<SampleInstance type="ObjectTypeInstanceVerbalizer" childHelperFor="ObjectType">
				<IterateInstances listStyle="ObjectTypeInstanceList">
					<ObjectTypeInstanceValue/>
				</IterateInstances>
			</SampleInstance>
		</SampleInstances>
	</Constructs>
</VerbalizationRoot>
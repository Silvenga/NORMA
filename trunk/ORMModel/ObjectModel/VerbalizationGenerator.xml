<?xml version="1.0" encoding="utf-8" ?>
<Root xmlns="http://Schemas.Neumont.edu/ORM/SDK/Verbalization">
	<Languages>
		<Language code="en-us">
			<FormalItems>
				<FormalItem type="ObjectType">
					<!-- All object type names are wrapped with this style automatically.
						 The objectType class should not be used in other quantifiers because
						 it will interfere with hyphen-binding and possible other features. -->
					<Form style="Basic"><![CDATA[<span class="objectType">{0}</span>]]></Form>
				</FormalItem>
				<FormalItem type="ObjectTypeWithSubscript">
					<Form style="Basic"><![CDATA[<span class="objectType">{0}<sub>{1}</sub></span>]]></Form>
				</FormalItem>
				<FormalItem type="UniversalQuantifier">
					<Form style="Basic"><![CDATA[<span class="quantifier">each</span> {0}]]></Form>
				</FormalItem>
				<FormalItem type="ImpersonalPronoun">
					<Form style="Basic"><![CDATA[<span class="quantifier">that</span> {0}]]></Form>
				</FormalItem>
				<FormalItem type="AtMostOneQuantifier">
					<Form style="Basic"><![CDATA[<span class="quantifier">at most one</span> {0}]]></Form>
				</FormalItem>
				<FormalItem type="EachInstanceQuantifier">
					<Form style="Basic"><![CDATA[<span class="quantifier">each instance of</span> {0} <span class="quantifier">occurs only once</span>]]></Form>
				</FormalItem>
				<FormalItem type="ForEachCompactQuantifier">
					<Form style="Basic"><![CDATA[<span class="quantifier">for each</span> {0}, {1}]]></Form>
				</FormalItem>
				<FormalItem type="ForEachQuantifier">
					<Form style="Basic"><![CDATA[<span class="quantifier">for each</span> {0},<br/><span class="smallIndent">{1}</span>]]></Form>
				</FormalItem>
				<FormalItem type="ExistentialQuantifier">
					<Form style="Basic"><![CDATA[<span class="quantifier">some</span> {0}]]></Form>
					<SplitForm style="Advanced">
						<Form condition="PreConsonant"><![CDATA[<span class="quantifier">a</span> {0}]]></Form>
						<Form condition="PreVowel"><![CDATA[<span class="quantifier">an</span> {0}]]></Form>
					</SplitForm>
				</FormalItem>
				<FormalItem type="IdentityReferenceQuantifier">
					<Form style="Basic"><![CDATA[<span class="quantifier">the same</span> {0}]]></Form>
				</FormalItem>
				<FormalItem type="MoreThanOneQuantifier">
					<Form style="Basic"><![CDATA[<span class="quantifier">more than one</span> {0}]]></Form>
				</FormalItem>
				<FormalItem type="ModalPossibilityOperator" modality="alethic" sign="+">
					<Form style="Basic"><![CDATA[<span class="quantifier">it is possible that</span> {0}]]></Form>
				</FormalItem>
				<FormalItem type="ModalPossibilityOperator" modality="deontic" sign="+">
					<Form style="Basic"><![CDATA[<span class="quantifier">it is permitted that</span> {0}]]></Form>
				</FormalItem>
				<FormalItem type="ModalPossibilityOperator" modality="alethic" sign="-">
					<Form style="Basic"><![CDATA[<span class="quantifier">it is impossible that</span> {0}]]></Form>
				</FormalItem>
				<FormalItem type="ModalPossibilityOperator" modality="deontic" sign="-">
					<Form style="Basic"><![CDATA[<span class="quantifier">it is forbidden that</span> {0}]]></Form>
				</FormalItem>
				<FormalItem type="ModalNecessityOperator" modality="alethic">
					<Form style="Basic"><![CDATA[<span class="quantifier">it is necessary that</span> {0}]]></Form>
				</FormalItem>
				<FormalItem type="ModalNecessityOperator" modality="deontic">
					<Form style="Basic"><![CDATA[<span class="quantifier">it is obligatory that</span> {0}]]></Form>
				</FormalItem>
				<FormalItem type="NegativeReadingForUnaryOnlyDisjunctiveMandatory" sign="-">
					<!-- Used inside a ModalOperator -->
					<Form style="Basic"><![CDATA[<span class="quantifier">some</span> {0} <span class="quantifier">participates in none of the following:</span>{1}]]></Form>
				</FormalItem>
				<FormalItem type="CompoundListOpen">
					<Form style="Basic"><![CDATA[<br/><span class="smallIndent">]]></Form>
				</FormalItem>
				<FormalItem type="CompoundListPairSeparator">
					<Form style="Basic"><![CDATA[<span class="listSeparator">; </span>]]></Form>
				</FormalItem>
				<FormalItem type="CompoundListSeparator">
					<Form style="Basic"><![CDATA[<span class="listSeparator">; </span>]]></Form>
				</FormalItem>
				<FormalItem type="CompoundListFinalSeparator">
					<Form style="Basic"><![CDATA[<span class="listSeparator">; </span>]]></Form>
				</FormalItem>
				<FormalItem type="CompoundListClose">
					<Form style="Basic"></Form>
				</FormalItem>
				<FormalItem type="IndentedListOpen">
					<Form style="Basic"><![CDATA[<br/><span class="smallIndent">]]></Form>
				</FormalItem>
				<FormalItem type="IndentedListPairSeparator">
					<Form style="Basic"><![CDATA[<span class="listSeparator"> and </span><br/>]]></Form>
				</FormalItem>
				<FormalItem type="IndentedListSeparator">
					<Form style="Basic"><![CDATA[<span class="listSeparator"> and </span><br/>]]></Form>
				</FormalItem>
				<FormalItem type="IndentedListFinalSeparator">
					<Form style="Basic"><![CDATA[<span class="listSeparator"> and </span><br/>]]></Form>
				</FormalItem>
				<FormalItem type="IndentedListClose">
					<Form style="Basic"><![CDATA[</span>]]></Form>
				</FormalItem>
				<FormalItem type="IndentedOrListOpen">
					<Form style="Basic"><![CDATA[<br/><span class="smallIndent">]]></Form>
				</FormalItem>
				<FormalItem type="IndentedOrListPairSeparator">
					<Form style="Basic"><![CDATA[<span class="listSeparator"> or </span><br/>]]></Form>
				</FormalItem>
				<FormalItem type="IndentedOrListSeparator">
					<Form style="Basic"><![CDATA[<span class="listSeparator"> or </span><br/>]]></Form>
				</FormalItem>
				<FormalItem type="IndentedOrListFinalSeparator">
					<Form style="Basic"><![CDATA[<span class="listSeparator"> or </span><br/>]]></Form>
				</FormalItem>
				<FormalItem type="IndentedOrListClose">
					<Form style="Basic"><![CDATA[</span>]]></Form>
				</FormalItem>
				<FormalItem type="SimpleListOpen">
					<Form style="Basic"></Form>
				</FormalItem>
				<FormalItem type="SimpleListPairSeparator">
					<Form style="Basic"><![CDATA[<span class="listSeparator"> and </span>]]></Form>
				</FormalItem>
				<FormalItem type="SimpleListSeparator">
					<Form style="Basic"><![CDATA[<span class="listSeparator">, </span>]]></Form>
				</FormalItem>
				<FormalItem type="SimpleListFinalSeparator">
					<Form style="Basic"><![CDATA[<span class="listSeparator">, and </span>]]></Form>
				</FormalItem>
				<FormalItem type="SimpleListClose">
					<Form style="Basic"></Form>
				</FormalItem>
				<FormalItem type="ObjectTypeMissing">
					<Form style="Basic"><![CDATA[<span class="objectTypeMissing">Missing<sub>{0}</sub></span>]]></Form>
				</FormalItem>
				<FormalItem type="CloseVerbalizationSentence">
					<Form style="Basic"><![CDATA[<span class="listSeparator">.</span>]]></Form>
				</FormalItem>
			</FormalItems>
		</Language>
	</Languages>
	<Constructs>
		<!-- Generate FactType verbalization along with constraints -->
		<FactType/>
		<!-- Generate constraint verbalizations -->
		<Constraints>
			<Constraint type="InternalUniquenessConstraint" patternGroup="InternalConstraint">
				<ConstrainedRoles span="all">
					<!-- UNDONE: Subscripting requirements specify on for binary, off for n-ary. Currently
						 they are always on. We need to see if there are any verbalizations where subscripts are
						 required in some places but not others before designing the xml and generating from it.
						 If subscripts are required in all places in any verbalization pattern that uses them, then
						 the following would be a potential tag for this location (we'd have subscripts off by default). -->
					<!--<EnableSubscripts minFactArity="3"/>-->
					<Quantifier type="EachInstanceQuantifier">
						<Fact/>
					</Quantifier>
					<Quantifier type="ModalPossibilityOperator">
						<IterateRoles listStyle="IndentedList">
							<!-- match="included" is not needed here because we've already filtered on span="all" -->
							<Fact readingChoice="PreferPrimaryLeadReading">
								<PredicateReplacement match="primary">
									<Quantifier type="IdentityReferenceQuantifier"/>
								</PredicateReplacement>
								<PredicateReplacement match="secondary">
									<Quantifier type="MoreThanOneQuantifier"/>
								</PredicateReplacement>
							</Fact>
						</IterateRoles>
					</Quantifier>
				</ConstrainedRoles>
				<ConstrainedRoles factArity="2">
					<ConditionalReading>
						<ReadingChoice match="RequireLeadReading">
							<Fact readingChoice="Conditional">
								<PredicateReplacement match="included">
									<Quantifier type="UniversalQuantifier"/>
								</PredicateReplacement>
								<PredicateReplacement>
									<Quantifier type="AtMostOneQuantifier"/>
								</PredicateReplacement>
							</Fact>
						</ReadingChoice>
						<ReadingChoice>
							<Quantifier type="ForEachCompactQuantifier">
								<IterateRoles listStyle="SimpleList" match="included"/>
								<Fact>
									<PredicateReplacement match="included">
										<Quantifier type="ImpersonalPronoun"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Quantifier type="AtMostOneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Quantifier>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
				<ConstrainedRoles>
					<ConditionalReading>
						<ReadingChoice match="RequireLeadReading">
							<Quantifier type="ForEachQuantifier">
								<IterateRoles listStyle="SimpleList" match="included"/>
								<Fact readingChoice="Conditional">
									<PredicateReplacement match="included">
										<Quantifier type="ImpersonalPronoun"/>
									</PredicateReplacement>
									<!-- match="excluded" is not needed here because it
										 is implied by the previous replacement.-->
									<PredicateReplacement>
										<Quantifier type="AtMostOneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Quantifier>
						</ReadingChoice>
						<ReadingChoice>
							<!-- Fallback choice -->
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>

			<!-- Simple Mandatory Constraint -->
			<Constraint type="SimpleMandatoryConstraint" patternGroup="InternalConstraint">

				<!-- 3.1.1 unary predicate -->
				<!-- Each A R -->
				<ConstrainedRoles factArity="1">
					<Quantifier type="UniversalQuantifier">
						<Fact/>
					</Quantifier>
				</ConstrainedRoles>


				<!-- 3.1.2 binary predicate -->
				<ConstrainedRoles factArity="2">
					<ConditionalReading>

						<!-- mandatory constraint starts reading relational style -->
						<!-- Each A R some B -->
						<ReadingChoice match="RequireLeadReading">
							<Fact readingChoice="Conditional">
								<PredicateReplacement match="included">
									<Quantifier type="UniversalQuantifier"/>
								</PredicateReplacement>
								<PredicateReplacement>
									<Quantifier type="ExistentialQuantifier"/>
								</PredicateReplacement>
							</Fact>
						</ReadingChoice>

						<!-- mandatory role does NOT start reading -->
						<!-- For each A, some B S that A -->
						<ReadingChoice>
							<Quantifier type="ForEachCompactQuantifier">
								<Fact>
									<PredicateReplacement match="excluded">
										<Quantifier type="ExistentialQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Quantifier type="ImpersonalPronoun"/>
									</PredicateReplacement>
								</Fact>
							</Quantifier>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>

				<!-- mandatory constraint starts reading attribute style -->
				<!-- Each A R some B -->
				<!-- not doing this time around -->

				<!-- 3.1.3 n-ary predicate -->
				<ConstrainedRoles>
					<ConditionalReading>
						<!-- mandatory role starts reading -->
						<!-- Each A R some B1 ... some Bn -->
						<ReadingChoice match="RequireLeadReading">
							<Fact readingChoice="Conditional">
								<PredicateReplacement match="included">
									<Quantifier type="UniversalQuantifier"/>
								</PredicateReplacement>
								<PredicateReplacement>
									<Quantifier type="ExistentialQuantifier"/>
								</PredicateReplacement>
							</Fact>
						</ReadingChoice>

						<!-- mandatory role does NOT start reading-->
						<!-- For each A,
							some B1 R ... that A ... some Bn -->
						<ReadingChoice>
							<Quantifier type="ForEachQuantifier">
								<IterateRoles listStyle="SimpleList"/>
								<Fact readingChoice="Conditional">
									<PredicateReplacement match="included">
										<Quantifier type="ImpersonalPronoun"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Quantifier type="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Quantifier>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>

			<!-- UNDONE: The data from here down is preliminary, but is being used for generation testing -->
			<Constraint type="DisjunctiveMandatoryConstraint" patternGroup="SingleColumnExternalConstraint">
				<!-- Unaries are the only reading choice that has an optional negative reading -->
				<ConstrainedRoles sign="-" maxFactArity="1">
					<Quantifier type="ModalPossibilityOperator">
						<Quantifier type="NegativeReadingForUnaryOnlyDisjunctiveMandatory">
							<IterateRoles listStyle="SimpleList" match="singleColumnConstraintRoles" pass="first"/>
							<IterateRoles listStyle="CompoundList" match="singleColumnConstraintRoles">
								<Fact/>
							</IterateRoles>
						</Quantifier>
					</Quantifier>
				</ConstrainedRoles>
				<ConstrainedRoles sign="+" maxFactArity="2">
					<ConditionalReading>
						<ReadingChoice match="RequireAllLeadReadingNoForwardText">
							<CompositeList listStyle="IndentedOrList">
								<IterateRoles minFactArity="2" match="singleColumnConstraintRoles">
									<Fact readingChoice="Conditional">
										<PredicateReplacement match="primary" pass="first">
											<Quantifier type="UniversalQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement match="primary">
											<Quantifier type="null"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Quantifier type="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
								<IterateRoles factArity="1" match="singleColumnConstraintRoles">
									<Fact readingChoice="Conditional">
										<PredicateReplacement>
											<Quantifier type="ImpersonalPronoun"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</CompositeList>
						</ReadingChoice>
						<!--<ReadingChoice>
							<Quantifier type="ForEachQuantifier">
								<IterateRoles minFactArity="2" match="singleColumnConstraintRoles">
									<Fact readingChoice="PreferPrimaryLeadReading">
										<PredicateReplacement match="primary">
											<Quantifier type="ImpersonalQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement match="primary">
											<Quantifier type="ExistentialQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement match="secondary">
											<Quantifier type="ExistentialQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement match="secondary">
											<Quantifier type="ImpersonalQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
								<IterateRoles factArity="1" match="singleColumnConstraintRoles">
									<Fact/>
								</IterateRoles>
							</Quantifier>
						</ReadingChoice>-->
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			<!-- Start External Uniqueness Constraint-->
			<Constraint type="ExternalUniquenessConstraint" patternGroup="SingleColumnExternalConstraint">
				<!-- Positive Reading -->
				<ConstrainedRoles sign="+" minFactArity="2" maxFactArity="2">
					<ConditionalReading>
						<ReadingChoice match="RequireAllNonLeadReadingNoForwardText">
							<Quantifier type="ForEachCompactQuantifier">
								<IterateRoles match="singleColumnConstraintRoles" listStyle="SimpleList" />
								<IterateRoles match="singleColumnConstraintRoles" listStyle="IndentedList">
									<Fact readingChoice="Conditional">
										<PredicateReplacement match="excluded" pass="first">
											<Quantifier type="AtMostOneQuantifier" />
										</PredicateReplacement>
										<PredicateReplacement match="excluded">
											<Quantifier type="null" />
										</PredicateReplacement>
										<PredicateReplacement>
											<Quantifier type="ImpersonalPronoun" />
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</Quantifier>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
				<!-- Negative Reading for External Uniqueness Constraint-->
				<ConstrainedRoles sign="-" minFactArity="2" maxFactArity="2">
					<ConditionalReading>
						<ReadingChoice match="RequireAllNonLeadReadingNoForwardText">
							<Quantifier type="ModalPossibilityOperator">
								<IterateRoles match="singleColumnConstraintRoles" listStyle="SimpleList">
									<Fact readingChoice="Conditional">
										<PredicateReplacement match="excluded" pass="first">
											<Quantifier type="MoreThanOneQuantifier" />
										</PredicateReplacement>
										<PredicateReplacement match="excluded">
											<Quantifier type="null" />
										</PredicateReplacement>
										<PredicateReplacement>
											<Quantifier type="IdentityReferenceQuantifier" />
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</Quantifier>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			- --><!-- End External Uniqueness Constraint  -->
		</Constraints>
	</Constructs>
</Root>

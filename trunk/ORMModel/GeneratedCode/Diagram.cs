#region Common Public License Copyright Notice
/**************************************************************************\
* Neumont Object-Role Modeling Architect for Visual Studio                 *
*                                                                          *
* Copyright © Neumont University. All rights reserved.                     *
*                                                                          *
* The use and distribution terms for this software are covered by the      *
* Common Public License 1.0 (http://opensource.org/licenses/cpl) which     *
* can be found in the file CPL.txt at the root of this distribution.       *
* By using this software in any fashion, you are agreeing to be bound by   *
* the terms of this license.                                               *
*                                                                          *
* You must not remove this notice, or any other, from this software.       *
\**************************************************************************/
#endregion
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DslModeling = Microsoft.VisualStudio.Modeling;
using DslDesign = Microsoft.VisualStudio.Modeling.Design;
using DslDiagrams = Microsoft.VisualStudio.Modeling.Diagrams;

namespace Neumont.Tools.ORM.ShapeModel
{
	/// <summary>
	/// Double-derived base class for DomainClass ORMDiagram
	/// </summary>
	[global::System.ComponentModel.TypeDescriptionProvider(typeof(global::Neumont.Tools.Modeling.Diagrams.Design.PresentationElementTypeDescriptionProvider<ORMDiagram, global::Neumont.Tools.ORM.ObjectModel.ORMModel, global::Neumont.Tools.Modeling.Diagrams.Design.DiagramTypeDescriptor<ORMDiagram, global::Neumont.Tools.ORM.ObjectModel.ORMModel>>))]
	[DslDesign::DisplayNameResource("Neumont.Tools.ORM.ShapeModel.ORMDiagram.DisplayName", typeof(global::Neumont.Tools.ORM.ShapeModel.ORMShapeModel), "Neumont.Tools.ORM.GeneratedCode.ShapeDomainModelResx")]
	[DslDesign::DescriptionResource("Neumont.Tools.ORM.ShapeModel.ORMDiagram.Description", typeof(global::Neumont.Tools.ORM.ShapeModel.ORMShapeModel), "Neumont.Tools.ORM.GeneratedCode.ShapeDomainModelResx")]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("948f992d-c9b8-46f9-be3c-b48347f8ab0b")]
	public abstract partial class ORMDiagramBase : DslDiagrams::Diagram
	{
		#region Diagram boilerplate
		private static DslDiagrams::StyleSet classStyleSet;
		private static global::System.Collections.Generic.IList<DslDiagrams::ShapeField> shapeFields;
		/// <summary>
		/// Per-class style set for this shape.
		/// </summary>
		protected override DslDiagrams::StyleSet ClassStyleSet
		{
			get
			{
				if (classStyleSet == null)
				{
					classStyleSet = CreateClassStyleSet();
				}
				return classStyleSet;
			}
		}
		
		/// <summary>
		/// Per-class ShapeFields for this shape
		/// </summary>
		public override global::System.Collections.Generic.IList<DslDiagrams::ShapeField> ShapeFields
		{
			get
			{
				if (shapeFields == null)
				{
					shapeFields = CreateShapeFields();
				}
				return shapeFields;
			}
		}
		#endregion
		#region Toolbox filters
		private static global::System.ComponentModel.ToolboxItemFilterAttribute[] toolboxFilters = new global::System.ComponentModel.ToolboxItemFilterAttribute[] {
					new global::System.ComponentModel.ToolboxItemFilterAttribute(global::Neumont.Tools.ORM.ShapeModel.ORMShapeModelToolboxHelperBase.ToolboxFilterString, global::System.ComponentModel.ToolboxItemFilterType.Require) };
		
		/// <summary>
		/// Toolbox item filter attributes for this diagram.
		/// </summary>
		public override global::System.Collections.ICollection TargetToolboxItemFilterAttributes
		{
			get
			{
				return toolboxFilters;
			}
		}
		#endregion
		#region Auto-placement
		/// <summary>
		/// Indicate that child shapes should added through view fixup should be placed automatically.
		/// </summary>
		public override bool ShouldAutoPlaceChildShapes
		{
			get
			{
				return true;
			}
		}
		#endregion
		#region Shape mapping
		/// <summary>
		/// Called during view fixup to ask the parent whether a shape should be created for the given child element.
		/// </summary>
		/// <remarks>
		/// Always return true, since we assume there is only one diagram per model file for DSL scenarios.
		/// </remarks>
		protected override bool ShouldAddShapeForElement(DslModeling::ModelElement element)
		{
			return true;
		}
		
		/// <summary>
		/// Called during view fixup to configure the given child element, after it has been created.
		/// </summary>
		/// <remarks>
		/// Custom code for choosing the shapes attached to either end of a connector is called from here.
		/// </remarks>
		protected override void OnChildConfiguring(DslDiagrams::ShapeElement child)
		{
			DslDiagrams::NodeShape sourceShape = null;
			DslDiagrams::NodeShape targetShape = null;
			DslDiagrams::BinaryLinkShape connector = child as DslDiagrams::BinaryLinkShape;
			if(connector == null)
			{
				base.OnChildConfiguring(child);
				return;
			}
			
			if (sourceShape == null || targetShape == null)
			{
				DslDiagrams::NodeShape[] endShapes = GetEndShapesForConnector(connector);
				if(sourceShape == null)
				{
					sourceShape = endShapes[0];
				}
				if(targetShape == null)
				{
					targetShape = endShapes[1];
				}
			}
			
			global::System.Diagnostics.Debug.Assert(sourceShape != null && targetShape != null, "Unable to find source and target shapes for connector.");
			connector.Connect(sourceShape, targetShape);
		}
		
		/// <summary>
		/// Helper method to find shapes for either end of a connector by looking for shapes associated with either end of the relationship mapped to the connector.
		/// </summary>
		private DslDiagrams::NodeShape[] GetEndShapesForConnector(DslDiagrams::BinaryLinkShape connector)
		{
			DslModeling::ElementLink link = connector.ModelElement as DslModeling::ElementLink;
			DslDiagrams::NodeShape sourceShape = null, targetShape = null;
			if (link != null)
			{
				global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::ModelElement> linkedElements = link.LinkedElements;
				if (linkedElements.Count == 2)
				{
					DslDiagrams::Diagram currentDiagram = this.Diagram;
					DslModeling::LinkedElementCollection<DslDiagrams::PresentationElement> presentationElements = DslDiagrams::PresentationViewsSubject.GetPresentation(linkedElements[0]);
					foreach (DslDiagrams::PresentationElement presentationElement in presentationElements)
					{
						DslDiagrams::NodeShape shape = presentationElement as DslDiagrams::NodeShape;
						if (shape != null && shape.Diagram == currentDiagram)
						{
							sourceShape = shape;
							break;
						}
					}
					
					presentationElements = DslDiagrams::PresentationViewsSubject.GetPresentation(linkedElements[1]);
					foreach (DslDiagrams::PresentationElement presentationElement in presentationElements)
					{
						DslDiagrams::NodeShape shape = presentationElement as DslDiagrams::NodeShape;
						if (shape != null && shape.Diagram == currentDiagram)
						{
							targetShape = shape;
							break;
						}
					}
		
				}
			}
			
			return new DslDiagrams::NodeShape[] { sourceShape, targetShape };
		}
		
		/// <summary>
		/// Creates a new shape for the given model element as part of view fixup
		/// </summary>
		protected override DslDiagrams::ShapeElement CreateChildShape(DslModeling::ModelElement element)
		{
			if(element is global::Neumont.Tools.ORM.ObjectModel.ModelNote)
			{
				return new global::Neumont.Tools.ORM.ShapeModel.ModelNoteShape(this.Partition);
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.ObjectTypePlaysRole)
			{
				return new global::Neumont.Tools.ORM.ShapeModel.RolePlayerLink(this.Partition);
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.ReadingOrder)
			{
				return new global::Neumont.Tools.ORM.ShapeModel.ReadingShape(this.Partition);
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.Role)
			{
				return new global::Neumont.Tools.ORM.ShapeModel.RoleNameShape(this.Partition);
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.ModelNoteReferencesFactType)
			{
				return new global::Neumont.Tools.ORM.ShapeModel.ModelNoteLink(this.Partition);
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.ModelNoteReferencesObjectType)
			{
				return new global::Neumont.Tools.ORM.ShapeModel.ModelNoteLink(this.Partition);
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.FactConstraint)
			{
				return new global::Neumont.Tools.ORM.ShapeModel.ExternalConstraintLink(this.Partition);
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.RoleHasValueConstraint)
			{
				return new global::Neumont.Tools.ORM.ShapeModel.ValueRangeLink(this.Partition);
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.ValueTypeValueConstraint)
			{
				return new global::Neumont.Tools.ORM.ShapeModel.ValueConstraintShape(this.Partition);
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.SubtypeFact)
			{
				return new global::Neumont.Tools.ORM.ShapeModel.SubtypeLink(this.Partition);
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.FactType)
			{
				return new global::Neumont.Tools.ORM.ShapeModel.FactTypeShape(this.Partition);
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.FrequencyConstraint)
			{
				return new global::Neumont.Tools.ORM.ShapeModel.FrequencyConstraintShape(this.Partition);
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.ObjectType)
			{
				// Multiple mappings have been defined for the class ObjectType.
				// Either implement a method as described below, or remove the multiple mappings from the DSL definition.
				//
				// Method:
				// private DslDiagrams::ShapeElement CreateShapeForObjectType(ObjectType newElement)
				// {
				// }
				// must be implemented in a partial class of ORMDiagramBase.  Given an instance of ObjectType,
				// the method should return a new shape or connector instance that should be associated with this element.  If no shape or connector should be created, the method should return null.
				return CreateShapeForObjectType((global::Neumont.Tools.ORM.ObjectModel.ObjectType)element);
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.RingConstraint)
			{
				return new global::Neumont.Tools.ORM.ShapeModel.RingConstraintShape(this.Partition);
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.RoleValueConstraint)
			{
				return new global::Neumont.Tools.ORM.ShapeModel.ValueConstraintShape(this.Partition);
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.SetConstraint)
			{
				return new global::Neumont.Tools.ORM.ShapeModel.ExternalConstraintShape(this.Partition);
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.SetComparisonConstraint)
			{
				return new global::Neumont.Tools.ORM.ShapeModel.ExternalConstraintShape(this.Partition);
			}
			return base.CreateChildShape(element);
		}
		#endregion
		#region Decorator mapping
		/// <summary>
		/// Initialize shape decorator mappings.  This is done here rather than in individual shapes because decorator maps
		/// are defined per diagram type rather than per shape type.
		/// </summary>
		protected override void InitializeShapeFields(global::System.Collections.Generic.IList<DslDiagrams::ShapeField> shapeFields)
		{
			base.InitializeShapeFields(shapeFields);
		}
		
		#endregion
		#region Constructors, domain class Id
	
		/// <summary>
		/// ORMDiagram domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x948f992d, 0xc9b8, 0x46f9, 0xbe, 0x3c, 0xb4, 0x83, 0x47, 0xf8, 0xab, 0x0b);
		// Constructors were not generated for this class because it had HasCustomConstructor
		// set to true. Please provide the constructors below in a partial class.
		///// <summary>
		///// Constructor.
		///// </summary>
		///// <param name="partition">Partition where new element is to be created.</param>
		///// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		//protected ORMDiagramBase(DslModeling::Partition partition, DslModeling::PropertyAssignment[] propertyAssignments)
		//	: base(partition, propertyAssignments)
		//{
		//}
		#endregion
		#region AutoPopulateShapes domain property code
		
		/// <summary>
		/// AutoPopulateShapes domain property Id.
		/// </summary>
		public static readonly global::System.Guid AutoPopulateShapesDomainPropertyId = new global::System.Guid(0xd3f7a171, 0xce39, 0x4944, 0xbe, 0x80, 0xd5, 0x51, 0x27, 0x42, 0x3c, 0x83);
		
		/// <summary>
		/// Storage for AutoPopulateShapes
		/// </summary>
		private global::System.Boolean autoPopulateShapesPropertyStorage;
		
		/// <summary>
		/// Gets or sets the value of AutoPopulateShapes domain property.
		/// Description for Neumont.Tools.ORM.ShapeModel.ORMDiagram.Auto Populate Shapes
		/// </summary>
		[DslDesign::DisplayNameResource("Neumont.Tools.ORM.ShapeModel.ORMDiagram/AutoPopulateShapes.DisplayName", typeof(global::Neumont.Tools.ORM.ShapeModel.ORMShapeModel), "Neumont.Tools.ORM.GeneratedCode.ShapeDomainModelResx")]
		[DslDesign::DescriptionResource("Neumont.Tools.ORM.ShapeModel.ORMDiagram/AutoPopulateShapes.Description", typeof(global::Neumont.Tools.ORM.ShapeModel.ORMShapeModel), "Neumont.Tools.ORM.GeneratedCode.ShapeDomainModelResx")]
		[global::System.ComponentModel.Browsable(false)]
		[DslModeling::DomainObjectId("d3f7a171-ce39-4944-be80-d55127423c83")]
		public global::System.Boolean AutoPopulateShapes
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return autoPopulateShapesPropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				AutoPopulateShapesPropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the ORMDiagram.AutoPopulateShapes domain property.
		/// </summary>
		internal sealed partial class AutoPopulateShapesPropertyHandler : DslModeling::DomainPropertyValueHandler<ORMDiagramBase, global::System.Boolean>
		{
			private AutoPopulateShapesPropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the ORMDiagram.AutoPopulateShapes domain property value handler.
			/// </summary>
			public static readonly AutoPopulateShapesPropertyHandler Instance = new AutoPopulateShapesPropertyHandler();
		
			/// <summary>
			/// Gets the Id of the ORMDiagram.AutoPopulateShapes domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return AutoPopulateShapesDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.Boolean GetValue(ORMDiagramBase element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.autoPopulateShapesPropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(ORMDiagramBase element, global::System.Boolean newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.Boolean oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.autoPopulateShapesPropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
			private new void ValueChanged(ORMDiagramBase element, global::System.Boolean oldValue, global::System.Boolean newValue)
			{
				// UNDONE: MSBUG The base crashes if a property is changed in the same transaction
				// as the element being deleted. The internal setValueMode is Resurrect during
				// an undo/redo
				if (element.Store.TransactionManager.InTransaction)
				{
					base.ValueChanged(element, oldValue, newValue);
				}
				else
				{
					this.OnValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
	}
	/// <summary>
	/// DomainClass ORMDiagram
	/// Description for Neumont.Tools.ORM.ShapeModel.ORMDiagram
	/// </summary>
	[global::System.CLSCompliant(true)]
			
	public partial class ORMDiagram : ORMDiagramBase
	{
		#region Constructors
		// Constructors were not generated for this class because it had HasCustomConstructor
		// set to true. Please provide the constructors below in a partial class.
		///// <summary>
		///// Constructor
		///// </summary>
		///// <param name="store">Store where new element is to be created.</param>
		///// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		//public ORMDiagram(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
		//	: this(store != null ? store.DefaultPartition : null, propertyAssignments)
		//{
		//}
		//
		///// <summary>
		///// Constructor
		///// </summary>
		///// <param name="partition">Partition where new element is to be created.</param>
		///// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		//public ORMDiagram(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
		//	: base(partition, propertyAssignments)
		//{
		//}
		#endregion
	}
}

namespace Neumont.Tools.ORM.ShapeModel
{
	/// <summary>
	/// Rule that initiates view fixup when an element that has an associated shape is added to the model. 
	/// </summary>
	[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.ModelNote), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeRulePriority, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.ObjectTypePlaysRole), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddConnectionRulePriority, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.ReadingOrder), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeRulePriority, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.Role), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeRulePriority, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.ModelNoteReferencesFactType), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddConnectionRulePriority, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.ModelNoteReferencesObjectType), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddConnectionRulePriority, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.FactConstraint), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddConnectionRulePriority, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.RoleHasValueConstraint), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddConnectionRulePriority, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.ValueTypeValueConstraint), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeRulePriority, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.SubtypeFact), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeRulePriority, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.FactType), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeRulePriority, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.FrequencyConstraint), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeRulePriority, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.ObjectType), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeRulePriority, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.RingConstraint), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeRulePriority, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.RoleValueConstraint), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeRulePriority, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.SetConstraint), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeRulePriority, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.SetComparisonConstraint), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeRulePriority, InitiallyDisabled=true)]
	internal sealed partial class FixUpDiagram : DslModeling::AddRule
	{
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
		public override void ElementAdded(DslModeling::ElementAddedEventArgs e)
		{
			if(e == null) throw new global::System.ArgumentNullException("e");
		
			DslModeling::ModelElement childElement = e.ModelElement;
			DslModeling::ModelElement parentElement;
			if(childElement is DslModeling::ElementLink)
			{
				parentElement = GetParentForRelationship((DslModeling::ElementLink)childElement);
			} else
			if(childElement is global::Neumont.Tools.ORM.ObjectModel.ModelNote)
			{
				parentElement = GetParentForModelNote((global::Neumont.Tools.ORM.ObjectModel.ModelNote)e.ModelElement);
			} else
			if(childElement is global::Neumont.Tools.ORM.ObjectModel.ReadingOrder)
			{
				parentElement = GetParentForReadingOrder((global::Neumont.Tools.ORM.ObjectModel.ReadingOrder)e.ModelElement);
			} else
			if(childElement is global::Neumont.Tools.ORM.ObjectModel.Role)
			{
				parentElement = GetParentForRole((global::Neumont.Tools.ORM.ObjectModel.Role)e.ModelElement);
			} else
			if(childElement is global::Neumont.Tools.ORM.ObjectModel.ValueTypeValueConstraint)
			{
				parentElement = GetParentForValueTypeValueConstraint((global::Neumont.Tools.ORM.ObjectModel.ValueTypeValueConstraint)e.ModelElement);
			} else
			if(childElement is global::Neumont.Tools.ORM.ObjectModel.SubtypeFact)
			{
				parentElement = GetParentForSubtypeFact((global::Neumont.Tools.ORM.ObjectModel.SubtypeFact)e.ModelElement);
			} else
			if(childElement is global::Neumont.Tools.ORM.ObjectModel.FactType)
			{
				parentElement = GetParentForFactType((global::Neumont.Tools.ORM.ObjectModel.FactType)e.ModelElement);
			} else
			if(childElement is global::Neumont.Tools.ORM.ObjectModel.FrequencyConstraint)
			{
				parentElement = GetParentForFrequencyConstraint((global::Neumont.Tools.ORM.ObjectModel.FrequencyConstraint)e.ModelElement);
			} else
			if(childElement is global::Neumont.Tools.ORM.ObjectModel.ObjectType)
			{
				parentElement = GetParentForObjectType((global::Neumont.Tools.ORM.ObjectModel.ObjectType)e.ModelElement);
			} else
			if(childElement is global::Neumont.Tools.ORM.ObjectModel.RingConstraint)
			{
				parentElement = GetParentForRingConstraint((global::Neumont.Tools.ORM.ObjectModel.RingConstraint)e.ModelElement);
			} else
			if(childElement is global::Neumont.Tools.ORM.ObjectModel.RoleValueConstraint)
			{
				parentElement = GetParentForRoleValueConstraint((global::Neumont.Tools.ORM.ObjectModel.RoleValueConstraint)e.ModelElement);
			} else
			if(childElement is global::Neumont.Tools.ORM.ObjectModel.SetConstraint)
			{
				parentElement = GetParentForSetConstraint((global::Neumont.Tools.ORM.ObjectModel.SetConstraint)e.ModelElement);
			} else
			if(childElement is global::Neumont.Tools.ORM.ObjectModel.SetComparisonConstraint)
			{
				parentElement = GetParentForSetComparisonConstraint((global::Neumont.Tools.ORM.ObjectModel.SetComparisonConstraint)e.ModelElement);
			} else
			{
				parentElement = null;
			}
			
			if(parentElement != null)
			{
				DslDiagrams::Diagram.FixUpDiagram(parentElement, childElement);
			}
		}
		public static global::Neumont.Tools.ORM.ObjectModel.ORMModel GetParentForObjectType( global::Neumont.Tools.ORM.ObjectModel.ObjectType root )
		{
			// Segments 0 and 1
			global::Neumont.Tools.ORM.ObjectModel.ORMModel result = root.Model;
			if ( result == null ) return null;
			return result;
		}
		public static global::Neumont.Tools.ORM.ObjectModel.ORMModel GetParentForFactType( global::Neumont.Tools.ORM.ObjectModel.FactType root )
		{
			// Segments 0 and 1
			global::Neumont.Tools.ORM.ObjectModel.ORMModel result = root.Model;
			if ( result == null ) return null;
			return result;
		}
		public static global::Neumont.Tools.ORM.ObjectModel.ORMModel GetParentForSubtypeFact( global::Neumont.Tools.ORM.ObjectModel.FactType root )
		{
			// Segments 0 and 1
			global::Neumont.Tools.ORM.ObjectModel.ORMModel result = root.Model;
			if ( result == null ) return null;
			return result;
		}
		public static global::Neumont.Tools.ORM.ObjectModel.ORMModel GetParentForSetComparisonConstraint( global::Neumont.Tools.ORM.ObjectModel.SetComparisonConstraint root )
		{
			// Segments 0 and 1
			global::Neumont.Tools.ORM.ObjectModel.ORMModel result = root.Model;
			if ( result == null ) return null;
			return result;
		}
		public static global::Neumont.Tools.ORM.ObjectModel.ORMModel GetParentForSetConstraint( global::Neumont.Tools.ORM.ObjectModel.SetConstraint root )
		{
			// Segments 0 and 1
			global::Neumont.Tools.ORM.ObjectModel.ORMModel result = root.Model;
			if ( result == null ) return null;
			return result;
		}
		public static global::Neumont.Tools.ORM.ObjectModel.ORMModel GetParentForFrequencyConstraint( global::Neumont.Tools.ORM.ObjectModel.SetConstraint root )
		{
			// Segments 0 and 1
			global::Neumont.Tools.ORM.ObjectModel.ORMModel result = root.Model;
			if ( result == null ) return null;
			return result;
		}
		public static global::Neumont.Tools.ORM.ObjectModel.ORMModel GetParentForRingConstraint( global::Neumont.Tools.ORM.ObjectModel.SetConstraint root )
		{
			// Segments 0 and 1
			global::Neumont.Tools.ORM.ObjectModel.ORMModel result = root.Model;
			if ( result == null ) return null;
			return result;
		}
		public static global::Neumont.Tools.ORM.ObjectModel.ORMModel GetParentForRoleValueConstraint( global::Neumont.Tools.ORM.ObjectModel.RoleValueConstraint root )
		{
			// Segments 0 and 1
			global::Neumont.Tools.ORM.ObjectModel.RoleBase root2 = root.Role as global::Neumont.Tools.ORM.ObjectModel.RoleBase;
			if ( root2 == null ) return null;
			// Segments 2 and 3
			global::Neumont.Tools.ORM.ObjectModel.FactType root4 = root2.FactType;
			if ( root4 == null ) return null;
			// Segments 4 and 5
			global::Neumont.Tools.ORM.ObjectModel.ORMModel result = root4.Model;
			if ( result == null ) return null;
			return result;
		}
		public static global::Neumont.Tools.ORM.ObjectModel.ORMModel GetParentForValueTypeValueConstraint( global::Neumont.Tools.ORM.ObjectModel.ValueTypeValueConstraint root )
		{
			// Segments 0 and 1
			global::Neumont.Tools.ORM.ObjectModel.ObjectType root2 = root.ValueType;
			if ( root2 == null ) return null;
			// Segments 2 and 3
			global::Neumont.Tools.ORM.ObjectModel.ORMModel result = root2.Model;
			if ( result == null ) return null;
			return result;
		}
		public static global::Neumont.Tools.ORM.ObjectModel.ORMModel GetParentForReadingOrder( global::Neumont.Tools.ORM.ObjectModel.ReadingOrder root )
		{
			// Segments 0 and 1
			global::Neumont.Tools.ORM.ObjectModel.FactType root2 = root.FactType;
			if ( root2 == null ) return null;
			// Segments 2 and 3
			global::Neumont.Tools.ORM.ObjectModel.ORMModel result = root2.Model;
			if ( result == null ) return null;
			return result;
		}
		public static global::Neumont.Tools.ORM.ObjectModel.ORMModel GetParentForRole( global::Neumont.Tools.ORM.ObjectModel.RoleBase root )
		{
			// Segments 0 and 1
			global::Neumont.Tools.ORM.ObjectModel.FactType root2 = root.FactType;
			if ( root2 == null ) return null;
			// Segments 2 and 3
			global::Neumont.Tools.ORM.ObjectModel.ORMModel result = root2.Model;
			if ( result == null ) return null;
			return result;
		}
		public static global::Neumont.Tools.ORM.ObjectModel.ORMModel GetParentForModelNote( global::Neumont.Tools.ORM.ObjectModel.ModelNote root )
		{
			// Segments 0 and 1
			global::Neumont.Tools.ORM.ObjectModel.ORMModel result = root.Model;
			if ( result == null ) return null;
			return result;
		}
		private static DslModeling::ModelElement GetParentForRelationship(DslModeling::ElementLink elementLink)
		{
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::ModelElement> linkedElements = elementLink.LinkedElements;

			if (linkedElements.Count == 2)
			{
				DslModeling::ModelElement sourceParent = DslModeling::DomainClassInfo.FindEmbeddingElement(linkedElements[0]);
				DslModeling::ModelElement targetParent = DslModeling::DomainClassInfo.FindEmbeddingElement(linkedElements[1]);

				while (sourceParent != targetParent && sourceParent != null)
				{
					DslModeling::ModelElement curParent = targetParent;
					while (sourceParent != curParent && curParent != null)
					{
						curParent = DslModeling::DomainClassInfo.FindEmbeddingElement(curParent);
					}

					if(sourceParent == curParent)
					{
						break;
					}
					else
					{
						sourceParent = DslModeling::DomainClassInfo.FindEmbeddingElement(sourceParent);
					}
				}

				bool foundParent = false;
				while (sourceParent != null)
				{
					// ensure that the parent is or has an associated pel that can parent connectors (i.e., the diagram or a swimlane).
					if(sourceParent is DslDiagrams::Diagram || sourceParent is DslDiagrams::SwimlaneShape)
					{
						foundParent = true;
						break;
					}
					else
					{
						DslModeling::LinkedElementCollection<DslDiagrams::PresentationElement> presentationElements = DslDiagrams::PresentationViewsSubject.GetPresentation(sourceParent);
						foreach (DslDiagrams::PresentationElement presentationElement in presentationElements)
						{
							if (presentationElement is DslDiagrams::Diagram || presentationElement is DslDiagrams::SwimlaneShape)
							{
								foundParent = true;
								break;
							}
						}
					}

					if (foundParent)
					{
						break;
					}
					else
					{
						sourceParent = DslModeling::DomainClassInfo.FindEmbeddingElement(sourceParent);
					}
				}

				global::System.Diagnostics.Debug.Assert(sourceParent != null, "unable to find common parent for view fixup.");
				return sourceParent;
			}

			return null;
		}
	}
	

	/// <summary>
	/// Reroute a connector when the role players of its underlying relationship change
	/// </summary>
	[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.ObjectTypePlaysRole), FireTime = DslModeling::TimeToFire.TopLevelCommit, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.FactConstraint), FireTime = DslModeling::TimeToFire.TopLevelCommit, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.RoleHasValueConstraint), FireTime = DslModeling::TimeToFire.TopLevelCommit, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.ModelNoteReferencesFactType), FireTime = DslModeling::TimeToFire.TopLevelCommit, InitiallyDisabled=true)]
	[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.ModelNoteReferencesObjectType), FireTime = DslModeling::TimeToFire.TopLevelCommit, InitiallyDisabled=true)]
	internal sealed class ConnectorRolePlayerChanged : DslModeling::RolePlayerChangeRule
	{
		/// <summary>
		/// Reroute a connector when the role players of its underlying relationship change
		/// </summary>
		public override void RolePlayerChanged(DslModeling::RolePlayerChangedEventArgs e)
		{
			if (e == null) throw new global::System.ArgumentNullException("e");

			bool fixupFirstRolePlayer = e.DomainRelationship.DomainRoles[0] == e.DomainRole;
	
			global::System.Collections.ObjectModel.ReadOnlyCollection<DslDiagrams::PresentationViewsSubject> connectorLinks = DslDiagrams::PresentationViewsSubject.GetLinksToPresentation(e.ElementLink);
			foreach (DslDiagrams::PresentationViewsSubject connectorLink in connectorLinks)
			{
				// Fix up any binary link shapes attached to the element link.
				DslDiagrams::BinaryLinkShape linkShape = connectorLink.Presentation as DslDiagrams::BinaryLinkShape;
				if (linkShape != null)
				{
					if(e.NewRolePlayer != null)
					{	
						if (fixupFirstRolePlayer)
						{
							// Loop through shapes mapped to new role player, find the first one with a matching diagram to the link, and reroute.
							DslDiagrams::NodeShape fromShape = null;
							global::System.Collections.ObjectModel.ReadOnlyCollection<DslDiagrams::PresentationViewsSubject> shapeLinks = DslDiagrams::PresentationViewsSubject.GetLinksToPresentation(e.NewRolePlayer);
							foreach (DslDiagrams::PresentationViewsSubject shapeLink in shapeLinks)
							{
								DslDiagrams::NodeShape shape = shapeLink.Presentation as DslDiagrams::NodeShape;
								if (shape.Diagram == linkShape.Diagram)
								{
									fromShape = shape;
									break;
								}
							}
							linkShape.FromShape = fromShape;
						}
						else
						{
							// Loop through shapes mapped to new role player, find the first one with a matching diagram to the link, and reroute.
							DslDiagrams::NodeShape toShape = null;
							global::System.Collections.ObjectModel.ReadOnlyCollection<DslDiagrams::PresentationViewsSubject> links = DslDiagrams::PresentationViewsSubject.GetLinksToPresentation(e.NewRolePlayer);
							foreach (DslDiagrams::PresentationViewsSubject shapeLink in links)
							{
								DslDiagrams::NodeShape shape = shapeLink.Presentation as DslDiagrams::NodeShape;
								if (shape.Diagram == linkShape.Diagram)
								{
									toShape = shape;
									break;
								}
							}
							linkShape.ToShape = toShape;
						}
					}
					else
					{
						// delete the connector if the new role player is null.
						linkShape.Delete();
					}
				}
			}
		}
	}
}

<?xml version="1.0" encoding="UTF-8" ?>
<xsl:stylesheet version="1.0" 
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:oil="http://schemas.orm.net/OIAL" 
	xmlns:ormdt="http://schemas.orm.net/ORMDataTypes"
	xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#"
	xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
	xmlns:owl="http://www.w3.org/2002/07/owl#"
	xmlns:exsl="http://exslt.org/common"
	extension-element-prefixes="exsl">

	<xsl:output indent="yes" method="xml" omit-xml-declaration="yes"/>

	<xsl:template match="/">
		<xsl:apply-templates/>
	</xsl:template>
	<xsl:template match="oil:model">
		<xsl:comment>This Owl Schema was generated by the ORM2 Tool</xsl:comment>
		<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:rdfs="http://www.w3.org/2000/01/rdf-schema#" xmlns:owl="http://www.w3.org/2002/07/owl#" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns="This needs to be done">
			
			<xsl:comment>OWL Universe of Discourse for <xsl:value-of select="@name"/></xsl:comment>
			
			<xsl:variable name="InformationTypeFormatMappingsFragment">
				<xsl:apply-templates select="oil:informationTypeFormats/child::*" mode="GenerateMapping"/>
			</xsl:variable>
			<xsl:variable name="InformationTypeFormatMappings" select="exsl:node-set($InformationTypeFormatMappingsFragment)/child::*"/>
			<xsl:variable name="ConceptTypes" select="//oil:conceptType"/>
			<xsl:comment>Each ORM EntityType maps to an owl:Class</xsl:comment>
			<xsl:apply-templates select="$ConceptTypes"/>
			<xsl:comment>Each ORM ValueType maps to an owl:DatatypeProperty</xsl:comment>
			<xsl:apply-templates select="oil:informationTypeFormats/child::*" mode="GenerateSimpleType"/>
			<xsl:comment>Relationships between ORM EntityTypes map to an owl:ObjectProperty</xsl:comment>
			<xsl:for-each select="oil:conceptType">
				<xsl:call-template name="GenerateRelationshipObjectProperties">
					<xsl:with-param name="ConceptType" select="."/>
				</xsl:call-template>
			</xsl:for-each>
		</rdf:RDF>
	</xsl:template>

	<xsl:template name="GenerateRelationshipObjectProperties">
		<xsl:param name="ConceptType"/>
		<xsl:for-each select="$ConceptType/oil:conceptType">
			<owl:ObjectProperty rdf:ID="">
				<rdfs:domain rdf:resource="#{$ConceptType/@name}"/>
					<rdfs:range rdf:resource="#{@name}"/>
			</owl:ObjectProperty>
			<owl:ObjectProperty rdf:ID="">
				<rdfs:inverseOf rdf:resource="#"/>
			</owl:ObjectProperty>
		</xsl:for-each>
		<xsl:for-each select="$ConceptType/oil:conceptTypeRef">
			<owl:ObjectProperty rdf:ID="{@name}">
				<rdfs:domain rdf:resource="#{$ConceptType/@name}"/>
				<rdfs:range rdf:resource="#{@target}"/>
			</owl:ObjectProperty>
			<owl:ObjectProperty rdf:ID="{@oppositeName}">
				<rdfs:inverseOf rdf:resource="#{@name}"/>
			</owl:ObjectProperty>
		</xsl:for-each>
		<xsl:if test=".">
			
		</xsl:if>
		
	</xsl:template>
	
	<xsl:template match="ormdt:identity" mode="GenerateMapping">
		<FormatMapping name="{@name}" target="xs:integer"/>
	</xsl:template>
	<xsl:template match="ormdt:boolean" mode="GenerateMapping">
		<FormatMapping name="{@name}">
			<xsl:attribute name="target">
				<xsl:choose>
					<xsl:when test="@fixed='true'">
						<xsl:value-of select="'oxs:true'"/>
					</xsl:when>
					<xsl:when test="@fixed='false'">
						<xsl:value-of select="'oxs:false'"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="'xs:boolean'"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:attribute>
		</FormatMapping>
	</xsl:template>
	<xsl:template match="ormdt:decimalNumber" mode="GenerateMapping">
		<FormatMapping name="{@name}">
			<xsl:attribute name="target">
				<xsl:choose>
					<!-- TODO: Optimize this so that we map to smaller integer types when possible. -->
					<xsl:when test="ormdt:enumeration or ormdt:range or @totalDigits or not(@fractionDigits=0)">
						<xsl:value-of select="concat('oxs:', @name)"/>
					</xsl:when>
					<xsl:when test="@fractionDigits = 0">
						<xsl:value-of select="'xs:integer'"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="'xs:decimal'"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:attribute>
		</FormatMapping>
	</xsl:template>
	<xsl:template match="ormdt:floatingPointNumber" mode="GenerateMapping">
		<FormatMapping name="{@name}">
			<xsl:attribute name="target">
				<xsl:choose>
					<xsl:when test="child::*">
						<xsl:value-of select="concat('oxs:', @name)"/>
					</xsl:when>
					<xsl:when test="@precision &lt; 25 or @precision='single'">
						<xsl:value-of select="'xs:float'"/>
					</xsl:when>
					<xsl:when test="@precision &lt; 54 or @precision='double'">
						<xsl:value-of select="'xs:double'"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:message terminate="yes">
							<xsl:text>Sorry, XML Schema doesn't support floating point data types above double-precision.</xsl:text>
						</xsl:message>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:attribute>
		</FormatMapping>
	</xsl:template>
	<xsl:template match="ormdt:string" mode="GenerateMapping">
		<FormatMapping name="{@name}">
			<xsl:attribute name="target">
				<xsl:choose>
					<xsl:when test="@minLength or @maxLength or child::*">
						<xsl:value-of select="concat('oxs:', @name)"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="'xs:string'"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:attribute>
		</FormatMapping>
	</xsl:template>
	<xsl:template match="ormdt:binary" mode="GenerateMapping">
		<FormatMapping name="{@name}">
			<xsl:attribute name="target">
				<xsl:choose>
					<xsl:when test="@minLength or @maxLength">
						<xsl:value-of select="concat('oxs:', @name)"/>
					</xsl:when>
					<xsl:otherwise>
						<xsl:value-of select="'xs:hexBinary'"/>
					</xsl:otherwise>
				</xsl:choose>
			</xsl:attribute>
		</FormatMapping>
	</xsl:template>

	<xsl:template match="oil:informationTypeFormats/child::*" mode="GenerateSimpleType">
		<!-- informationTypeFormats that don't have a one-to-one mapping to predefined data types are made into xs:simpleTypes -->
		<owl:DatatypeProperty rdf:ID="{@name}">
			<xsl:apply-templates select="." mode="GenerateDatatypePropertyRefs">
				<xsl:with-param name="resourceName" select="//oil:conceptType[oil:informationType/@formatRef=current()/@name]/@name"/>
			</xsl:apply-templates>
		</owl:DatatypeProperty>
	</xsl:template>

	<xsl:template match="ormdt:identity" mode="GenerateDatatypePropertyRefs">
		<!-- Need to decide how we cater for a Value Type that is absorbed by more than one entity type.-->
		<xsl:param name="resourceName"/>
		<rdfs:domain rdf:resource="#{$resourceName}"/>

		<rdfs:range>
			<xsl:choose>
				<xsl:when test="child::*">
					<!--TODO: -->
				</xsl:when>
				<xsl:otherwise>
					<xsl:attribute name="rdf:resource">
						<xsl:text>xs:integer</xsl:text>
					</xsl:attribute>
				</xsl:otherwise>
			</xsl:choose>
		</rdfs:range>
	</xsl:template>
	<xsl:template match="ormdt:floatingPointNumber" mode="GenerateDatatypePropertyRefs">
		<xsl:param name="resourceName"/>
		<rdfs:domain rdf:resource="#"/>
		<rdfs:range >
			<xsl:choose>
				<xsl:when test="child::*">
					<!--TODO: -->
				</xsl:when>
				<xsl:otherwise>
					<xsl:attribute name="rdf:resource">
						<xsl:text>xs:float</xsl:text>
					</xsl:attribute>
				</xsl:otherwise>
			</xsl:choose>
		</rdfs:range>
	</xsl:template>
	<xsl:template match="ormdt:binary" mode="GenerateDatatypePropertyRefs">
		<xsl:param name="resourceName"/>	
		<rdfs:domain rdf:resource="#{$resourceName}"/>
		<rdfs:range >
			<xsl:choose>
				<xsl:when test="child::*">
					<!--TODO: -->
				</xsl:when>
				<xsl:otherwise>
					<xsl:attribute name="rdf:resource">
						<xsl:text>xs:hexBinary</xsl:text>
					</xsl:attribute>
				</xsl:otherwise>
			</xsl:choose>
		</rdfs:range>
	</xsl:template>
	<xsl:template match="ormdt:string" mode="GenerateDatatypePropertyRefs">
		<xsl:param name="resourceName"/>
		<rdfs:domain rdf:resource="#{$resourceName}"/>
		<rdfs:range>
			<xsl:choose>
				<xsl:when test="ormdt:enumeration">
					<owl:DataRange>
						<owl:oneOf>
							<xsl:call-template name="GenerateEnumeration">
								<xsl:with-param name="enum" select="ormdt:enumeration[1]"/>
							</xsl:call-template>
						</owl:oneOf>
					</owl:DataRange>
				</xsl:when>
				<xsl:otherwise>
					<xsl:attribute name="rdf:resource">
						<xsl:text>xs:string</xsl:text>
					</xsl:attribute>
				</xsl:otherwise>
			</xsl:choose>
			<xsl:if test="@minLength">
				
			</xsl:if>
			<xsl:if test="@maxLength">
				
			</xsl:if>
		</rdfs:range>
	</xsl:template>
	<xsl:template name="GenerateEnumeration">
		<xsl:param name="enum"/>
		<rdf:List>
			<rdf:first rdf:dataType="xs:string">
				<xsl:value-of select="$enum/@value"/>
			</rdf:first>
			<rdf:rest>
				<xsl:choose>
					<xsl:when test="$enum/following-sibling::*">
						<xsl:call-template name="GenerateEnumeration">
							<xsl:with-param name="enum" select="$enum/following-sibling::*[1]"/>
						</xsl:call-template>
					</xsl:when>
					<xsl:otherwise>
						<xsl:attribute name="rdf:resource">
							<!--TODO: allow rdf: to be expressed as predefined entitiy '&rdf;'-->
							<xsl:text>rdf:nil</xsl:text>
						</xsl:attribute>
					</xsl:otherwise>
				</xsl:choose>
			</rdf:rest>
		</rdf:List>
	</xsl:template>
	<xsl:template match="ormdt:boolean" mode="GenerateDatatypePropertyRefs">
		<xsl:param name="resourceName"/>
		<rdfs:domain rdf:resource="#{$resourceName}"/>
		<rdfs:range >
			<xsl:choose>
				<xsl:when test="child::*">
					<!--TODO: -->
				</xsl:when>
				<xsl:otherwise>
					<xsl:attribute name="rdf:resource">
						<xsl:text>xs:boolean</xsl:text>
					</xsl:attribute>
				</xsl:otherwise>
			</xsl:choose>
		</rdfs:range>
	</xsl:template>
	<xsl:template match="ormdt:decimalNumber" mode="GenerateDatatypePropertyRefs">
		<xsl:param name="resourceName"/>
		<rdfs:domain rdf:resource="#{$resourceName}"/>
		<rdfs:range>
			<xsl:choose>
				<xsl:when test="child::*">
					<!--TODO: -->
				</xsl:when>
				<xsl:otherwise>
					<xsl:attribute name="rdf:resource">
						<xsl:text>xs:decimalNumber</xsl:text>
					</xsl:attribute>
				</xsl:otherwise>
			</xsl:choose>
		</rdfs:range>
	</xsl:template>

	<xsl:template match="oil:conceptType">
		<owl:Class rdf:ID="{@name}">
			<xsl:comment>Preferred Id</xsl:comment>
			<rdfs:subClassOf>
				<xsl:choose>
					<xsl:when test="oil:informationType/oil:singleRoleUniquenessConstraint[@isPreferred='true']">
						<xsl:variable name="preferredId" select="oil:informationType[oil:singleRoleUniquenessConstraint/@isPreferred='true']/@name"/>

						<owl:Restriction>
							<owl:onProperty rdf:resource="#{$preferredId}"/>
							<owl:cardinality rdf:datatype="xs:nonNegativeInteger">1</owl:cardinality>
						</owl:Restriction>
					</xsl:when>
					<xsl:when test="oil:roleSequenceUniquenessConstraint/@isPreferred='true'">
						<owl:unionOf rdf:parseType="Collection">
							<xsl:for-each select="oil:roleSequenceUniquenessConstraint[@isPreferred='true']/oil:roleSequence/oil:typeRef">
								<owl:Restriction>
									<owl:onProperty rdf:resource="#{@targetChild}" />
									<owl:cardinality rdf:datatype="xs:nonNegativeInteger">1</owl:cardinality>
								</owl:Restriction>
							</xsl:for-each>
						</owl:unionOf>
					</xsl:when>
				</xsl:choose>
				<xsl:apply-templates select="oil:informationType" mode="GenerateFunctionalConstraintOnInformationType"/>
			</rdfs:subClassOf>
		</owl:Class>
		<!--What is the full qualification here? Can a subtype have -->
		<xsl:call-template name="CreateSubtypes"/>
	</xsl:template>
	<xsl:template match="oil:informationType" mode="GenerateFunctionalConstraintOnInformationType">
		<owl:Restriction>
			<owl:onProperty rdf:resource="#{@formatRef}" />
			<xsl:choose>
				<xsl:when test="@mandatory='alethic'">
					<owl:cardinality rdf:datatype="xs:nonNegativeInteger">1</owl:cardinality>
				</xsl:when>
				<xsl:when test="@mandatory='false'">
					<owl:minCardinality rdf:datatype="xs:nonNegativeInteger">1</owl:minCardinality >
				</xsl:when>
				<xsl:when test="@mandatory='deontic'">
					<xsl:comment>Deontic</xsl:comment>
					<owl:cardinality rdf:datatype="xs:nonNegativeInteger">1</owl:cardinality >
				</xsl:when>
			</xsl:choose>
		</owl:Restriction>
	</xsl:template>
	<xsl:template name="CreateSubtypes">

	</xsl:template>
</xsl:stylesheet>
#region Common Public License Copyright Notice
/**************************************************************************\
* Neumont Object-Role Modeling Architect for Visual Studio                 *
*                                                                          *
* Copyright © Neumont University. All rights reserved.                     *
*                                                                          *
* The use and distribution terms for this software are covered by the      *
* Common Public License 1.0 (http://opensource.org/licenses/cpl) which     *
* can be found in the file CPL.txt at the root of this distribution.       *
* By using this software in any fashion, you are agreeing to be bound by   *
* the terms of this license.                                               *
*                                                                          *
* You must not remove this notice, or any other, from this software.       *
\**************************************************************************/
#endregion
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DslModeling = global::Microsoft.VisualStudio.Modeling;
using DslDesign = global::Microsoft.VisualStudio.Modeling.Design;
using DslDiagrams = global::Microsoft.VisualStudio.Modeling.Diagrams;

namespace Neumont.Tools.ORM.ShapeModel
{
	/// <summary>
	/// Double-derived base class for DomainClass ORMDiagram
	/// </summary>
	[global::System.ComponentModel.TypeDescriptionProvider(typeof(global::Neumont.Tools.Modeling.Diagrams.Design.PresentationElementTypeDescriptionProvider<ORMDiagram, global::Neumont.Tools.ORM.ObjectModel.ORMModel, global::Neumont.Tools.Modeling.Diagrams.Design.DiagramTypeDescriptor<ORMDiagram, global::Neumont.Tools.ORM.ObjectModel.ORMModel>>))]
	[DslDesign::DisplayNameResource("Neumont.Tools.ORM.ShapeModel.ORMDiagram.DisplayName", typeof(global::Neumont.Tools.ORM.ShapeModel.ORMShapeDomainModel), "Neumont.Tools.ORM.GeneratedCode.ShapeDomainModelResx")]
	[DslDesign::DescriptionResource("Neumont.Tools.ORM.ShapeModel.ORMDiagram.Description", typeof(global::Neumont.Tools.ORM.ShapeModel.ORMShapeDomainModel), "Neumont.Tools.ORM.GeneratedCode.ShapeDomainModelResx")]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("948f992d-c9b8-46f9-be3c-b48347f8ab0b")]
	public abstract partial class ORMDiagramBase : DslDiagrams::Diagram
	{
		#region Diagram boilerplate
		private static DslDiagrams::StyleSet classStyleSet;
		private static global::System.Collections.Generic.IList<DslDiagrams::ShapeField> shapeFields;
		/// <summary>
		/// Per-class style set for this shape.
		/// </summary>
		protected override DslDiagrams::StyleSet ClassStyleSet
		{
			get
			{
				if (classStyleSet == null)
				{
					classStyleSet = CreateClassStyleSet();
				}
				return classStyleSet;
			}
		}
		
		/// <summary>
		/// Per-class ShapeFields for this shape
		/// </summary>
		public override global::System.Collections.Generic.IList<DslDiagrams::ShapeField> ShapeFields
		{
			get
			{
				if (shapeFields == null)
				{
					shapeFields = CreateShapeFields();
				}
				return shapeFields;
			}
		}
		#endregion
		#region Toolbox filters
		private static global::System.ComponentModel.ToolboxItemFilterAttribute[] toolboxFilters = new global::System.ComponentModel.ToolboxItemFilterAttribute[] {
					new global::System.ComponentModel.ToolboxItemFilterAttribute(global::Neumont.Tools.ORM.ShapeModel.ORMShapeToolboxHelperBase.ToolboxFilterString, global::System.ComponentModel.ToolboxItemFilterType.Require) };
		
		/// <summary>
		/// Toolbox item filter attributes for this diagram.
		/// </summary>
		public override global::System.Collections.ICollection TargetToolboxItemFilterAttributes
		{
			get
			{
				return toolboxFilters;
			}
		}
		#endregion
		#region Auto-placement
		/// <summary>
		/// Indicate that child shapes should added through view fixup should be placed automatically.
		/// </summary>
		public override bool ShouldAutoPlaceChildShapes
		{
			get
			{
				return true;
			}
		}
		#endregion
		#region Shape mapping
		/// <summary>
		/// Called during view fixup to ask the parent whether a shape should be created for the given child element.
		/// </summary>
		/// <remarks>
		/// Always return true, since we assume there is only one diagram per model file for DSL scenarios.
		/// </remarks>
		protected override bool ShouldAddShapeForElement(DslModeling::ModelElement element)
		{
			return true;
		}
		
		/// <summary>
		/// Called during view fixup to configure the given child element, after it has been created.
		/// </summary>
		/// <remarks>
		/// Custom code for choosing the shapes attached to either end of a connector is called from here.
		/// </remarks>
		protected override void OnChildConfiguring(DslDiagrams::ShapeElement child, bool createdDuringViewFixup)
		{
			DslDiagrams::NodeShape sourceShape;
			DslDiagrams::NodeShape targetShape;
			DslDiagrams::BinaryLinkShape connector = child as DslDiagrams::BinaryLinkShape;
			if(connector == null)
			{
				base.OnChildConfiguring(child, createdDuringViewFixup);
				return;
			}
			this.GetSourceAndTargetForConnector(connector, out sourceShape, out targetShape);
			
			global::System.Diagnostics.Debug.Assert(sourceShape != null && targetShape != null, "Unable to find source and target shapes for connector.");
			connector.Connect(sourceShape, targetShape);
		}
		
		/// <summary>
		/// helper method to find the shapes for either end of a connector, including calling the user's custom code
		/// </summary>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
		internal void GetSourceAndTargetForConnector(DslDiagrams::BinaryLinkShape connector, out DslDiagrams::NodeShape sourceShape, out DslDiagrams::NodeShape targetShape)
		{
			sourceShape = null;
			targetShape = null;
			
			if (sourceShape == null || targetShape == null)
			{
				DslDiagrams::NodeShape[] endShapes = GetEndShapesForConnector(connector);
				if(sourceShape == null)
				{
					sourceShape = endShapes[0];
				}
				if(targetShape == null)
				{
					targetShape = endShapes[1];
				}
			}
		}
		
		/// <summary>
		/// Helper method to find shapes for either end of a connector by looking for shapes associated with either end of the relationship mapped to the connector.
		/// </summary>
		private DslDiagrams::NodeShape[] GetEndShapesForConnector(DslDiagrams::BinaryLinkShape connector)
		{
			DslModeling::ElementLink link = connector.ModelElement as DslModeling::ElementLink;
			DslDiagrams::NodeShape sourceShape = null, targetShape = null;
			if (link != null)
			{
				global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::ModelElement> linkedElements = link.LinkedElements;
				if (linkedElements.Count == 2)
				{
					DslDiagrams::Diagram currentDiagram = this.Diagram;
					DslModeling::LinkedElementCollection<DslDiagrams::PresentationElement> presentationElements = DslDiagrams::PresentationViewsSubject.GetPresentation(linkedElements[0]);
					foreach (DslDiagrams::PresentationElement presentationElement in presentationElements)
					{
						DslDiagrams::NodeShape shape = presentationElement as DslDiagrams::NodeShape;
						if (shape != null && shape.Diagram == currentDiagram)
						{
							sourceShape = shape;
							break;
						}
					}
					
					presentationElements = DslDiagrams::PresentationViewsSubject.GetPresentation(linkedElements[1]);
					foreach (DslDiagrams::PresentationElement presentationElement in presentationElements)
					{
						DslDiagrams::NodeShape shape = presentationElement as DslDiagrams::NodeShape;
						if (shape != null && shape.Diagram == currentDiagram)
						{
							targetShape = shape;
							break;
						}
					}
		
				}
			}
			
			return new DslDiagrams::NodeShape[] { sourceShape, targetShape };
		}
		
		/// <summary>
		/// Most connectors are mapped to element links, but there can be exceptions. This method tell if a connector should be
		/// mapped to an element link.
		/// </summary>
		public override bool IsConnectorMappedToLink(DslDiagrams::BinaryLinkShape connector)
		{
			#region Check Parameters
			global::System.Diagnostics.Debug.Assert(connector != null);
			if (connector == null)
				throw new global::System.ArgumentNullException("connector");
			#endregion
			if (connector is global::Neumont.Tools.ORM.ShapeModel.ORMBaseBinaryLinkShape)
				return false;
			return base.IsConnectorMappedToLink(connector);
		}
		
		/// <summary>
		/// Creates a new shape for the given model element as part of view fixup
		/// </summary>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily", Justification = "Generated code.")]
		protected override DslDiagrams::ShapeElement CreateChildShape(DslModeling::ModelElement element)
		{
			if(element is global::Neumont.Tools.ORM.ObjectModel.RingConstraint)
			{
				global::Neumont.Tools.ORM.ShapeModel.RingConstraintShape newShape = new global::Neumont.Tools.ORM.ShapeModel.RingConstraintShape(this.Partition);
				if(newShape != null) newShape.Size = newShape.DefaultSize; // set default shape size
				return newShape;
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.FrequencyConstraint)
			{
				global::Neumont.Tools.ORM.ShapeModel.FrequencyConstraintShape newShape = new global::Neumont.Tools.ORM.ShapeModel.FrequencyConstraintShape(this.Partition);
				if(newShape != null) newShape.Size = newShape.DefaultSize; // set default shape size
				return newShape;
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.ValueTypeValueConstraint)
			{
				global::Neumont.Tools.ORM.ShapeModel.ValueConstraintShape newShape = new global::Neumont.Tools.ORM.ShapeModel.ValueConstraintShape(this.Partition);
				if(newShape != null) newShape.Size = newShape.DefaultSize; // set default shape size
				return newShape;
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.RoleValueConstraint)
			{
				global::Neumont.Tools.ORM.ShapeModel.ValueConstraintShape newShape = new global::Neumont.Tools.ORM.ShapeModel.ValueConstraintShape(this.Partition);
				if(newShape != null) newShape.Size = newShape.DefaultSize; // set default shape size
				return newShape;
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.SetConstraint)
			{
				global::Neumont.Tools.ORM.ShapeModel.ExternalConstraintShape newShape = new global::Neumont.Tools.ORM.ShapeModel.ExternalConstraintShape(this.Partition);
				if(newShape != null) newShape.Size = newShape.DefaultSize; // set default shape size
				return newShape;
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.SubtypeFact)
			{
				global::Neumont.Tools.ORM.ShapeModel.SubtypeLink newShape = new global::Neumont.Tools.ORM.ShapeModel.SubtypeLink(this.Partition);
				if(newShape != null) newShape.Size = newShape.DefaultSize; // set default shape size
				return newShape;
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.SetComparisonConstraint)
			{
				global::Neumont.Tools.ORM.ShapeModel.ExternalConstraintShape newShape = new global::Neumont.Tools.ORM.ShapeModel.ExternalConstraintShape(this.Partition);
				if(newShape != null) newShape.Size = newShape.DefaultSize; // set default shape size
				return newShape;
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.ModelNote)
			{
				global::Neumont.Tools.ORM.ShapeModel.ModelNoteShape newShape = new global::Neumont.Tools.ORM.ShapeModel.ModelNoteShape(this.Partition);
				if(newShape != null) newShape.Size = newShape.DefaultSize; // set default shape size
				return newShape;
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.ObjectType)
			{
				// Multiple mappings have been defined for the class ObjectType.
				// Either implement a method as described below, or remove the multiple mappings from the DSL definition.
				//
				// Method:
				// private DslDiagrams::NodeShape CreateShapeForObjectType(ObjectType newElement)
				// {
				// }
				// must be implemented in a partial class of ORMDiagramBase.  Given an instance of ObjectType,
				// the method should return a new shape or connector instance that should be associated with this element.  If no shape or connector should be created, the method should return null.
				DslDiagrams::NodeShape newShape = CreateShapeForObjectType((global::Neumont.Tools.ORM.ObjectModel.ObjectType)element);
				if(newShape != null) newShape.Size = newShape.DefaultSize; // set default shape size
				return newShape;
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.Role)
			{
				global::Neumont.Tools.ORM.ShapeModel.RoleNameShape newShape = new global::Neumont.Tools.ORM.ShapeModel.RoleNameShape(this.Partition);
				if(newShape != null) newShape.Size = newShape.DefaultSize; // set default shape size
				return newShape;
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.ReadingOrder)
			{
				global::Neumont.Tools.ORM.ShapeModel.ReadingShape newShape = new global::Neumont.Tools.ORM.ShapeModel.ReadingShape(this.Partition);
				if(newShape != null) newShape.Size = newShape.DefaultSize; // set default shape size
				return newShape;
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.FactType)
			{
				global::Neumont.Tools.ORM.ShapeModel.FactTypeShape newShape = new global::Neumont.Tools.ORM.ShapeModel.FactTypeShape(this.Partition);
				if(newShape != null) newShape.Size = newShape.DefaultSize; // set default shape size
				return newShape;
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.ModelNoteReferencesObjectType)
			{
				global::Neumont.Tools.ORM.ShapeModel.ModelNoteLink newShape = new global::Neumont.Tools.ORM.ShapeModel.ModelNoteLink(this.Partition);
				return newShape;
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.ModelNoteReferencesFactType)
			{
				global::Neumont.Tools.ORM.ShapeModel.ModelNoteLink newShape = new global::Neumont.Tools.ORM.ShapeModel.ModelNoteLink(this.Partition);
				return newShape;
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.RoleHasValueConstraint)
			{
				global::Neumont.Tools.ORM.ShapeModel.ValueRangeLink newShape = new global::Neumont.Tools.ORM.ShapeModel.ValueRangeLink(this.Partition);
				return newShape;
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.FactConstraint)
			{
				global::Neumont.Tools.ORM.ShapeModel.ExternalConstraintLink newShape = new global::Neumont.Tools.ORM.ShapeModel.ExternalConstraintLink(this.Partition);
				return newShape;
			}
			if(element is global::Neumont.Tools.ORM.ObjectModel.ObjectTypePlaysRole)
			{
				global::Neumont.Tools.ORM.ShapeModel.RolePlayerLink newShape = new global::Neumont.Tools.ORM.ShapeModel.RolePlayerLink(this.Partition);
				return newShape;
			}
			return base.CreateChildShape(element);
		}
		#endregion
		#region Decorator mapping
		/// <summary>
		/// Initialize shape decorator mappings.  This is done here rather than in individual shapes because decorator maps
		/// are defined per diagram type rather than per shape type.
		/// </summary>
		protected override void InitializeShapeFields(global::System.Collections.Generic.IList<DslDiagrams::ShapeField> shapeFields)
		{
			base.InitializeShapeFields(shapeFields);
		}
		
		#endregion
		#region Constructors, domain class Id
	
		/// <summary>
		/// ORMDiagram domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x948f992d, 0xc9b8, 0x46f9, 0xbe, 0x3c, 0xb4, 0x83, 0x47, 0xf8, 0xab, 0x0b);
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		protected ORMDiagramBase(DslModeling::Partition partition, DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region AutoPopulateShapes domain property code
		
		/// <summary>
		/// AutoPopulateShapes domain property Id.
		/// </summary>
		public static readonly global::System.Guid AutoPopulateShapesDomainPropertyId = new global::System.Guid(0xd3f7a171, 0xce39, 0x4944, 0xbe, 0x80, 0xd5, 0x51, 0x27, 0x42, 0x3c, 0x83);
		
		/// <summary>
		/// Storage for AutoPopulateShapes
		/// </summary>
		private global::System.Boolean autoPopulateShapesPropertyStorage;
		
		/// <summary>
		/// Gets or sets the value of AutoPopulateShapes domain property.
		/// Description for Neumont.Tools.ORM.ShapeModel.ORMDiagram.Auto Populate Shapes
		/// </summary>
		[DslDesign::DisplayNameResource("Neumont.Tools.ORM.ShapeModel.ORMDiagram/AutoPopulateShapes.DisplayName", typeof(global::Neumont.Tools.ORM.ShapeModel.ORMShapeDomainModel), "Neumont.Tools.ORM.GeneratedCode.ShapeDomainModelResx")]
		[DslDesign::DescriptionResource("Neumont.Tools.ORM.ShapeModel.ORMDiagram/AutoPopulateShapes.Description", typeof(global::Neumont.Tools.ORM.ShapeModel.ORMShapeDomainModel), "Neumont.Tools.ORM.GeneratedCode.ShapeDomainModelResx")]
		[global::System.ComponentModel.Browsable(false)]
		[DslModeling::DomainObjectId("d3f7a171-ce39-4944-be80-d55127423c83")]
		public global::System.Boolean AutoPopulateShapes
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return autoPopulateShapesPropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				AutoPopulateShapesPropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the ORMDiagram.AutoPopulateShapes domain property.
		/// </summary>
		internal sealed partial class AutoPopulateShapesPropertyHandler : DslModeling::DomainPropertyValueHandler<ORMDiagramBase, global::System.Boolean>
		{
			private AutoPopulateShapesPropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the ORMDiagram.AutoPopulateShapes domain property value handler.
			/// </summary>
			public static readonly AutoPopulateShapesPropertyHandler Instance = new AutoPopulateShapesPropertyHandler();
		
			/// <summary>
			/// Gets the Id of the ORMDiagram.AutoPopulateShapes domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return AutoPopulateShapesDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.Boolean GetValue(ORMDiagramBase element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.autoPopulateShapesPropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(ORMDiagramBase element, global::System.Boolean newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.Boolean oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.autoPopulateShapesPropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
	}
	/// <summary>
	/// DomainClass ORMDiagram
	/// Description for Neumont.Tools.ORM.ShapeModel.ORMDiagram
	/// </summary>
	[global::System.CLSCompliant(true)]
			
	public partial class ORMDiagram : ORMDiagramBase
	{
		#region Constructors
		// Constructors were not generated for this class because it had HasCustomConstructor
		// set to true. Please provide the constructors below in a partial class.
		///// <summary>
		///// Constructor
		///// </summary>
		///// <param name="store">Store where new element is to be created.</param>
		///// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		//public ORMDiagram(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
		//	: this(store != null ? store.DefaultPartition : null, propertyAssignments)
		//{
		//}
		//
		///// <summary>
		///// Constructor
		///// </summary>
		///// <param name="partition">Partition where new element is to be created.</param>
		///// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		//public ORMDiagram(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
		//	: base(partition, propertyAssignments)
		//{
		//}
		#endregion
	}
}
namespace Neumont.Tools.ORM.ShapeModel
{
		/// <summary>
		/// Rule that initiates view fixup when an element that has an associated shape is added to the model. 
		/// </summary>
		[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.FrequencyConstraint), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeParentExistRulePriority, InitiallyDisabled=true)]
		[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.RingConstraint), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeParentExistRulePriority, InitiallyDisabled=true)]
		[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.SetConstraint), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeParentExistRulePriority, InitiallyDisabled=true)]
		[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.RoleValueConstraint), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeParentExistRulePriority, InitiallyDisabled=true)]
		[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.ValueTypeValueConstraint), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeParentExistRulePriority, InitiallyDisabled=true)]
		[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.ObjectType), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeParentExistRulePriority, InitiallyDisabled=true)]
		[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.Role), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeParentExistRulePriority, InitiallyDisabled=true)]
		[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.ModelNote), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeParentExistRulePriority, InitiallyDisabled=true)]
		[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.SubtypeFact), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeParentExistRulePriority, InitiallyDisabled=true)]
		[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.SetComparisonConstraint), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeParentExistRulePriority, InitiallyDisabled=true)]
		[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.ModelNoteReferencesObjectType), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddConnectionRulePriority, InitiallyDisabled=true)]
		[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.ModelNoteReferencesFactType), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddConnectionRulePriority, InitiallyDisabled=true)]
		[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.ReadingOrder), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeParentExistRulePriority, InitiallyDisabled=true)]
		[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.FactType), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddShapeParentExistRulePriority, InitiallyDisabled=true)]
		[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.ObjectTypePlaysRole), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddConnectionRulePriority, InitiallyDisabled=true)]
		[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.FactConstraint), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddConnectionRulePriority, InitiallyDisabled=true)]
		[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.RoleHasValueConstraint), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddConnectionRulePriority, InitiallyDisabled=true)]
		internal sealed partial class FixUpDiagram : DslModeling::AddRule
		{
			[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
			public override void ElementAdded(DslModeling::ElementAddedEventArgs e)
			{
				if(e == null) throw new global::System.ArgumentNullException("e");
			
				DslModeling::ModelElement childElement = e.ModelElement;
				if (childElement.IsDeleted)
					return;
				DslModeling::ModelElement parentElement;
				if(childElement is DslModeling::ElementLink)
				{
					parentElement = GetParentForRelationship((DslModeling::ElementLink)childElement);
				} else
				if(childElement is global::Neumont.Tools.ORM.ObjectModel.FrequencyConstraint)
				{
					parentElement = GetParentForFrequencyConstraint((global::Neumont.Tools.ORM.ObjectModel.FrequencyConstraint)childElement);
				} else
				if(childElement is global::Neumont.Tools.ORM.ObjectModel.RingConstraint)
				{
					parentElement = GetParentForRingConstraint((global::Neumont.Tools.ORM.ObjectModel.RingConstraint)childElement);
				} else
				if(childElement is global::Neumont.Tools.ORM.ObjectModel.SetConstraint)
				{
					parentElement = GetParentForSetConstraint((global::Neumont.Tools.ORM.ObjectModel.SetConstraint)childElement);
				} else
				if(childElement is global::Neumont.Tools.ORM.ObjectModel.RoleValueConstraint)
				{
					parentElement = GetParentForRoleValueConstraint((global::Neumont.Tools.ORM.ObjectModel.RoleValueConstraint)childElement);
				} else
				if(childElement is global::Neumont.Tools.ORM.ObjectModel.ValueTypeValueConstraint)
				{
					parentElement = GetParentForValueTypeValueConstraint((global::Neumont.Tools.ORM.ObjectModel.ValueTypeValueConstraint)childElement);
				} else
				if(childElement is global::Neumont.Tools.ORM.ObjectModel.ObjectType)
				{
					parentElement = GetParentForObjectType((global::Neumont.Tools.ORM.ObjectModel.ObjectType)childElement);
				} else
				if(childElement is global::Neumont.Tools.ORM.ObjectModel.Role)
				{
					parentElement = GetParentForRole((global::Neumont.Tools.ORM.ObjectModel.Role)childElement);
				} else
				if(childElement is global::Neumont.Tools.ORM.ObjectModel.ModelNote)
				{
					parentElement = GetParentForModelNote((global::Neumont.Tools.ORM.ObjectModel.ModelNote)childElement);
				} else
				if(childElement is global::Neumont.Tools.ORM.ObjectModel.SubtypeFact)
				{
					parentElement = GetParentForSubtypeFact((global::Neumont.Tools.ORM.ObjectModel.SubtypeFact)childElement);
				} else
				if(childElement is global::Neumont.Tools.ORM.ObjectModel.SetComparisonConstraint)
				{
					parentElement = GetParentForSetComparisonConstraint((global::Neumont.Tools.ORM.ObjectModel.SetComparisonConstraint)childElement);
				} else
				if(childElement is global::Neumont.Tools.ORM.ObjectModel.ReadingOrder)
				{
					parentElement = GetParentForReadingOrder((global::Neumont.Tools.ORM.ObjectModel.ReadingOrder)childElement);
				} else
				if(childElement is global::Neumont.Tools.ORM.ObjectModel.FactType)
				{
					parentElement = GetParentForFactType((global::Neumont.Tools.ORM.ObjectModel.FactType)childElement);
				} else
				{
					parentElement = null;
				}
				
				if(parentElement != null)
				{
					DslDiagrams::Diagram.FixUpDiagram(parentElement, childElement);
				}
			}
			public static global::Neumont.Tools.ORM.ObjectModel.ORMModel GetParentForObjectType( global::Neumont.Tools.ORM.ObjectModel.ObjectType root )
			{
				// Segments 0 and 1
				global::Neumont.Tools.ORM.ObjectModel.ORMModel result = root.Model;
				if ( result == null ) return null;
				return result;
			}
			public static global::Neumont.Tools.ORM.ObjectModel.ORMModel GetParentForFactType( global::Neumont.Tools.ORM.ObjectModel.FactType root )
			{
				// Segments 0 and 1
				global::Neumont.Tools.ORM.ObjectModel.ORMModel result = root.Model;
				if ( result == null ) return null;
				return result;
			}
			public static global::Neumont.Tools.ORM.ObjectModel.ORMModel GetParentForSubtypeFact( global::Neumont.Tools.ORM.ObjectModel.FactType root )
			{
				// Segments 0 and 1
				global::Neumont.Tools.ORM.ObjectModel.ORMModel result = root.Model;
				if ( result == null ) return null;
				return result;
			}
			public static global::Neumont.Tools.ORM.ObjectModel.ORMModel GetParentForSetComparisonConstraint( global::Neumont.Tools.ORM.ObjectModel.SetComparisonConstraint root )
			{
				// Segments 0 and 1
				global::Neumont.Tools.ORM.ObjectModel.ORMModel result = root.Model;
				if ( result == null ) return null;
				return result;
			}
			public static global::Neumont.Tools.ORM.ObjectModel.ORMModel GetParentForSetConstraint( global::Neumont.Tools.ORM.ObjectModel.SetConstraint root )
			{
				// Segments 0 and 1
				global::Neumont.Tools.ORM.ObjectModel.ORMModel result = root.Model;
				if ( result == null ) return null;
				return result;
			}
			public static global::Neumont.Tools.ORM.ObjectModel.ORMModel GetParentForFrequencyConstraint( global::Neumont.Tools.ORM.ObjectModel.SetConstraint root )
			{
				// Segments 0 and 1
				global::Neumont.Tools.ORM.ObjectModel.ORMModel result = root.Model;
				if ( result == null ) return null;
				return result;
			}
			public static global::Neumont.Tools.ORM.ObjectModel.ORMModel GetParentForRingConstraint( global::Neumont.Tools.ORM.ObjectModel.SetConstraint root )
			{
				// Segments 0 and 1
				global::Neumont.Tools.ORM.ObjectModel.ORMModel result = root.Model;
				if ( result == null ) return null;
				return result;
			}
			public static global::Neumont.Tools.ORM.ObjectModel.ORMModel GetParentForRoleValueConstraint( global::Neumont.Tools.ORM.ObjectModel.RoleValueConstraint root )
			{
				// Segments 0 and 1
				global::Neumont.Tools.ORM.ObjectModel.RoleBase root2 = root.Role as global::Neumont.Tools.ORM.ObjectModel.RoleBase;
				if ( root2 == null ) return null;
				// Segments 2 and 3
				global::Neumont.Tools.ORM.ObjectModel.FactType root4 = root2.FactType;
				if ( root4 == null ) return null;
				// Segments 4 and 5
				global::Neumont.Tools.ORM.ObjectModel.ORMModel result = root4.Model;
				if ( result == null ) return null;
				return result;
			}
			public static global::Neumont.Tools.ORM.ObjectModel.ORMModel GetParentForValueTypeValueConstraint( global::Neumont.Tools.ORM.ObjectModel.ValueTypeValueConstraint root )
			{
				// Segments 0 and 1
				global::Neumont.Tools.ORM.ObjectModel.ObjectType root2 = root.ValueType;
				if ( root2 == null ) return null;
				// Segments 2 and 3
				global::Neumont.Tools.ORM.ObjectModel.ORMModel result = root2.Model;
				if ( result == null ) return null;
				return result;
			}
			public static global::Neumont.Tools.ORM.ObjectModel.ORMModel GetParentForReadingOrder( global::Neumont.Tools.ORM.ObjectModel.ReadingOrder root )
			{
				// Segments 0 and 1
				global::Neumont.Tools.ORM.ObjectModel.FactType root2 = root.FactType;
				if ( root2 == null ) return null;
				// Segments 2 and 3
				global::Neumont.Tools.ORM.ObjectModel.ORMModel result = root2.Model;
				if ( result == null ) return null;
				return result;
			}
			public static global::Neumont.Tools.ORM.ObjectModel.ORMModel GetParentForRole( global::Neumont.Tools.ORM.ObjectModel.RoleBase root )
			{
				// Segments 0 and 1
				global::Neumont.Tools.ORM.ObjectModel.FactType root2 = root.FactType;
				if ( root2 == null ) return null;
				// Segments 2 and 3
				global::Neumont.Tools.ORM.ObjectModel.ORMModel result = root2.Model;
				if ( result == null ) return null;
				return result;
			}
			public static global::Neumont.Tools.ORM.ObjectModel.ORMModel GetParentForModelNote( global::Neumont.Tools.ORM.ObjectModel.ModelNote root )
			{
				// Segments 0 and 1
				global::Neumont.Tools.ORM.ObjectModel.ORMModel result = root.Model;
				if ( result == null ) return null;
				return result;
			}
			private static DslModeling::ModelElement GetParentForRelationship(DslModeling::ElementLink elementLink)
			{
				global::System.Collections.ObjectModel.ReadOnlyCollection<DslModeling::ModelElement> linkedElements = elementLink.LinkedElements;
	
				if (linkedElements.Count == 2)
				{
					DslDiagrams::ShapeElement sourceShape = linkedElements[0] as DslDiagrams::ShapeElement;
					DslDiagrams::ShapeElement targetShape = linkedElements[1] as DslDiagrams::ShapeElement;
	
					if(sourceShape == null)
					{
						DslModeling::LinkedElementCollection<DslDiagrams::PresentationElement> presentationElements = DslDiagrams::PresentationViewsSubject.GetPresentation(linkedElements[0]);
						foreach (DslDiagrams::PresentationElement presentationElement in presentationElements)
						{
							DslDiagrams::ShapeElement shape = presentationElement as DslDiagrams::ShapeElement;
							if (shape != null)
							{
								sourceShape = shape;
								break;
							}
						}
					}
					
					if(targetShape == null)
					{
						DslModeling::LinkedElementCollection<DslDiagrams::PresentationElement> presentationElements = DslDiagrams::PresentationViewsSubject.GetPresentation(linkedElements[1]);
						foreach (DslDiagrams::PresentationElement presentationElement in presentationElements)
						{
							DslDiagrams::ShapeElement shape = presentationElement as DslDiagrams::ShapeElement;
							if (shape != null)
							{
								targetShape = shape;
								break;
							}
						}
					}
					
					if(sourceShape == null || targetShape == null)
					{
						global::System.Diagnostics.Debug.Fail("Unable to find source and/or target shape for view fixup.");
						return null;
					}
	
					DslDiagrams::ShapeElement sourceParent = sourceShape.ParentShape;
					DslDiagrams::ShapeElement targetParent = targetShape.ParentShape;
	
					while (sourceParent != targetParent && sourceParent != null)
					{
						DslDiagrams::ShapeElement curParent = targetParent;
						while (sourceParent != curParent && curParent != null)
						{
							curParent = curParent.ParentShape;
						}
	
						if(sourceParent == curParent)
						{
							break;
						}
						else
						{
							sourceParent = sourceParent.ParentShape;
						}
					}
	
					while (sourceParent != null)
					{
						// ensure that the parent can parent connectors (i.e., a diagram or a swimlane).
						if(sourceParent is DslDiagrams::Diagram || sourceParent is DslDiagrams::SwimlaneShape)
						{
							break;
						}
						else
						{
							sourceParent = sourceParent.ParentShape;
						}
					}
	
					global::System.Diagnostics.Debug.Assert(sourceParent != null && sourceParent.ModelElement != null, "Unable to find common parent for view fixup.");
					return sourceParent.ModelElement;
				}
	
				return null;
			}
		}
		
	
		/// <summary>
		/// Reroute a connector when the role players of its underlying relationship change
		/// </summary>
		[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.ObjectTypePlaysRole), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddConnectionRulePriority, InitiallyDisabled=true)]
		[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.FactConstraint), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddConnectionRulePriority, InitiallyDisabled=true)]
		[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.RoleHasValueConstraint), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddConnectionRulePriority, InitiallyDisabled=true)]
		[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.ModelNoteReferencesFactType), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddConnectionRulePriority, InitiallyDisabled=true)]
		[DslModeling::RuleOn(typeof(global::Neumont.Tools.ORM.ObjectModel.ModelNoteReferencesObjectType), FireTime = DslModeling::TimeToFire.TopLevelCommit, Priority = DslDiagrams::DiagramFixupConstants.AddConnectionRulePriority, InitiallyDisabled=true)]
		internal sealed class ConnectorRolePlayerChanged : DslModeling::RolePlayerChangeRule
		{
			/// <summary>
			/// Reroute a connector when the role players of its underlying relationship change
			/// </summary>
			public override void RolePlayerChanged(DslModeling::RolePlayerChangedEventArgs e)
			{
				if (e == null) throw new global::System.ArgumentNullException("e");
	
				global::System.Collections.ObjectModel.ReadOnlyCollection<DslDiagrams::PresentationViewsSubject> connectorLinks = DslDiagrams::PresentationViewsSubject.GetLinksToPresentation(e.ElementLink);
				foreach (DslDiagrams::PresentationViewsSubject connectorLink in connectorLinks)
				{
					// Fix up any binary link shapes attached to the element link.
					DslDiagrams::BinaryLinkShape linkShape = connectorLink.Presentation as DslDiagrams::BinaryLinkShape;
					if (linkShape != null)
					{
						global::Neumont.Tools.ORM.ShapeModel.ORMDiagram diagram = linkShape.Diagram as global::Neumont.Tools.ORM.ShapeModel.ORMDiagram;
						if (diagram != null)
						{
							if (e.NewRolePlayer != null)
							{
								DslDiagrams::NodeShape fromShape;
								DslDiagrams::NodeShape toShape;
								diagram.GetSourceAndTargetForConnector(linkShape, out fromShape, out toShape);
								if (fromShape != null && toShape != null)
								{
									if (!object.Equals(fromShape, linkShape.FromShape))
									{
										linkShape.FromShape = fromShape;
									}
									if (!object.Equals(linkShape.ToShape, toShape))
									{
										linkShape.ToShape = toShape;
									}
								}
								else
								{
									// delete the connector if we cannot find an appropriate target shape.
									linkShape.Delete();
								}
							}
							else
							{
								// delete the connector if the new role player is null.
								linkShape.Delete();
							}
						}
					}
				}
			}
		}
	}

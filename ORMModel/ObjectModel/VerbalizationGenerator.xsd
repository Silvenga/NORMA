<?xml version="1.0" encoding="utf-8"?>
<xs:schema
	attributeFormDefault="unqualified"
	elementFormDefault="qualified"
	targetNamespace="http://schemas.neumont.edu/ORM/SDK/Verbalization"
	xmlns="http://schemas.neumont.edu/ORM/SDK/Verbalization"
	xmlns:ve="http://schemas.neumont.edu/ORM/SDK/Verbalization"
	xmlns:xs="http://www.w3.org/2001/XMLSchema">
	<xs:import namespace="http://www.w3.org/XML/1998/namespace"/>
	<xs:simpleType name="ModalityEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="alethic"/>
			<xs:enumeration value="deontic"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="SignEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="positive"/>
			<xs:enumeration value="negative"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="PassEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="first"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="SpanEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="all"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="SnippetTypeEnum">
		<xs:restriction base="xs:NMTOKEN">
			<xs:enumeration value="ObjectType"/>
			<xs:enumeration value="ObjectTypeWithSubscript"/>
			<xs:enumeration value="ObjectTypeMissing"/>
			<xs:enumeration value="ImpersonalPronoun"/>
			<xs:enumeration value="PersonalPronoun"/>
			<xs:enumeration value="DefiniteArticle">
				<xs:annotation>
					<xs:documentation>Used for 'that' before an object name. Different than ImpersonalPronoun
					which is used to refer back to an object and is frequently used conditionally with PersonalPronoun.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="UniversalQuantifier"/>
			<xs:enumeration value="AtMostOneQuantifier"/>
			<xs:enumeration value="EachInstanceQuantifier"/>
			<xs:enumeration value="ForEachCompactQuantifier"/>
			<xs:enumeration value="ForEachQuantifier"/>
			<xs:enumeration value="ExistentialQuantifier"/>
			<xs:enumeration value="IdentityReferenceQuantifier"/>
			<xs:enumeration value="ImpliedModalNecessityOperator">
				<xs:annotation>
					<xs:documentation>No text for alethic, same as ModalNecessityOperator otherwise.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MoreThanOneQuantifier"/>
			<xs:enumeration value="ModalPossibilityOperator"/>
			<xs:enumeration value="ModalNecessityOperator"/>
			<xs:enumeration value="NegativeReadingForUnaryOnlyDisjunctiveMandatory"/>
			<xs:enumeration value="CompoundListOpen"/>
			<xs:enumeration value="CompoundListPairSeparator"/>
			<xs:enumeration value="CompoundListSeparator"/>
			<xs:enumeration value="CompoundListFinalSeparator"/>
			<xs:enumeration value="CompoundListClose"/>
			<xs:enumeration value="IndentedListOpen"/>
			<xs:enumeration value="IndentedListPairSeparator"/>
			<xs:enumeration value="IndentedListSeparator"/>
			<xs:enumeration value="IndentedListFinalSeparator"/>
			<xs:enumeration value="IndentedListClose"/>
			<xs:enumeration value="IndentedLogicalAndListOpen"/>
			<xs:enumeration value="IndentedLogicalAndListPairSeparator"/>
			<xs:enumeration value="IndentedLogicalAndListSeparator"/>
			<xs:enumeration value="IndentedLogicalAndListFinalSeparator"/>
			<xs:enumeration value="IndentedLogicalAndListClose"/>
			<xs:enumeration value="IndentedLogicalOrListOpen"/>
			<xs:enumeration value="IndentedLogicalOrListPairSeparator"/>
			<xs:enumeration value="IndentedLogicalOrListSeparator"/>
			<xs:enumeration value="IndentedLogicalOrListFinalSeparator"/>
			<xs:enumeration value="IndentedLogicalOrListClose"/>
			<xs:enumeration value="ConstraintProvidesPreferredIdentifier"/>
			<xs:enumeration value="TopLevelIndentedLogicalAndListOpen"/>
			<xs:enumeration value="TopLevelIndentedLogicalAndListPairSeparator"/>
			<xs:enumeration value="TopLevelIndentedLogicalAndListSeparator"/>
			<xs:enumeration value="TopLevelIndentedLogicalAndListFinalSeparator"/>
			<xs:enumeration value="TopLevelIndentedLogicalAndListClose"/>
			<xs:enumeration value="TopLevelIndentedLogicalOrListOpen"/>
			<xs:enumeration value="TopLevelIndentedLogicalOrListPairSeparator"/>
			<xs:enumeration value="TopLevelIndentedLogicalOrListSeparator"/>
			<xs:enumeration value="TopLevelIndentedLogicalOrListFinalSeparator"/>
			<xs:enumeration value="TopLevelIndentedLogicalOrListClose"/>
			<xs:enumeration value="SimpleListOpen"/>
			<xs:enumeration value="SimpleListPairSeparator"/>
			<xs:enumeration value="SimpleListSeparator"/>
			<xs:enumeration value="SimpleListFinalSeparator"/>
			<xs:enumeration value="SimpleListClose"/>
			<xs:enumeration value="CompactSimpleListOpen"/>
			<xs:enumeration value="CompactSimpleListPairSeparator"/>
			<xs:enumeration value="CompactSimpleListSeparator"/>
			<xs:enumeration value="CompactSimpleListFinalSeparator"/>
			<xs:enumeration value="CompactSimpleListClose"/>
			<xs:enumeration value="CloseVerbalizationSentence"/>
			<xs:enumeration value="CombinationIdentifier"/>
			<xs:enumeration value="OccursInPopulation"/>
			<xs:enumeration value="OneQuantifier"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ConstraintTypeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="InternalUniquenessConstraint"/>
			<xs:enumeration value="ExternalUniquenessConstraint"/>
			<xs:enumeration value="DisjunctiveMandatoryConstraint"/>
			<xs:enumeration value="SimpleMandatoryConstraint"/>
			<xs:enumeration value="FrequencyConstraint"/>
			<xs:enumeration value="RingConstraint"/>
			<xs:enumeration value="SubsetConstraint"/>
			<xs:enumeration value="ExclusionConstraint"/>
			<xs:enumeration value="EqualityConstraint"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ConstraintPatternGroupEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="InternalConstraint"/>
			<xs:enumeration value="SingleColumnExternalConstraint"/>
			<xs:enumeration value="MultiColumnExternalConstraint"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ReadingChoicePreferSingleMatchEnum">
		<xs:restriction base="xs:string">
			<!-- Allowable options are {Conditional|Prefer[Non][Primary]LeadReading[NoForwardText]} -->
			<xs:enumeration value="Conditional"/>
			<xs:enumeration value="PreferLeadReading"/>
			<xs:enumeration value="PreferNonLeadReading"/>
			<xs:enumeration value="PreferPrimaryLeadReading"/>
			<xs:enumeration value="PreferNonPrimaryLeadReading"/>
			<xs:enumeration value="PreferLeadReadingNoForwardText"/>
			<xs:enumeration value="PreferNonLeadReadingNoForwardText"/>
			<xs:enumeration value="PreferPrimaryLeadReadingNoForwardText"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingNoForwardText"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ReadingChoiceFullRequiredMatchEnum">
		<xs:restriction base="xs:string">
			<!-- Allowable options are {Require[All][Non][Primary]LeadReading[NoForwardText]} -->
			<xs:enumeration value="RequireLeadReading"/>
			<xs:enumeration value="RequireNonLeadReading"/>
			<xs:enumeration value="RequirePrimaryLeadReading"/>
			<xs:enumeration value="RequireNonPrimaryLeadReading"/>
			<xs:enumeration value="RequireLeadReadingNoForwardText"/>
			<xs:enumeration value="RequireNonLeadReadingNoForwardText"/>
			<xs:enumeration value="RequirePrimaryLeadReadingNoForwardText"/>
			<xs:enumeration value="RequireNonPrimaryLeadReadingNoForwardText"/>
			<xs:enumeration value="RequireAllLeadReading"/>
			<xs:enumeration value="RequireAllNonLeadReading"/>
			<xs:enumeration value="RequireAllPrimaryLeadReading"/>
			<xs:enumeration value="RequireAllNonPrimaryLeadReading"/>
			<xs:enumeration value="RequireAllLeadReadingNoForwardText"/>
			<xs:enumeration value="RequireAllNonLeadReadingNoForwardText"/>
			<xs:enumeration value="RequireAllPrimaryLeadReadingNoForwardText"/>
			<xs:enumeration value="RequireAllNonPrimaryLeadReadingNoForwardText"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ListStyleEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="CompactSimpleList"/>
			<xs:enumeration value="CompoundList"/>
			<xs:enumeration value="IndentedList"/>
			<xs:enumeration value="IndentedLogicalAndList"/>
			<xs:enumeration value="IndentedLogicalOrList"/>
			<xs:enumeration value="SimpleList"/>
			<xs:enumeration value="TopLevelIndentedLogicalAndList"/>
			<xs:enumeration value="TopLevelIndentedLogicalOrList"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="PredicateReplacementMatchEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="included"/>
			<xs:enumeration value="excluded"/>
			<xs:enumeration value="primary"/>
			<xs:enumeration value="secondary"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="IterateRolesMatchEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="all"/>
			<xs:enumeration value="included"/>
			<xs:enumeration value="excluded"/>
			<xs:enumeration value="singleColumnConstraintRoles"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:attributeGroup name="FactArityAttributes">
		<xs:attribute name="factArity" type="xs:unsignedByte" use="optional"/>
		<xs:attribute name="minFactArity" type="xs:unsignedByte" use="optional"/>
		<xs:attribute name="maxFactArity" type="xs:unsignedByte" use="optional"/>
	</xs:attributeGroup>
	<xs:complexType name="SnippetLeafType">
		<xs:attribute name="ref" use="required">
			<xs:simpleType>
				<xs:union memberTypes="SnippetTypeEnum">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="null"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:union>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="SnippetLeafTypeWithMatch">
		<xs:complexContent>
			<xs:extension base="SnippetLeafType">
				<xs:attribute name="match" use="optional" type="ConditionalMatchPatternType"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="ConditionalMatchPatternType">
		<xs:restriction base="xs:token">
			<xs:enumeration value="IsPersonal">
				<xs:annotation>
					<xs:documentation>True if the IsPersonal property for the current role player is true.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="IsPreferredIdentifier">
				<xs:annotation>
					<xs:documentation>True if the current constraint is a preferred identifier.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="SnippetType">
		<xs:complexContent>
			<xs:extension base="SnippetLeafType">
				<xs:choice minOccurs="1" maxOccurs="unbounded">
					<xs:element name="Snippet" type="SnippetType"/>
					<xs:element name="IterateRoles" type="IterateRolesType"/>
					<xs:element name="CompositeList" type="CompositeListType"/>
					<xs:element name="Fact" type="FactType"/>
				</xs:choice>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="SnippetTypeWithMatch">
		<xs:complexContent>
			<xs:extension base="SnippetType">
				<xs:attribute name="match" use="optional" type="ConditionalMatchPatternType"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ConditionalSnippetType">
		<xs:choice minOccurs="1" maxOccurs="unbounded">
			<xs:element name="Snippet" type="SnippetLeafTypeWithMatch"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="PredicateReplacementType">
		<xs:choice minOccurs="1" maxOccurs="1">
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType"/>
			<xs:element name="Snippet" type="SnippetLeafType"/>
		</xs:choice>
		<xs:attribute name="match" use="optional" type="PredicateReplacementMatchEnum"/>
		<xs:attribute name="pass" use="optional" type="PassEnum"/>
	</xs:complexType>
	<xs:complexType name="FactConstructType">
		<!-- Nothing here yet, this is for the top-level verbalization of a Fact -->
	</xs:complexType>
	<xs:complexType name="FactType">
		<xs:sequence minOccurs="0" maxOccurs="1">
			<xs:element name="PredicateReplacement" type="PredicateReplacementType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="readingChoice" use="optional" type="ReadingChoicePreferSingleMatchEnum"/>
	</xs:complexType>
	<xs:complexType name="IterateRolesNoListType">
		<xs:sequence>
			<xs:element name="Fact" type="FactType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="match" type="IterateRolesMatchEnum" default="all"/>
		<xs:attributeGroup ref="FactArityAttributes"/>
		<xs:attribute name="pass" use="optional" type="PassEnum"/>
	</xs:complexType>
	<xs:complexType name="IterateRolesType">
		<xs:complexContent>
			<xs:extension base="IterateRolesNoListType">
				<xs:attribute name="listStyle" use="required">
					<xs:simpleType>
						<xs:union memberTypes="ListStyleEnum">
							<xs:simpleType>
								<xs:restriction base="xs:token">
									<xs:enumeration value="null"/>
								</xs:restriction>
							</xs:simpleType>
						</xs:union>
					</xs:simpleType>
				</xs:attribute>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ReadingChoiceType">
		<xs:choice minOccurs="1" maxOccurs="unbounded">
			<xs:element name="Fact" type="FactType"/>
			<xs:element name="Snippet" type="SnippetType"/>
			<xs:element name="CompositeList" type="CompositeListType"/>
			<xs:element name="IterateRoles" type="IterateRolesType"/>
		</xs:choice>
		<xs:attribute name="match" use="optional" type="ReadingChoiceFullRequiredMatchEnum"/>
	</xs:complexType>
	<xs:complexType name="ConditionalReadingType">
		<xs:sequence>
			<xs:element name="ReadingChoice" type="ReadingChoiceType" minOccurs="2" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="CompositeListType">
		<xs:sequence>
			<xs:element name="IterateRoles" type="IterateRolesNoListType" minOccurs="1" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="listStyle" type="ListStyleEnum" use="required"/>
	</xs:complexType>
	<xs:complexType name="LanguageType">
		<xs:sequence>
			<xs:element name="Snippets" minOccurs="1" maxOccurs="1">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Snippet" minOccurs="1" maxOccurs="unbounded">
							<xs:complexType>
								<xs:simpleContent>
									<xs:extension base="xs:string">
										<xs:attribute name="type" use="required">
											<xs:simpleType>
												<xs:union memberTypes="SnippetTypeEnum">
													<!-- Add extra elements that are reserved for use by the verbalizer -->
													<xs:simpleType>
														<xs:restriction base="xs:NMTOKEN">
															<xs:enumeration value="VerbalizerNewLine">
																<xs:annotation>
																	<xs:documentation>Used by the verbalizer to enter a new line</xs:documentation>
																</xs:annotation>
															</xs:enumeration>
															<xs:enumeration value="VerbalizerIncreaseIndent">
																<xs:annotation>
																	<xs:documentation>Used by the verbalizer to indent a child verbalization</xs:documentation>
																</xs:annotation>
															</xs:enumeration>
															<xs:enumeration value="VerbalizerDecreaseIndent">
																<xs:annotation>
																	<xs:documentation>Used by the verbalizer to close indent opened by VerbalizerIncreaseIndent</xs:documentation>
																</xs:annotation>
															</xs:enumeration>
															<xs:enumeration value="VerbalizerOpenVerbalization">
																<xs:annotation>
																	<xs:documentation>Used by the verbalizer around a single verbalization</xs:documentation>
																</xs:annotation>
															</xs:enumeration>
															<xs:enumeration value="VerbalizerCloseVerbalization">
																<xs:annotation>
																	<xs:documentation>Used by the verbalizer to close a verbalization opened by VerbalizerOpenVerbalization</xs:documentation>
																</xs:annotation>
															</xs:enumeration>
															<xs:enumeration value="VerbalizerOpenError">
																<xs:annotation>
																	<xs:documentation>Used by the verbalizer around an error section</xs:documentation>
																</xs:annotation>
															</xs:enumeration>
															<xs:enumeration value="VerbalizerCloseError">
																<xs:annotation>
																	<xs:documentation>Used by the verbalizer to close an error section</xs:documentation>
																</xs:annotation>
															</xs:enumeration>
															<xs:enumeration value="VerbalizerDocumentHeader">
																<xs:annotation>
																	<xs:documentation>Used by the verbalizer to open a document. The document header gets replacement fields in the following order:
																	{0} font-family
																	{1} font-size
																	{2} predicate text color
																	{3} predicate text bold
																	{4} object name color
																	{5} object name bold
																	{6} formal item color
																	{7} formal item bold
																	</xs:documentation>
																</xs:annotation>
															</xs:enumeration>
															<xs:enumeration value="VerbalizerDocumentFooter">
																<xs:annotation>
																	<xs:documentation>Used by the verbalizer to close a document</xs:documentation>
																</xs:annotation>
															</xs:enumeration>
															<xs:enumeration value="VerbalizerFontWeightBold">
																<xs:annotation>
																	<xs:documentation>The text to insert to indicate a bold font.</xs:documentation>
																</xs:annotation>
															</xs:enumeration>
															<xs:enumeration value="VerbalizerFontWeightNormal">
																<xs:annotation>
																	<xs:documentation>The text to insert to indicate a normal font weight.</xs:documentation>
																</xs:annotation>
															</xs:enumeration>
														</xs:restriction>
													</xs:simpleType>
												</xs:union>
											</xs:simpleType>
										</xs:attribute>
										<xs:attribute name="modality" type="ModalityEnum" use="optional"/>
										<xs:attribute name="sign" type="SignEnum" use="optional"/>
									</xs:extension>
								</xs:simpleContent>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attribute ref="xml:lang" use="required"/>
	</xs:complexType>
	<xs:complexType name="ConstraintsConstructType">
		<xs:sequence>
			<xs:element name="Constraint" type="ConstraintType" minOccurs="1" maxOccurs="unbounded">
				<xs:unique name="ConstrainedRolesFilter">
					<xs:selector xpath="ve:ConstrainedRoles"/>
					<xs:field xpath="@span"/>
					<xs:field xpath="@factArity"/>
					<xs:field xpath="@minFactArity"/>
					<xs:field xpath="@maxFactArity"/>
				</xs:unique>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ConstraintType">
		<xs:sequence>
			<xs:element name="ConstrainedRoles" minOccurs="1" maxOccurs="unbounded" >
				<xs:complexType>
					<xs:choice minOccurs="1" maxOccurs="unbounded">
						<xs:element name="Snippet" type="SnippetTypeWithMatch"/>
						<xs:element name="IterateRoles" type="IterateRolesType"/>
						<xs:element name="CompositeList" type="CompositeListType"/>
						<xs:element name="ConditionalReading" type="ConditionalReadingType">
							<xs:unique name="ConditionalReadingReadingChoice">
								<xs:selector xpath="ve:ReadingChoice"/>
								<xs:field xpath="@match"/>
							</xs:unique>
						</xs:element>
					</xs:choice>
					<xs:attribute name="span" type="SpanEnum" use="optional"/>
					<xs:attribute name="sign" type="SignEnum" use="optional"/>
					<xs:attributeGroup ref="FactArityAttributes"/>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attribute name="type" type="ConstraintTypeEnum" use="required"/>
		<xs:attribute name="patternGroup" type="ConstraintPatternGroupEnum" use="required"/>
	</xs:complexType>
	<xs:element name="VerbalizationRoot">
		<xs:complexType>
			<xs:sequence>
				<xs:element name="Languages" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:sequence>
							<xs:element name="Language" type="LanguageType" minOccurs="1" maxOccurs="unbounded"/>
						</xs:sequence>
					</xs:complexType>
					<xs:key name="LanguageCodeKey">
						<xs:selector xpath="ve:Language"/>
						<xs:field xpath="@xml:lang"/>
					</xs:key>
				</xs:element>
				<xs:element name="Constructs" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:all>
							<xs:element name="FactType" type="FactConstructType"/>
							<xs:element name="Constraints" type="ConstraintsConstructType"/>
						</xs:all>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
</xs:schema>
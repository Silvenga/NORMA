<?xml version="1.0" encoding="utf-8"?>
<xs:schema
	attributeFormDefault="unqualified"
	elementFormDefault="qualified"
	targetNamespace="http://schemas.neumont.edu/ORM/SDK/Verbalization"
	xmlns="http://schemas.neumont.edu/ORM/SDK/Verbalization"
	xmlns:ve="http://schemas.neumont.edu/ORM/SDK/Verbalization"
	xmlns:xs="http://www.w3.org/2001/XMLSchema">
	<xs:import namespace="http://www.w3.org/XML/1998/namespace"/>
	<xs:simpleType name="ModalityEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="alethic"/>
			<xs:enumeration value="deontic"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="SignEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="positive"/>
			<xs:enumeration value="negative"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="PassEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="first"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="SpanEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="all"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="SnippetTypeEnum">
		<xs:restriction base="xs:NMTOKEN">
			<xs:enumeration value="ObjectType"/>
			<xs:enumeration value="ObjectTypeWithSubscript"/>
			<xs:enumeration value="ObjectTypeMissing"/>
			<xs:enumeration value="ImpersonalPronoun"/>
			<xs:enumeration value="PersonalPronoun"/>
			<xs:enumeration value="DefiniteArticle">
				<xs:annotation>
					<xs:documentation>
						Used for 'that' before an object name. Different than ImpersonalPronoun
						which is used to refer back to an object and is frequently used conditionally with PersonalPronoun.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="UniversalQuantifier"/>
			<xs:enumeration value="AtMostOneQuantifier"/>
			<xs:enumeration value="EachInstanceQuantifier"/>
			<xs:enumeration value="ForEachCompactQuantifier"/>
			<xs:enumeration value="ForEachQuantifier"/>
			<xs:enumeration value="ExistentialQuantifier"/>
			<xs:enumeration value="IdentityReferenceQuantifier"/>
			<xs:enumeration value="ImpliedModalNecessityOperator">
				<xs:annotation>
					<xs:documentation>No text for alethic, same as ModalNecessityOperator otherwise.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MoreThanOneQuantifier"/>
			<xs:enumeration value="ModalPossibilityOperator"/>
			<xs:enumeration value="ModalNecessityOperator"/>
			<xs:enumeration value="NegativeReadingForUnaryOnlyDisjunctiveMandatory"/>
			<xs:enumeration value="CompoundListOpen"/>
			<xs:enumeration value="CompoundListPairSeparator"/>
			<xs:enumeration value="CompoundListSeparator"/>
			<xs:enumeration value="CompoundListFinalSeparator"/>
			<xs:enumeration value="CompoundListClose"/>
			<xs:enumeration value="IndentedListOpen"/>
			<xs:enumeration value="IndentedListPairSeparator"/>
			<xs:enumeration value="IndentedListSeparator"/>
			<xs:enumeration value="IndentedListFinalSeparator"/>
			<xs:enumeration value="IndentedListClose"/>
			<xs:enumeration value="IndentedLogicalAndListOpen"/>
			<xs:enumeration value="IndentedLogicalAndListPairSeparator"/>
			<xs:enumeration value="IndentedLogicalAndListSeparator"/>
			<xs:enumeration value="IndentedLogicalAndListFinalSeparator"/>
			<xs:enumeration value="IndentedLogicalAndListClose"/>
			<xs:enumeration value="IndentedLogicalOrListOpen"/>
			<xs:enumeration value="IndentedLogicalOrListPairSeparator"/>
			<xs:enumeration value="IndentedLogicalOrListSeparator"/>
			<xs:enumeration value="IndentedLogicalOrListFinalSeparator"/>
			<xs:enumeration value="IndentedLogicalOrListClose"/>
			<xs:enumeration value="ConstraintProvidesPreferredIdentifier"/>
			<xs:enumeration value="TopLevelIndentedLogicalAndListOpen"/>
			<xs:enumeration value="TopLevelIndentedLogicalAndListPairSeparator"/>
			<xs:enumeration value="TopLevelIndentedLogicalAndListSeparator"/>
			<xs:enumeration value="TopLevelIndentedLogicalAndListFinalSeparator"/>
			<xs:enumeration value="TopLevelIndentedLogicalAndListClose"/>
			<xs:enumeration value="TopLevelIndentedLogicalOrListOpen"/>
			<xs:enumeration value="TopLevelIndentedLogicalOrListPairSeparator"/>
			<xs:enumeration value="TopLevelIndentedLogicalOrListSeparator"/>
			<xs:enumeration value="TopLevelIndentedLogicalOrListFinalSeparator"/>
			<xs:enumeration value="TopLevelIndentedLogicalOrListClose"/>
			<xs:enumeration value="SimpleListOpen"/>
			<xs:enumeration value="SimpleListPairSeparator"/>
			<xs:enumeration value="SimpleListSeparator"/>
			<xs:enumeration value="SimpleListFinalSeparator"/>
			<xs:enumeration value="SimpleListClose"/>
			<xs:enumeration value="CompactSimpleListOpen"/>
			<xs:enumeration value="CompactSimpleListPairSeparator"/>
			<xs:enumeration value="CompactSimpleListSeparator"/>
			<xs:enumeration value="CompactSimpleListFinalSeparator"/>
			<xs:enumeration value="CompactSimpleListClose"/>
			<xs:enumeration value="CloseVerbalizationSentence"/>
			<xs:enumeration value="CombinationIdentifier"/>
			<xs:enumeration value="OccursInPopulation"/>
			<xs:enumeration value="OneQuantifier"/>
			<xs:enumeration value="PeriodDelimiter">
				<xs:annotation>
					<xs:documentation>{0}.{1} :: Used to delimit two snippet replacements by a snippet.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="NameWithRefMode">
				<xs:annotation>
					<xs:documentation>{0}({1}) :: Used to enclose the second snippet replacement in brackets.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="SingleValueValueConstraint">
				<xs:annotation>
					<xs:documentation>the possible value of {0} is {1} :: Used to verbalize a value range constraint with one range, where the min value is equal to the max value.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MultiValueValueConstraint">
				<xs:annotation>
					<xs:documentation>the possible values of {0} are {1} :: Used to verbalize a value range constraint with multiple values.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="SelfReference">
				<xs:annotation>
					<xs:documentation>{0} :: Allows the snippet replacement to verbalize itself.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinClosedMaxClosed">
				<xs:annotation>
					<xs:documentation>at least {0} to at most {1} :: Used to verbalize a range inclusion with the minimum bound closed and the maximum bound closed.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinClosedMaxOpen">
				<xs:annotation>
					<xs:documentation>at least {0} to below {1} :: Used to verbalize a range inclusion with the minimum bound closed and the maximum bound open.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinClosedMaxUnbounded">
				<xs:annotation>
					<xs:documentation>at least {0} :: Used to verbalize a range inclusion with the minimum bound closed and the maximum unbounded.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinOpenMaxClosed">
				<xs:annotation>
					<xs:documentation>above {0} to at most {1} :: Used to verbalize a range inclusion with the minimum bound open and the maximum bound closed.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinOpenMaxOpen">
				<xs:annotation>
					<xs:documentation>above {0} to below {1} :: Used to verbalize a range inclusion with the minimum bound open and the maximum bound open.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinOpenMaxUnbounded">
				<xs:annotation>
					<xs:documentation>above {0} :: Used to verbalize a range inclusion with the minimum bound open and the maximum unbounded.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinUnboundedMaxClosed">
				<xs:annotation>
					<xs:documentation>at most {1} :: Used to verbalize a range inclusion with the minimum unbounded and the maximum bound closed.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinUnboundedMaxOpen">
				<xs:annotation>
					<xs:documentation>below {1} :: Used to verbalize a range inclusion with the minimum unbounded and the maximum bound open.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="InSeparator">
				<xs:annotation>
					<xs:documentation>{0} in {1} :: Used to verbalize [RolePlayer in Fact] for role value constraints, e.g. Person in Person has Age.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ConstraintTypeEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="InternalUniquenessConstraint"/>
			<xs:enumeration value="ExternalUniquenessConstraint"/>
			<xs:enumeration value="DisjunctiveMandatoryConstraint"/>
			<xs:enumeration value="SimpleMandatoryConstraint"/>
			<xs:enumeration value="FrequencyConstraint"/>
			<xs:enumeration value="RingConstraint"/>
			<xs:enumeration value="SubsetConstraint"/>
			<xs:enumeration value="ExclusionConstraint"/>
			<xs:enumeration value="EqualityConstraint"/>
			<xs:enumeration value="RoleValueRangeDefinition">
				<xs:annotation>
					<xs:documentation>Verbalizes value range constraints on roles.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ConstraintPatternGroupEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="InternalConstraint"/>
			<xs:enumeration value="SingleColumnExternalConstraint"/>
			<xs:enumeration value="MultiColumnExternalConstraint"/>
			<xs:enumeration value="RoleValueConstraint">
				<xs:annotation>
					<xs:documentation>Verbalizes role value constraints.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ReadingChoicePreferSingleMatchEnum">
		<xs:restriction base="xs:string">
			<!-- Allowable options are {Conditional|Prefer[Non][Primary]LeadReading[NoForwardText]} -->
			<xs:enumeration value="Conditional"/>
			<xs:enumeration value="PreferLeadReading"/>
			<xs:enumeration value="PreferNonLeadReading"/>
			<xs:enumeration value="PreferPrimaryLeadReading"/>
			<xs:enumeration value="PreferNonPrimaryLeadReading"/>
			<xs:enumeration value="PreferLeadReadingNoForwardText"/>
			<xs:enumeration value="PreferNonLeadReadingNoForwardText"/>
			<xs:enumeration value="PreferPrimaryLeadReadingNoForwardText"/>
			<xs:enumeration value="PreferNonPrimaryLeadReadingNoForwardText"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ReadingChoiceFullRequiredMatchEnum">
		<xs:restriction base="xs:string">
			<!-- Allowable options are {Require[All][Non][Primary]LeadReading[NoForwardText]} -->
			<xs:enumeration value="RequireLeadReading"/>
			<xs:enumeration value="RequireNonLeadReading"/>
			<xs:enumeration value="RequirePrimaryLeadReading"/>
			<xs:enumeration value="RequireNonPrimaryLeadReading"/>
			<xs:enumeration value="RequireLeadReadingNoForwardText"/>
			<xs:enumeration value="RequireNonLeadReadingNoForwardText"/>
			<xs:enumeration value="RequirePrimaryLeadReadingNoForwardText"/>
			<xs:enumeration value="RequireNonPrimaryLeadReadingNoForwardText"/>
			<xs:enumeration value="RequireAllLeadReading"/>
			<xs:enumeration value="RequireAllNonLeadReading"/>
			<xs:enumeration value="RequireAllPrimaryLeadReading"/>
			<xs:enumeration value="RequireAllNonPrimaryLeadReading"/>
			<xs:enumeration value="RequireAllLeadReadingNoForwardText"/>
			<xs:enumeration value="RequireAllNonLeadReadingNoForwardText"/>
			<xs:enumeration value="RequireAllPrimaryLeadReadingNoForwardText"/>
			<xs:enumeration value="RequireAllNonPrimaryLeadReadingNoForwardText"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ListStyleEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="CompactSimpleList"/>
			<xs:enumeration value="CompoundList"/>
			<xs:enumeration value="IndentedList"/>
			<xs:enumeration value="IndentedLogicalAndList"/>
			<xs:enumeration value="IndentedLogicalOrList"/>
			<xs:enumeration value="SimpleList"/>
			<xs:enumeration value="TopLevelIndentedLogicalAndList"/>
			<xs:enumeration value="TopLevelIndentedLogicalOrList"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="ListStyleEnumOrNull">
		<xs:union memberTypes="ListStyleEnum">
			<xs:simpleType>
				<xs:restriction base="xs:token">
					<xs:enumeration value="null"/>
				</xs:restriction>
			</xs:simpleType>
		</xs:union>
	</xs:simpleType>
	<xs:simpleType name="RoleIteratorContextMatchEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="included"/>
			<xs:enumeration value="excluded"/>
			<xs:enumeration value="primary"/>
			<xs:enumeration value="secondary"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:simpleType name="IterateRolesMatchEnum">
		<xs:restriction base="xs:string">
			<xs:enumeration value="all"/>
			<xs:enumeration value="included"/>
			<xs:enumeration value="excluded"/>
			<xs:enumeration value="singleColumnConstraintRoles"/>
		</xs:restriction>
	</xs:simpleType>
	<xs:attributeGroup name="FactArityAttributes">
		<xs:attribute name="factArity" type="xs:unsignedByte" use="optional"/>
		<xs:attribute name="minFactArity" type="xs:unsignedByte" use="optional"/>
		<xs:attribute name="maxFactArity" type="xs:unsignedByte" use="optional"/>
	</xs:attributeGroup>
	<xs:complexType name="SnippetLeafType">
		<xs:attribute name="ref" use="required">
			<xs:simpleType>
				<xs:union memberTypes="SnippetTypeEnum">
					<xs:simpleType>
						<xs:restriction base="xs:string">
							<xs:enumeration value="null"/>
						</xs:restriction>
					</xs:simpleType>
				</xs:union>
			</xs:simpleType>
		</xs:attribute>
	</xs:complexType>
	<xs:complexType name="SnippetLeafTypeWithConditionalMatch">
		<xs:complexContent>
			<xs:extension base="SnippetLeafType">
				<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:simpleType name="ConditionalMatchPatternType">
		<xs:restriction base="xs:token">
			<xs:enumeration value="IsPersonal">
				<xs:annotation>
					<xs:documentation>True if the IsPersonal property for the current role player is true.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="IsPreferredIdentifier">
				<xs:annotation>
					<xs:documentation>True if the current constraint is a preferred identifier.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="BinaryWithRoleName">
				<xs:annotation>
					<xs:documentation>True if the current role is named and is playing a role within a binary fact type.</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="RolePlayerHasRefScheme">
				<xs:annotation>
					<xs:documentation>True if the current role player has a reference scheme</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="IsSingleValue">
				<xs:annotation>
					<xs:documentation>
						True if the value range collection has only one value range whose
						min value is equal to the max value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinEqualsMax">
				<xs:annotation>
					<xs:documentation>
						Matches a value range whose min value is equal to the max value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinClosedMaxUnbounded">
				<xs:annotation>
					<xs:documentation>
						Matches a value range with a closed minimum value and an unbounded maximum value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinOpenMaxUnbounded">
				<xs:annotation>
					<xs:documentation>
						Matches a value range with an open minimum value and an unbounded maximum value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinUnboundedMaxClosed">
				<xs:annotation>
					<xs:documentation>
						Matches a value range with an unbounded minimum value and a closed maximum value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinUnboundedMaxOpen">
				<xs:annotation>
					<xs:documentation>
						Matches a value range with an unbounded minimum value and an open maximum value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinClosedMaxClosed">
				<xs:annotation>
					<xs:documentation>
						Matches a value range with a closed minimum value and an open maximum value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinClosedMaxOpen">
				<xs:annotation>
					<xs:documentation>
						Matches a value range with a closed minimum value and an open maximum value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinOpenMaxClosed">
				<xs:annotation>
					<xs:documentation>
						Matches a value range with an open minimum value and an open maximum value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
			<xs:enumeration value="MinOpenMaxOpen">
				<xs:annotation>
					<xs:documentation>
						Matches a value range with an open minimum value and an open maximum value.
					</xs:documentation>
				</xs:annotation>
			</xs:enumeration>
		</xs:restriction>
	</xs:simpleType>
	<xs:complexType name="SnippetType">
		<xs:complexContent>
			<xs:extension base="SnippetLeafType">
				<xs:group ref="ReplacementElementsGroup" minOccurs="0" maxOccurs="unbounded"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:group name="ReplacementElementsGroup">
		<xs:choice>
			<xs:element name="Snippet" type="SnippetType"/>
			<xs:element name="IterateRoles" type="IterateRolesType"/>
			<xs:element name="CompositeList" type="CompositeListType"/>
			<xs:element name="Fact" type="FactType"/>
			<xs:element name="ConditionalReplacement" type="ConditionalReplacementType"/>
			<xs:element name="IterateValueRanges" type="IterateValueRangesType"/>
			<xs:element name="MinValue" type="MinValueType"/>
			<xs:element name="MaxValue" type="MaxValueType"/>
			<xs:element name="IterateContextRoles" type="IterateContextRolesType"/>
			<xs:element name="RoleName" type="RoleNameType"/>
			<xs:element name="RolePlayerRefModeScheme" type="RolePlayerRefModeSchemeType"/>
		</xs:choice>
	</xs:group>
	<xs:group name="ReplacementElementsWithConditionalMatchGroup">
		<xs:annotation>
			<xs:documentation>The elements listed in ReplacementElementsGroup with a
			conditionalMatch attribute added. Used inside the ConditionalReplacements element.</xs:documentation>
		</xs:annotation>
		<xs:choice>
			<xs:element name="Snippet" type="SnippetTypeWithConditionalMatch"/>
			<xs:element name="IterateRoles">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="IterateRolesType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="CompositeList">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="CompositeListType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="Fact">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="FactType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="ConditionalReplacement">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="ConditionalReplacementType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="IterateValueRanges">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="IterateValueRangesType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="MinValue">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="MinValueType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="MaxValue">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="MaxValueType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="IterateContextRoles">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="IterateContextRolesType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="RoleName">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="RoleNameType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
			<xs:element name="RolePlayerRefModeScheme">
				<xs:complexType>
					<xs:complexContent>
						<xs:extension base="RolePlayerRefModeSchemeType">
							<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
						</xs:extension>
					</xs:complexContent>
				</xs:complexType>
			</xs:element>
		</xs:choice>
	</xs:group>
	<xs:complexType name="SnippetTypeWithConditionalMatch">
		<xs:complexContent>
			<xs:extension base="SnippetType">
				<xs:attribute name="conditionalMatch" use="optional" type="ConditionalMatchPatternType"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="ConditionalSnippetType">
		<xs:annotation>
			<xs:documentation>
				Provides a commonly matchable pattern.  The ConditionalSnippet holds multiple potential
				Snippets with match conditions, plus a fallback snippet.  The SnippetReplacements section
				contains the replacement fields that will be used for all snippets.
			</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="1" maxOccurs="unbounded">
			<xs:element name="Snippet" type="SnippetLeafTypeWithConditionalMatch"/>
			<xs:element name="SnippetReplacements" type="SnippetReplacementsType"/>
		</xs:choice>
	</xs:complexType>
	<xs:complexType name="SnippetReplacementsType">
		<xs:annotation>
			<xs:documentation>
				Holds potential replacement fields for the conditional snippets listed above.
				There must be at least as many replacement fields here as there are in the conditional snippet
				which requires the most replacement fields.
			</xs:documentation>
		</xs:annotation>
		<xs:group ref="ReplacementElementsGroup" minOccurs="0" maxOccurs="unbounded"/>
	</xs:complexType>
	<xs:complexType name="ConditionalReplacementType">
		<xs:annotation>
			<xs:documentation>
				Provides a commonly matchable pattern similar to ConditionalSnippet.  ConditionalReplacements
				are only allowed within SnippetReplacement tags, and they allow a conditional selection of
				replacement contents for the replacement fields in the ConditionalSnippet.
			</xs:documentation>
		</xs:annotation>
		<xs:group ref="ReplacementElementsWithConditionalMatchGroup" minOccurs="1" maxOccurs="unbounded"/>
	</xs:complexType>
	<xs:complexType name="IterateValueRangesType">
		<xs:annotation>
			<xs:documentation>
				Iterates a value range collection.
			</xs:documentation>
		</xs:annotation>
		<xs:choice minOccurs="1" maxOccurs="unbounded">
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType"/>
		</xs:choice>
		<xs:attribute name="listStyle" type="ListStyleEnum"/>
	</xs:complexType>
	<xs:complexType name="MinValueType">
		<xs:annotation>
			<xs:documentation>
				Returns the minimum value of a value range constraint.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="MaxValueType">
		<xs:annotation>
			<xs:documentation>
				Returns the maximum value of a value range constraint.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="RoleNameType">
		<xs:annotation>
			<xs:documentation>
				Returns the name of a role.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="RolePlayerRefModeSchemeType">
		<xs:annotation>
			<xs:documentation>
				Returns the reference mode scheme of the attached role player.
			</xs:documentation>
		</xs:annotation>
	</xs:complexType>
	<xs:complexType name="PredicateReplacementType">
		<xs:choice minOccurs="1" maxOccurs="1">
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType"/>
			<xs:element name="Snippet" type="SnippetLeafType"/>
		</xs:choice>
		<xs:attribute name="match" use="optional" type="RoleIteratorContextMatchEnum"/>
		<xs:attribute name="pass" use="optional" type="PassEnum"/>
	</xs:complexType>
	<xs:complexType name="FactConstructType">
		<!-- Nothing here yet, this is for the top-level verbalization of a Fact -->
	</xs:complexType>
	<xs:complexType name="FactType">
		<xs:annotation>
			<xs:documentation>
				Returns the full verbalization for a fact type, i.e, Company provides Product to Company.
			</xs:documentation>
		</xs:annotation>
		<xs:sequence minOccurs="0" maxOccurs="1">
			<xs:element name="PredicateReplacement" type="PredicateReplacementType" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="readingChoice" use="optional" type="ReadingChoicePreferSingleMatchEnum"/>
	</xs:complexType>
	<xs:complexType name="IterateRolesNoListType">
		<xs:choice minOccurs="0" maxOccurs="unbounded">
			<xs:element name="Fact" type="FactType"/>
			<xs:element name="Snippet" type="SnippetType"/>
			<xs:element name="IterateContextRoles" type="IterateContextRolesType"/>
		</xs:choice>
		<xs:attribute name="match" type="IterateRolesMatchEnum" default="all"/>
		<xs:attributeGroup ref="FactArityAttributes"/>
		<xs:attribute name="pass" use="optional" type="PassEnum"/>
	</xs:complexType>
	<xs:complexType name="IterateRolesType">
		<xs:complexContent>
			<xs:extension base="IterateRolesNoListType">
				<xs:attribute name="listStyle" use="required" type="ListStyleEnumOrNull"/>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
	<xs:complexType name="IterateContextRolesType">
		<xs:group ref="ReplacementElementsGroup" minOccurs="0" maxOccurs="unbounded"/>
		<xs:attribute name="match" type="RoleIteratorContextMatchEnum" use="optional"/>
		<xs:attribute name="listStyle" type="ListStyleEnumOrNull" use="required"/>
		<xs:attribute name="pass" use="optional" type="PassEnum"/>
	</xs:complexType>
	<xs:complexType name="ReadingChoiceType">
		<xs:choice minOccurs="1" maxOccurs="unbounded">
			<xs:element name="Fact" type="FactType"/>
			<xs:element name="Snippet" type="SnippetType"/>
			<xs:element name="CompositeList" type="CompositeListType"/>
			<xs:element name="IterateRoles" type="IterateRolesType"/>
		</xs:choice>
		<xs:attribute name="match" use="optional" type="ReadingChoiceFullRequiredMatchEnum"/>
	</xs:complexType>
	<xs:complexType name="ConditionalReadingType">
		<xs:sequence>
			<xs:element name="ReadingChoice" type="ReadingChoiceType" minOccurs="2" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="CompositeListType">
		<xs:sequence>
			<xs:element name="IterateRoles" type="IterateRolesNoListType" minOccurs="1" maxOccurs="unbounded"/>
		</xs:sequence>
		<xs:attribute name="listStyle" type="ListStyleEnum" use="required"/>
	</xs:complexType>
	<xs:complexType name="LanguageType">
		<xs:sequence>
			<xs:element name="Snippets" minOccurs="1" maxOccurs="1">
				<xs:complexType>
					<xs:sequence>
						<xs:element name="Snippet" minOccurs="1" maxOccurs="unbounded">
							<xs:complexType>
								<xs:simpleContent>
									<xs:extension base="xs:string">
										<xs:attribute name="type" use="required">
											<xs:simpleType>
												<xs:union memberTypes="SnippetTypeEnum">
													<!-- Add extra elements that are reserved for use by the verbalizer -->
													<xs:simpleType>
														<xs:restriction base="xs:NMTOKEN">
															<xs:enumeration value="VerbalizerNewLine">
																<xs:annotation>
																	<xs:documentation>Used by the verbalizer to enter a new line</xs:documentation>
																</xs:annotation>
															</xs:enumeration>
															<xs:enumeration value="VerbalizerIncreaseIndent">
																<xs:annotation>
																	<xs:documentation>Used by the verbalizer to indent a child verbalization</xs:documentation>
																</xs:annotation>
															</xs:enumeration>
															<xs:enumeration value="VerbalizerDecreaseIndent">
																<xs:annotation>
																	<xs:documentation>Used by the verbalizer to close indent opened by VerbalizerIncreaseIndent</xs:documentation>
																</xs:annotation>
															</xs:enumeration>
															<xs:enumeration value="VerbalizerOpenVerbalization">
																<xs:annotation>
																	<xs:documentation>Used by the verbalizer around a single verbalization</xs:documentation>
																</xs:annotation>
															</xs:enumeration>
															<xs:enumeration value="VerbalizerCloseVerbalization">
																<xs:annotation>
																	<xs:documentation>Used by the verbalizer to close a verbalization opened by VerbalizerOpenVerbalization</xs:documentation>
																</xs:annotation>
															</xs:enumeration>
															<xs:enumeration value="VerbalizerOpenError">
																<xs:annotation>
																	<xs:documentation>Used by the verbalizer around an error section</xs:documentation>
																</xs:annotation>
															</xs:enumeration>
															<xs:enumeration value="VerbalizerCloseError">
																<xs:annotation>
																	<xs:documentation>Used by the verbalizer to close an error section</xs:documentation>
																</xs:annotation>
															</xs:enumeration>
															<xs:enumeration value="VerbalizerDocumentHeader">
																<xs:annotation>
																	<xs:documentation>
																		Used by the verbalizer to open a document. The document header gets replacement fields in the following order:
																		{0} font-family
																		{1} font-size
																		{2} predicate text color
																		{3} predicate text bold
																		{4} object name color
																		{5} object name bold
																		{6} formal item color
																		{7} formal item bold
																	</xs:documentation>
																</xs:annotation>
															</xs:enumeration>
															<xs:enumeration value="VerbalizerDocumentFooter">
																<xs:annotation>
																	<xs:documentation>Used by the verbalizer to close a document</xs:documentation>
																</xs:annotation>
															</xs:enumeration>
															<xs:enumeration value="VerbalizerFontWeightBold">
																<xs:annotation>
																	<xs:documentation>The text to insert to indicate a bold font.</xs:documentation>
																</xs:annotation>
															</xs:enumeration>
															<xs:enumeration value="VerbalizerFontWeightNormal">
																<xs:annotation>
																	<xs:documentation>The text to insert to indicate a normal font weight.</xs:documentation>
																</xs:annotation>
															</xs:enumeration>
														</xs:restriction>
													</xs:simpleType>
												</xs:union>
											</xs:simpleType>
										</xs:attribute>
										<xs:attribute name="modality" type="ModalityEnum" use="optional"/>
										<xs:attribute name="sign" type="SignEnum" use="optional"/>
									</xs:extension>
								</xs:simpleContent>
							</xs:complexType>
						</xs:element>
					</xs:sequence>
				</xs:complexType>
			</xs:element>
		</xs:sequence>
		<xs:attribute ref="xml:lang" use="required"/>
	</xs:complexType>
	<xs:complexType name="ConstraintsConstructType">
		<xs:sequence>
			<xs:element name="Constraint" type="ConstraintType" minOccurs="1" maxOccurs="unbounded">
				<xs:unique name="ConstrainedRolesFilter">
					<xs:selector xpath="ve:ConstrainedRoles"/>
					<xs:field xpath="@span"/>
					<xs:field xpath="@factArity"/>
					<xs:field xpath="@minFactArity"/>
					<xs:field xpath="@maxFactArity"/>
				</xs:unique>
			</xs:element>
		</xs:sequence>
	</xs:complexType>
	<xs:complexType name="ConstraintType">
		<xs:choice minOccurs="1" maxOccurs="unbounded">
			<xs:element name="ConstrainedRoles">
				<xs:complexType>
					<xs:choice minOccurs="1" maxOccurs="unbounded">
						<xs:element name="Snippet" type="SnippetTypeWithConditionalMatch"/>
						<xs:element name="IterateRoles" type="IterateRolesType"/>
						<xs:element name="CompositeList" type="CompositeListType"/>
						<xs:element name="ConditionalSnippet" type="ConditionalSnippetType"/>
						<xs:element name="ConditionalReading" type="ConditionalReadingType">
							<xs:unique name="ConditionalReadingReadingChoice">
								<xs:selector xpath="ve:ReadingChoice"/>
								<xs:field xpath="@match"/>
							</xs:unique>
						</xs:element>
					</xs:choice>
					<xs:attribute name="span" type="SpanEnum" use="optional"/>
					<xs:attribute name="sign" type="SignEnum" use="optional"/>
					<xs:attributeGroup ref="FactArityAttributes"/>
				</xs:complexType>
			</xs:element>
			<xs:element name="ConditionalSnippet" type="ConditionalSnippetType"/>
		</xs:choice>
		<xs:attribute name="type" type="ConstraintTypeEnum" use="required"/>
		<xs:attribute name="patternGroup" type="ConstraintPatternGroupEnum" use="required"/>
	</xs:complexType>
	<xs:element name="VerbalizationRoot">
		<xs:complexType>
			<xs:sequence>
				<xs:element name="Languages" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:sequence>
							<xs:element name="Language" type="LanguageType" minOccurs="1" maxOccurs="unbounded"/>
						</xs:sequence>
					</xs:complexType>
					<xs:key name="LanguageCodeKey">
						<xs:selector xpath="ve:Language"/>
						<xs:field xpath="@xml:lang"/>
					</xs:key>
				</xs:element>
				<xs:element name="Constructs" minOccurs="0" maxOccurs="1">
					<xs:complexType>
						<xs:all>
							<xs:element name="FactType" type="FactConstructType"/>
							<xs:element name="Constraints" type="ConstraintsConstructType"/>
						</xs:all>
					</xs:complexType>
				</xs:element>
			</xs:sequence>
		</xs:complexType>
	</xs:element>
</xs:schema>
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ModelError.Constraint.TooFewRoleSequences.Text">
    <value xml:space="preserve">Constraint '{0}' does not have enough role sequences.</value>
    <comment xml:space="preserve">Model validation error text when too few role sequences are specified for a constraint. This is a common condition when constraints are being created.</comment>
  </data>
  <data name="ModelError.Constraint.TooManyRoleSequences.Text">
    <value xml:space="preserve">Constraint '{0}' has too many role sequences.</value>
    <comment xml:space="preserve">Model validation error text when too many role sequences are specified for a constraint. This is an uncommon condition that should only occur with a hand edit to a model file.</comment>
  </data>
  <data name="ModelError.Model.DuplicateConstraintNames.Text">
    <value xml:space="preserve">Model '{0}' contains multiple constraints named '{1}'. Constraint names must be unique in the model.</value>
    <comment xml:space="preserve">Model validation error text used when multiple constraints with the same name are loaded into a model. Field 0 is the model name, field 1 is the element name.This is an uncommon condition that should only occur with a hand edit to a model file.</comment>
  </data>
  <data name="ModelError.Model.DuplicateFactTypeNames.Text">
    <value xml:space="preserve">Model '{0}' contains multiple fact types named '{1}'. Type names must be unique across all facts in a model.</value>
    <comment xml:space="preserve">Model validation error text used when multiple fact types with the same name are loaded into a model.Field 0 is the model name, field 1 is the element name.This is an uncommon condition that should only occur with a hand edit to a model file.</comment>
  </data>
  <data name="ModelError.Model.DuplicateObjectTypeNames.Text">
    <value xml:space="preserve">Model '{0}' contains multiple object types named '{1}'. Type names must be unique across all entity and value types in a model.</value>
    <comment xml:space="preserve">Model validation error text used when multiple object types with the same name are loaded into a model.Field 0 is the model name, field 1 is the element name.This is an uncommon condition that should only occur with a hand edit to a model file.</comment>
  </data>
  <data name="ModelException.Constraint.PreferredIdentifierMustBeUniquenessConstraint">
    <value xml:space="preserve">A preferred identifier must have a ConstraintType of InternalUniqueness or ExternalUniqueness.</value>
    <comment xml:space="preserve">Exception message when an attempt is made to create a preferred identifier relationship with an incompatible constraint type.</comment>
  </data>
  <data name="ModelException.Fact.AddReading.InvalidReadingText">
    <value xml:space="preserve">Reading text is not in a valid format.</value>
    <comment xml:space="preserve">Thrown when adding a reading to a fact using the AddReading with the reading text to add.</comment>
  </data>
  <data name="ModelException.FactType.EnforceRolePlayerNotNestingType">
    <value xml:space="preserve">A role player cannot be the type objectifying the role's parent fact type.</value>
    <comment xml:space="preserve">Exception message when an attempt is made to use the same type as both a role player and the nesting type of a fact type.</comment>
  </data>
  <data name="ModelException.InternalConstraint.InconsistentRoleOwners">
    <value xml:space="preserve">All roles in an internal constraint must be owned by the same fact type.</value>
    <comment xml:space="preserve">Exception message when an attempt is made to add roles from different fact types to a role sequence owned by an internal constraint.</comment>
  </data>
  <data name="ModelException.InternalUniquenessConstraint.InvalidPreferredIdentifierPreConditions">
    <value xml:space="preserve">Conditions of the uniqueness constraint, other constraints on the owning fact type, or the types of attached role players are incompatible with making it the preferred uniqueness constraint.</value>
    <comment xml:space="preserve">Exception message when an attempt is made to set an internal uniqueness constraint as a preferred identifier when the preconditions are not met.</comment>
  </data>
  <data name="ModelException.Model.DuplicateName.Text">
    <value xml:space="preserve">The name '{0}' is already in use in this model.</value>
    <comment xml:space="preserve">Exception message when a name change in the editor attempts to introduce a duplicate name into the model.</comment>
  </data>
  <data name="ModelException.ObjectType.EnforcePreferredIdentifierForUnobjectifiedEntityType">
    <value xml:space="preserve">An object type with a preferred identifier must be an unobjectified entity type.</value>
    <comment xml:space="preserve">Exception message when an attempt is made to set both a primary identifier and a value type or a nested fact type on the same object type.</comment>
  </data>
  <data name="ModelException.ObjectType.EnforceValueTypeNotNestingType">
    <value xml:space="preserve">An object type cannot be both a value type and an objectified fact type.</value>
    <comment xml:space="preserve">Exception message when an attempt is made to make an object type both a value type and an objectified fact type.</comment>
  </data>
  <data name="ModelException.Reading.IsPrimary.ReadOnlyWhenFalse">
    <value xml:space="preserve">The IsPrimary property cannot be set to false, set it to true for the new primary reading and this will occur automatically</value>
    <comment xml:space="preserve">Exception message output when an attempt is made to set the IsPrimary property of a Reading to false.</comment>
  </data>
  <data name="ModelException.Reading.Text.InvalidText">
    <value xml:space="preserve">The new value is not valid for the current state of the reading.</value>
    <comment xml:space="preserve">Exception message when a change is made to the reading text and the new value is deemed invalid by IsValidReadingText.</comment>
  </data>
  <data name="ModelException.Role.IsMandatoryRequiresAttachedFactType">
    <value xml:space="preserve">A Role must be owned by a FactType that is owned by an ORMModel to set the IsMandatory property.</value>
    <comment xml:space="preserve">Exception message when an attempt is made to set the IsMandatory property on a role of an unattached fact type. IsMandatory creates a constraint, which is owned by an ORMModel, so cannot be realized if the model is unknown.</comment>
  </data>
</root>
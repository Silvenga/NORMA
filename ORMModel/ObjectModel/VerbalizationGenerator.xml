<?xml version="1.0" encoding="utf-8" ?>
<Root xmlns="http://Schemas.Neumont.edu/ORM/SDK/Verbalization">
	<Languages>
		<Language code="en-us">
			<FormalItems>
				<FormalItem type="UniversalQuantifier">
					<Form style="Basic">each {0}</Form>
				</FormalItem>
				<FormalItem type="ImpersonalPronoun">
					<Form style="Basic">that {0}</Form>
				</FormalItem>
				<FormalItem type="AtMostOneQuantifier">
					<Form style="Basic">at most one {0}</Form>
				</FormalItem>
				<FormalItem type="EachInstanceQuantifier">
					<Form style="Basic">each instance of {0} occurs only once</Form>
				</FormalItem>
				<FormalItem type="ForEachCompactQuantifier">
					<Form style="Basic">for each {0} {1}</Form>
				</FormalItem>
				<FormalItem type="ForEachQuantifier">
					<Form style="Basic">for each {0},&#xD;&#xA;&#x9;{1}</Form>
				</FormalItem>
				<FormalItem type="ExistentialQuantifier">
					<Form style="Basic">some {0}</Form>
					<SplitForm style="Advanced">
						<Form condition="PreConsonant">a {0}</Form>
						<Form condition="PreVowel">an {0}</Form>
					</SplitForm>
				</FormalItem>
				<FormalItem type="IdentityReferenceQuantifier">
					<Form style="Basic">the same {0}</Form>
				</FormalItem>
				<FormalItem type="MoreThanOneQuantifier">
					<Form style="Basic">more than one {0}</Form>
				</FormalItem>
				<FormalItem type="ModalPossibilityOperator" modality="alethic" sign="+">
					<Form style="Basic">it is possible that {0}</Form>
				</FormalItem>
				<FormalItem type="ModalPossibilityOperator" modality="deontic" sign="+">
					<Form style="Basic">it is permitted that {0}</Form>
				</FormalItem>
				<FormalItem type="ModalPossibilityOperator" modality="alethic" sign="-">
					<Form style="Basic">it is impossible that {0}</Form>
				</FormalItem>
				<FormalItem type="ModalPossibilityOperator" modality="deontic" sign="-">
					<Form style="Basic">it is forbidden that {0}</Form>
				</FormalItem>
				<FormalItem type="ModalNecessityOperator" modality="alethic">
					<Form style="Basic">it is necessary that {0}</Form>
				</FormalItem>
				<FormalItem type="ModalNecessityOperator" modality="deontic">
					<Form style="Basic">it is obligatory that {0}</Form>
				</FormalItem>
				<FormalItem type="IndentedListOpen">
					<Form style="Basic">&#xD;&#xA;&#x9;</Form>
				</FormalItem>
				<FormalItem type="IndentedListPairSeparator">
					<Form style="Basic"> and&#xD;&#xA;&#x9;</Form>
				</FormalItem>
				<FormalItem type="IndentedListSeparator">
					<Form style="Basic"> and&#xD;&#xA;&#x9;</Form>
				</FormalItem>
				<FormalItem type="IndentedListFinalSeparator">
					<Form style="Basic"> and&#xD;&#xA;&#x9;</Form>
				</FormalItem>
				<FormalItem type="IndentedListClose">
					<Form style="Basic"></Form>
				</FormalItem>
				<FormalItem type="SimpleListOpen">
					<Form style="Basic"></Form>
				</FormalItem>
				<FormalItem type="SimpleListPairSeparator">
					<Form style="Basic"> and </Form>
				</FormalItem>
				<FormalItem type="SimpleListSeparator">
					<Form style="Basic">, </Form>
				</FormalItem>
				<FormalItem type="SimpleListFinalSeparator">
					<Form style="Basic">, and </Form>
				</FormalItem>
				<FormalItem type="SimpleListClose">
					<Form style="Basic"></Form>
				</FormalItem>
			</FormalItems>
		</Language>
	</Languages>
	<Constructs>
		<Constraints>
			<Constraint type="InternalUniquenessConstraint" patternGroup="InternalConstraint">
				<ConstrainedRoles span="all" factArity="2">
					<Quantifier type="EachInstanceQuantifier">
						<Fact/>
					</Quantifier>
					<Quantifier type="ModalPossibilityOperator">
						<IterateRoles listStyle="IndentedList">
							<!-- match="included" is not needed here because we've already filtered on span="all" -->
							<Fact readingChoice="PreferPrimaryLeadReading">
								<PredicateReplacement match="primary">
									<Quantifier type="IdentityReferenceQuantifier"/>
								</PredicateReplacement>
								<PredicateReplacement match="secondary">
									<Quantifier type="MoreThanOneQuantifier"/>
								</PredicateReplacement>
							</Fact>
						</IterateRoles>
					</Quantifier>
				</ConstrainedRoles>
				<ConstrainedRoles factArity="2">
					<ConditionalReading>
						<ReadingChoice match="RequireLeadReading">
							<Fact readingChoice="Conditional">
								<PredicateReplacement match="included">
									<Quantifier type="UniversalQuantifier"/>
								</PredicateReplacement>
								<PredicateReplacement>
									<Quantifier type="AtMostOneQuantifier"/>
								</PredicateReplacement>
							</Fact>
						</ReadingChoice>
						<ReadingChoice>
							<Quantifier type="ForEachCompactQuantifier">
								<IterateRoles listStyle="SimpleList" match="included"/>
								<Fact>
									<PredicateReplacement match="included">
										<Quantifier type="ImpersonalPronoun"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Quantifier type="AtMostOneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Quantifier>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
				<ConstrainedRoles span="all">
					<Quantifier type="EachInstanceQuantifier">
						<Fact/>
					</Quantifier>
				</ConstrainedRoles>
				<ConstrainedRoles>
					<ConditionalReading>
						<ReadingChoice match="RequireLeadReading">
							<Quantifier type="ForEachQuantifier">
								<IterateRoles listStyle="SimpleList" match="included"/>
								<Fact readingChoice="Conditional">
									<PredicateReplacement match="included">
										<Quantifier type="ImpersonalPronoun"/>
									</PredicateReplacement>
									<!-- match="excluded" is not needed here because it
										 is implied by the previous replacement.-->
									<PredicateReplacement>
										<Quantifier type="AtMostOneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Quantifier>
						</ReadingChoice>
						<ReadingChoice>
							<!-- Fallback choice -->
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			<!-- UNDONE: Temporary data for xslt testing.-->
			<!--<Constraint type="DisjunctiveMandatoryConstraint" patternGroup="SingleColumnExternalConstraint">
				--><!-- Unaries are the only reading choice that has an optional negative reading --><!--
				<ConstrainedRoles minFactArity="1" maxFactArity="1" sign="-">
					<Quantifier type="NegativeReadingForUnaryOnlyDisjuntiveMandatory">
						<IterateRolePlayers listStyle="SimpleList" match="first"/>
						<IterateRoles listStyle="CompoundList" match="singleColumnConstraintRoles">
							<Fact/>
						</IterateRoles>
					</Quantifier>
				</ConstrainedRoles>
				<ConstrainedRoles minFactArity="1" maxFactArity="2" sign="-">
					<ConditionalReading readingChoice="RequireAllPrimaryLeadReading">
						<CompositeList listStyle="IndentedOrList">
							<IterateRoles minFactArity="2" match="singleColumnConstraintRoles">
								<Fact readingChoice="RequirePrimaryLeadReading">
									<PredicateReplacement match="firstPrimary">
										<Quantifier type="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement match="primary">
										<Quantifier type="ThatQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Quantifier type="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
							<IterateRoles factArity="1" match="singleColumnConstraintRoles">
								<Fact readingChoice="RequirePrimaryLeadReading">
									<PredicateReplacement>
										<Quantifier type="ThatQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</CompositeList>
					</ConditionalReading>
					<ConditionalReading>
						<Quantifier type="ForEachQuantifier">
							<IterateRoles minFactArity="2" match="singleColumnConstraintRoles">
								<Fact readingChoice="PreferPrimaryLeadReading">
									<PredicateReplacement match="primary">
										<Quantifier type="ImpersonalQuantifier"/>
										<Quantifier type="ExistentialQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary">
										<Quantifier type="ExistentialQuantifier"/>
										<Quantifier type="ImpersonalQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
							<IterateRoles factArity="1" match="singleColumnConstraintRoles">
								<Fact/>
							</IterateRoles>
						</Quantifier>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>-->
		</Constraints>
	</Constructs>
</Root>

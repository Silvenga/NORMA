<?xml version="1.0" encoding="utf-8" ?>
<VerbalizationRoot xmlns="http://Schemas.Neumont.edu/ORM/SDK/Verbalization">
	<Languages>
		<Language xml:lang="en-US">
			<Snippets>

				<!-- All object type names are wrapped with this style automatically.
						 The objectType class should not be used in other quantifiers because
						 it will interfere with hyphen-binding and possible other features. -->
				<Snippet type="ObjectType"><![CDATA[<span class="objectType">{0}</span>]]></Snippet>
				<Snippet type="ObjectTypeWithSubscript"><![CDATA[<span class="objectType">{0}<sub>{1}</sub></span>]]></Snippet>
				<Snippet type="ObjectTypeMissing"><![CDATA[<span class="objectTypeMissing">Missing<sub>{0}</sub></span>]]></Snippet>

				<Snippet type="ImpersonalPronoun"><![CDATA[<span class="quantifier">that</span> {0}]]></Snippet>
				<Snippet type="PersonalPronoun"><![CDATA[<span class="quantifier">who</span> {0}]]></Snippet>
				
				<Snippet type="UniversalQuantifier"><![CDATA[<span class="quantifier">each</span> {0}]]></Snippet>
				<Snippet type="AtMostOneQuantifier"><![CDATA[<span class="quantifier">at most one</span> {0}]]></Snippet>
				<Snippet type="EachInstanceQuantifier"><![CDATA[<span class="quantifier">each instance of</span> {0} <span class="quantifier">occurs only once</span>]]></Snippet>
				<Snippet type="ForEachCompactQuantifier"><![CDATA[<span class="quantifier">for each</span> {0}, {1}]]></Snippet>
				<Snippet type="ForEachQuantifier"><![CDATA[<span class="quantifier">for each</span> {0},<br/><span class="smallIndent">{1}</span>]]></Snippet>
				<Snippet type="ExistentialQuantifier"><![CDATA[<span class="quantifier">some</span> {0}]]></Snippet>
					<!-- UNDONE:
						<Form condition="PreConsonant"><![CDATA[<span class="quantifier">a</span> {0}]]></Form>
						<Form condition="PreVowel"><![CDATA[<span class="quantifier">an</span> {0}]]></Form>
					-->
				<Snippet type="IdentityReferenceQuantifier"><![CDATA[<span class="quantifier">the same</span> {0}]]></Snippet>
				<Snippet type="MoreThanOneQuantifier"><![CDATA[<span class="quantifier">more than one</span> {0}]]></Snippet>

				<Snippet type="CombinationIdentifier"><![CDATA[{0} <span class="quantifier">combination</span>]]></Snippet>
				<Snippet type="OneQuantifier" sign="positive"><![CDATA[<span class="quantifier">at most one</span> {0}]]></Snippet>
				<Snippet type="OneQuantifier" sign="negative"><![CDATA[<span class="quantifier">more than one</span> {0}]]></Snippet>
			
				
				<Snippet type="OccursInPopulation" sign="positive"><![CDATA[{0} <span class="quantifier">occurs at most once in the population of</span> {1}]]></Snippet>
				<Snippet type="OccursInPopulation" sign="negative"><![CDATA[{0} <span class="quantifier">occurs more than once in the population of</span> {1}]]></Snippet>

				<Snippet type="ModalPossibilityOperator" modality="alethic" sign="positive"><![CDATA[<span class="quantifier">it is possible that</span> {0}]]></Snippet>
				<Snippet type="ModalPossibilityOperator" modality="deontic" sign="positive"><![CDATA[<span class="quantifier">it is permitted that</span> {0}]]></Snippet>
				<Snippet type="ModalPossibilityOperator" modality="alethic" sign="negative"><![CDATA[<span class="quantifier">it is impossible that</span> {0}]]></Snippet>
				<Snippet type="ModalPossibilityOperator" modality="deontic" sign="negative"><![CDATA[<span class="quantifier">it is forbidden that</span> {0}]]></Snippet>
				<Snippet type="ModalNecessityOperator" modality="alethic"><![CDATA[<span class="quantifier">it is necessary that</span> {0}]]></Snippet>
				<Snippet type="ModalNecessityOperator" modality="deontic"><![CDATA[<span class="quantifier">it is obligatory that</span> {0}]]></Snippet>
				<!-- Used inside a ModalOperator -->
				<Snippet type="NegativeReadingForUnaryOnlyDisjunctiveMandatory" sign="negative"><![CDATA[<span class="quantifier">some</span> {0} <span class="quantifier">participates in none of the following:</span>{1}]]></Snippet>

				<Snippet type="CompoundListOpen"><![CDATA[<br/><span class="smallIndent">]]></Snippet>
				<Snippet type="CompoundListPairSeparator"><![CDATA[<span class="listSeparator">; </span>]]></Snippet>
				<Snippet type="CompoundListSeparator"><![CDATA[<span class="listSeparator">; </span>]]></Snippet>
				<Snippet type="CompoundListFinalSeparator"><![CDATA[<span class="listSeparator">; </span>]]></Snippet>
				<Snippet type="CompoundListClose"><![CDATA[</span>]]></Snippet>
				<Snippet type="IndentedListOpen"><![CDATA[<br/><span class="smallIndent">]]></Snippet>
				<Snippet type="IndentedListPairSeparator"><![CDATA[<span class="listSeparator"> and </span><br/>]]></Snippet>
				<Snippet type="IndentedListSeparator"><![CDATA[<span class="listSeparator"> and </span><br/>]]></Snippet>
				<Snippet type="IndentedListFinalSeparator"><![CDATA[<span class="listSeparator"> and </span><br/>]]></Snippet>
				<Snippet type="IndentedListClose"><![CDATA[</span>]]></Snippet>
				<Snippet type="IndentedOrListOpen"><![CDATA[<span class="smallIndent">]]></Snippet>
				<Snippet type="IndentedOrListPairSeparator"><![CDATA[<br/><span class="listSeparator">or </span>]]></Snippet>
				<Snippet type="IndentedOrListSeparator"><![CDATA[<br/><span class="listSeparator">or </span>]]></Snippet>
				<Snippet type="IndentedOrListFinalSeparator"><![CDATA[<br/><span class="listSeparator">or </span>]]></Snippet>
				<Snippet type="IndentedOrListClose"><![CDATA[</span>]]></Snippet>
				<Snippet type="TopLevelIndentedOrListOpen"><![CDATA[<span>]]></Snippet>
				<Snippet type="TopLevelIndentedOrListPairSeparator"><![CDATA[</span><span class="smallIndent"><br/><span class="listSeparator">or </span>]]></Snippet>
				<Snippet type="TopLevelIndentedOrListSeparator"><![CDATA[</span><span class="smallIndent"><br/><span class="listSeparator">or </span>]]></Snippet>
				<Snippet type="TopLevelIndentedOrListFinalSeparator"><![CDATA[</span><span class="smallIndent"><br/><span class="listSeparator">or </span>]]></Snippet>
				<Snippet type="TopLevelIndentedOrListClose"><![CDATA[</span>]]></Snippet>

				<Snippet type="SimpleListOpen"><![CDATA[]]></Snippet>
				<Snippet type="SimpleListPairSeparator"><![CDATA[<span class="listSeparator"> and </span>]]></Snippet>
				<Snippet type="SimpleListSeparator"><![CDATA[<span class="listSeparator">, </span>]]></Snippet>
				<Snippet type="SimpleListFinalSeparator"><![CDATA[<span class="listSeparator">, and </span>]]></Snippet>
				<Snippet type="SimpleListClose"><![CDATA[]]></Snippet>
				<Snippet type="CompactSimpleListOpen"><![CDATA[]]></Snippet>
				<Snippet type="CompactSimpleListPairSeparator"><![CDATA[<span class="listSeparator">, </span>]]></Snippet>
				<Snippet type="CompactSimpleListSeparator"><![CDATA[<span class="listSeparator">, </span>]]></Snippet>
				<Snippet type="CompactSimpleListFinalSeparator"><![CDATA[<span class="listSeparator">, </span>]]></Snippet>
				<Snippet type="CompactSimpleListClose"><![CDATA[]]></Snippet>
				<Snippet type="CloseVerbalizationSentence"><![CDATA[<span class="listSeparator">.</span>]]></Snippet>
			</Snippets>
		</Language>
	</Languages>
	<Constructs>
		<!-- Generate FactType verbalization along with constraints -->
		<FactType/>
		<!-- Generate constraint verbalizations -->
		<Constraints>
			<Constraint type="InternalUniquenessConstraint" patternGroup="InternalConstraint">
				<ConstrainedRoles factArity="1" sign="positive">
					<!-- span='all' is implicit in the other conditions. 0 arity includedRoles is blocked. -->
					<Snippet ref="OccursInPopulation">
						<Snippet ref="UniversalQuantifier">
							<IterateRoles match="included" listStyle="SimpleList"/>
						</Snippet>
						<Fact/>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles factArity="1">
					<!-- span="all" sign="negative" is implicit in the other conditions are previous element-->
					<Snippet ref="ModalPossibilityOperator">
						<Snippet ref="OccursInPopulation">
							<Snippet ref="IdentityReferenceQuantifier">
								<IterateRoles match="included" listStyle="SimpleList"/>
							</Snippet>
							<Fact/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles span="all" sign="positive">
					<!-- UNDONE: Subscripting requirements specify on for binary, off for n-ary. Currently
						 they are always on. We need to see if there are any verbalizations where subscripts are
						 required in some places but not others before designing the xml and generating from it.
						 If subscripts are required in all places in any verbalization pattern that uses them, then
						 the following would be a potential tag for this location (we'd have subscripts off by default). -->
					<!--<EnableSubscripts minFactArity="3"/>-->
					<Snippet ref="OccursInPopulation">
						<Snippet ref="CombinationIdentifier">
							<Snippet ref="UniversalQuantifier">
								<IterateRoles match="included" listStyle="SimpleList"/>
							</Snippet>
						</Snippet>
						<Fact/>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles span="all">
					<!-- sign="negative" is implied by the previous element -->
					<Snippet ref="ModalPossibilityOperator">
						<Snippet ref="OccursInPopulation">
							<Snippet ref="CombinationIdentifier">
								<Snippet ref="IdentityReferenceQuantifier">
									<IterateRoles match="included" listStyle="CompactSimpleList"/>
								</Snippet>
							</Snippet>
							<Fact/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles factArity="2" sign="positive">
					<ConditionalReading>
						<ReadingChoice match="RequireLeadReading">
							<Fact readingChoice="Conditional">
								<PredicateReplacement match="included">
									<Snippet ref="UniversalQuantifier"/>
								</PredicateReplacement>
								<PredicateReplacement>
									<Snippet ref="OneQuantifier"/>
								</PredicateReplacement>
							</Fact>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles listStyle="SimpleList" match="included"/>
								<Fact>
									<PredicateReplacement match="included">
										<Snippet ref="ImpersonalPronoun"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="OneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
				<ConstrainedRoles factArity="2">
					<!-- sign="negative" is implied by the previous element -->
					<ConditionalReading>
						<ReadingChoice match="RequireLeadReading">
							<Snippet ref="ForEachQuantifier">
								<IterateRoles listStyle="SimpleList" match="included"/>
								<Snippet ref="ModalPossibilityOperator">
									<Fact readingChoice="Conditional">
										<PredicateReplacement match="included">
											<Snippet ref="ImpersonalPronoun"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<!-- UNDONE: Check -->
											<Snippet ref="AtMostOneQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</Snippet>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<!-- UNDONE: Fill in -->
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
				<ConstrainedRoles sign="negative">
					<Snippet ref="ModalPossibilityOperator">
						<Snippet ref="IdentityReferenceQuantifier">
							<IterateRoles match="included" listStyle="SimpleList"/>
							<Fact readingChoice="RequireLeadReading">
								<PredicateReplacement match="included">
									<Snippet ref="ImpersonalPronoun"/>
								</PredicateReplacement>
								<PredicateReplacement match="excluded">
									<Snippet ref="OneQuantifier"/>
								</PredicateReplacement>
							</Fact>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles>
					<!-- sign="positive" is implied by the previous element -->
					<Snippet ref="ForEachQuantifier">
						<IterateRoles match="included" listStyle="SimpleList"/>
						<Fact>
							<PredicateReplacement match="included">
								<Snippet ref="ImpersonalPronoun"/>
							</PredicateReplacement>
							<PredicateReplacement match="excluded">
								<Snippet ref="OneQuantifier"/>
							</PredicateReplacement>
						</Fact>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>

			<!-- Simple Mandatory Constraint -->
			<Constraint type="SimpleMandatoryConstraint" patternGroup="InternalConstraint">

				<!-- 3.1.1 unary predicate -->
				<!-- Each A R -->
				<ConstrainedRoles factArity="1">
					<Snippet ref="UniversalQuantifier">
						<Fact/>
					</Snippet>
				</ConstrainedRoles>


				<!-- 3.1.2 binary predicate -->
				<ConstrainedRoles factArity="2">
					<ConditionalReading>

						<!-- mandatory constraint starts reading relational style -->
						<!-- Each A R some B -->
						<ReadingChoice match="RequireLeadReading">
							<Fact readingChoice="Conditional">
								<PredicateReplacement match="included">
									<Snippet ref="UniversalQuantifier"/>
								</PredicateReplacement>
								<PredicateReplacement>
									<Snippet ref="ExistentialQuantifier"/>
								</PredicateReplacement>
							</Fact>
						</ReadingChoice>

						<!-- mandatory role does NOT start reading -->
						<!-- For each A, some B S that A -->
						<ReadingChoice>
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles match="included" listStyle="SimpleList"/>
								<Fact>
									<PredicateReplacement match="included">
										<Snippet ref="ImpersonalPronoun"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>

				<!-- mandatory constraint starts reading attribute style -->
				<!-- Each A R some B -->
				<!-- not doing this time around -->

				<!-- 3.1.3 n-ary predicate -->
				<ConstrainedRoles>
					<ConditionalReading>
						<!-- mandatory role starts reading -->
						<!-- Each A R some B1 ... some Bn -->
						<ReadingChoice match="RequireLeadReading">
							<Fact readingChoice="Conditional">
								<PredicateReplacement match="included">
									<Snippet ref="UniversalQuantifier"/>
								</PredicateReplacement>
								<PredicateReplacement>
									<Snippet ref="ExistentialQuantifier"/>
								</PredicateReplacement>
							</Fact>
						</ReadingChoice>

						<!-- mandatory role does NOT start reading-->
						<!-- For each A,
							some B1 R ... that A ... some Bn -->
						<ReadingChoice>
							<Snippet ref="ForEachQuantifier">
								<IterateRoles match="included" listStyle="SimpleList"/>
								<Fact>
									<PredicateReplacement match="included">
										<Snippet ref="ImpersonalPronoun"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			
			<Constraint type="DisjunctiveMandatoryConstraint" patternGroup="SingleColumnExternalConstraint">
				<!-- Unaries are the only reading choice that has an optional negative reading -->
				<ConstrainedRoles sign="negative" maxFactArity="1">
					<Snippet ref="ModalPossibilityOperator">
						<Snippet ref="NegativeReadingForUnaryOnlyDisjunctiveMandatory">
							<IterateRoles listStyle="SimpleList" match="singleColumnConstraintRoles" pass="first"/>
							<IterateRoles listStyle="CompoundList" match="singleColumnConstraintRoles">
								<Fact/>
							</IterateRoles>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles sign="positive" maxFactArity="1">
					<IterateRoles listStyle="TopLevelIndentedOrList"  match="singleColumnConstraintRoles">
						<Fact>
							<PredicateReplacement match="primary" pass="first">
								<Snippet ref="UniversalQuantifier"/>
							</PredicateReplacement>
							<PredicateReplacement match="primary">
								<Snippet ref="null"/>
							</PredicateReplacement>
						</Fact>
					</IterateRoles>
				</ConstrainedRoles>
				<ConstrainedRoles sign="positive">
					<ConditionalReading>
						<ReadingChoice match="RequireAllLeadReading">
							<CompositeList listStyle="TopLevelIndentedOrList">
								<IterateRoles minFactArity="2" match="singleColumnConstraintRoles">
									<Fact readingChoice="Conditional">
										<PredicateReplacement match="primary" pass="first">
											<Snippet ref="UniversalQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement match="primary">
											<Snippet ref="null"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
								<IterateRoles factArity="1" match="singleColumnConstraintRoles">
									<Fact readingChoice="Conditional">
										<PredicateReplacement>
											<!-- UNDONE: Needs conditional snippet catering for forward text-->
											<Snippet ref="null"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</CompositeList>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ForEachQuantifier">
								<IterateRoles match="singleColumnConstraintRoles" pass="first" listStyle="SimpleList"/>
								<CompositeList listStyle="IndentedOrList">
									<IterateRoles match="singleColumnConstraintRoles" minFactArity="2">
										<Fact readingChoice="PreferPrimaryLeadReadingNoForwardText">
											<PredicateReplacement match="included">
												<Snippet ref="ImpersonalPronoun"/>
											</PredicateReplacement>
											<PredicateReplacement match="excluded">
												<Snippet ref="ExistentialQuantifier"/>
											</PredicateReplacement>
										</Fact>
									</IterateRoles>
									<IterateRoles factArity="1" match="singleColumnConstraintRoles">
										<Fact>
											<PredicateReplacement>
												<Snippet ref="ImpersonalPronoun"/>
											</PredicateReplacement>
										</Fact>
									</IterateRoles>
								</CompositeList>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			<!-- Start External Uniqueness Constraint-->
			<Constraint type="ExternalUniquenessConstraint" patternGroup="SingleColumnExternalConstraint">
				<!-- Positive Reading -->
				<ConstrainedRoles sign="positive" minFactArity="2" maxFactArity="2">
					<ConditionalReading>
						<ReadingChoice match="RequireAllNonLeadReadingNoForwardText">
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles match="singleColumnConstraintRoles" listStyle="SimpleList" />
								<IterateRoles match="singleColumnConstraintRoles" listStyle="IndentedList">
									<Fact readingChoice="Conditional">
										<PredicateReplacement match="excluded" pass="first">
											<Snippet ref="AtMostOneQuantifier" />
										</PredicateReplacement>
										<PredicateReplacement match="excluded">
											<Snippet ref="null" />
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ImpersonalPronoun" />
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
				<!-- Negative Reading for External Uniqueness Constraint-->
				<ConstrainedRoles sign="negative" minFactArity="2" maxFactArity="2">
					<ConditionalReading>
						<ReadingChoice match="RequireAllNonLeadReadingNoForwardText">
							<Snippet ref="ModalPossibilityOperator">
								<IterateRoles match="singleColumnConstraintRoles" listStyle="SimpleList">
									<Fact readingChoice="Conditional">
										<PredicateReplacement match="excluded" pass="first">
											<Snippet ref="MoreThanOneQuantifier" />
										</PredicateReplacement>
										<PredicateReplacement match="excluded">
											<Snippet ref="null" />
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="IdentityReferenceQuantifier" />
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			<!-- End External Uniqueness Constraint  -->
		</Constraints>
	</Constructs>
</VerbalizationRoot>

<?xml version="1.0" encoding="utf-8"?>
<VerbalizationRoot
	xmlns="http://schemas.neumont.edu/ORM/SDK/CoreVerbalizationGenerator"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://schemas.neumont.edu/ORM/SDK/CoreVerbalizationGenerator VerbalizationGenerator.xsd"
	snippetsLocation="VerbalizationCoreSnippets/VerbalizationCoreSnippets.xml">
	<Copyright name="Common Public License Copyright Notice">
		Neumont Object-Role Modeling Architect for Visual Studio

		Copyright © Neumont University. All rights reserved.

		The use and distribution terms for this software are covered by the
		Common Public License 1.0 (http://opensource.org/licenses/cpl) which
		can be found in the file CPL.txt at the root of this distribution.
		By using this software in any fashion, you are agreeing to be bound by
		the terms of this license.

		You must not remove this notice, or any other, from this software.
	</Copyright>
	<Constructs>
		<!-- Generate FactType verbalization along with constraints -->
		<FactType/>
		<!-- Generate ObjectType verbalization along with constraints -->
		<ObjectType>
			<ConditionalSnippet>
				<Snippet ref="EntityTypeVerbalization" conditionalMatch="IsEntityType"/>
				<Snippet ref="ValueTypeVerbalization"/>
				<SnippetReplacements>
					<Snippet ref="ObjectType">
						<ObjectTypeName/>
					</Snippet>
				</SnippetReplacements>
			</ConditionalSnippet>
			<Snippet ref="ObjectifiesFactTypeVerbalization" conditionalMatch="IsObjectifiedFactType" conditionalBlockContext="ObjectifiedFactType">
				<Snippet ref="ObjectType">
					<ObjectTypeName/>
				</Snippet>
				<Fact/>
			</Snippet>
			<Snippet ref="ReferenceSchemeVerbalization" conditionalMatch="HasPreferredIdentifier">
				<IterateRoles match="preferredIdentifier" listStyle="CompoundList">
					<Fact/>
				</IterateRoles>
			</Snippet>
			<Snippet ref="ReferenceModeVerbalization" conditionalMatch="HasReferenceMode">
				<ReferenceMode/>
			</Snippet>
			<Snippet ref="IndependentVerbalization" conditionalMatch="IsIndependent">
				<Snippet ref="ObjectType">
					<ObjectTypeName/>
				</Snippet>
			</Snippet>
			<Snippet ref="PortableDataTypeVerbalization" conditionalMatch="HasPortableDataType">
				<PortableDataType/>
			</Snippet>
		</ObjectType>
		<Note>
			<Snippet ref="NotesVerbalization">
				<NoteText/>
			</Snippet>
		</Note>
		<!-- Generate constraint verbalizations -->
		<Constraints>
			<!-- Implied single-role internal uniqueness constraint on proxy role of implied binary fact -->
			<Constraint type="ImpliedUniqueVerbalizer" childHelperFor="FactType" patternGroup="InternalConstraint">
				<ConstrainedRoles constraintArity="1" factArity="2" sign="positive">
					<ConditionalReading>
						<ReadingChoice match="RequireLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="OneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles listStyle="SimpleList" match="included" hyphenBind="true"/>
								<Snippet ref="ImpliedModalNecessityOperator">
									<Fact>
										<PredicateReplacement match="included">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="OneQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
					<Snippet ref="ConstraintProvidesPreferredIdentifier" conditionalMatch="IsPreferredIdentifier">
						<IterateRoles listStyle="null" match="included"/>
						<IterateRoles listStyle="null" match="excluded"/>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles constraintArity="1" factArity="2">
					<!-- sign="negative" is implied by the previous element -->
					<!-- The pattern is the same whether or not we have a lead reading, so don't use ConditionalReading here -->
					<ReadingContext match="PreferLeadReading">
						<Snippet ref="ForEachCompactQuantifier">
							<IterateRoles match="included" listStyle="CompactSimpleList" hyphenBind="true"/>
							<Snippet ref="ModalPossibilityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="excluded">
										<Snippet ref="OneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</Snippet>
					</ReadingContext>
				</ConstrainedRoles>
			</Constraint>
			<!-- Implied simple mandatory on constraint on proxy role of implied binary fact -->
			<Constraint type="ImpliedMandatoryVerbalizer" childHelperFor="FactType" patternGroup="InternalConstraint">
				<!-- 3.1.2 binary predicate -->
				<ConstrainedRoles factArity="2">
					<ConditionalReading>

						<!-- mandatory constraint starts reading relational style -->
						<!-- Each A R some B -->
						<ReadingChoice match="RequireLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>

						<!-- mandatory role does NOT start reading -->
						<!-- For each A, some B S that A -->
						<ReadingChoice>
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles match="included" listStyle="SimpleList" hyphenBind="true"/>
								<Snippet ref="ImpliedModalNecessityOperator">
									<Fact>
										<PredicateReplacement match="included">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			<!-- FactType.DefaultBinaryMissingUniquenessVerbalizer -->
			<Constraint type="DefaultBinaryMissingUniquenessVerbalizer" childHelperFor="FactType" patternGroup="InternalConstraint">
				<!-- The context here is an alethic constraint covering the opposite single role -->
				<ConstrainedRoles factArity="2" sign="positive">
					<Snippet ref="ModalPossibilityOperator">
						<Fact readingChoice="PreferNonLeadReading">
							<PredicateReplacement match="included">
								<Snippet ref="MoreThanOneQuantifier"/>
							</PredicateReplacement>
							<PredicateReplacement>
								<Snippet ref="IdentityReferenceQuantifier"/>
							</PredicateReplacement>
						</Fact>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<!-- FactType.CombinedMandatoryUniqueVerbalizer -->
			<Constraint type="CombinedMandatoryUniqueVerbalizer" childHelperFor="FactType" patternGroup="InternalConstraint">
				<!-- 3.1.2 binary predicate -->
				<ConstrainedRoles factArity="2" sign="positive">
					<ConditionalReading>

						<!-- mandatory constraint starts reading relational style -->
						<!-- Each A R some B -->
						<ReadingChoice match="RequireLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExactlyOneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>

						<!-- mandatory role does NOT start reading -->
						<!-- For each A, some B S that A -->
						<ReadingChoice>
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles match="included" listStyle="SimpleList" hyphenBind="true"/>
								<Snippet ref="ImpliedModalNecessityOperator">
									<Fact>
										<PredicateReplacement match="included">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExactlyOneQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="MandatoryConstraint" patternGroup="SetConstraint">
				<!-- Handle internal constraint patterns first -->
				<!-- 3.1.1 unary predicate -->
				<!-- Each A R -->
				<ConstrainedRoles constraintArity="1" factArity="1" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="UniversalQuantifier">
							<Fact/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>

				<!-- 3.1.2 binary predicate -->
				<ConstrainedRoles constraintArity="1" factArity="2" maxFactArity="2">
					<ConditionalReading>

						<!-- mandatory constraint starts reading relational style -->
						<!-- Each A R some B -->
						<ReadingChoice match="RequireLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>

						<!-- mandatory role does NOT start reading -->
						<!-- For each A, some B S that A -->
						<ReadingChoice>
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles match="included" listStyle="SimpleList" hyphenBind="true"/>
								<Snippet ref="ImpliedModalNecessityOperator">
									<Fact>
										<PredicateReplacement match="included">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>

				<!-- mandatory constraint starts reading attribute style -->
				<!-- Each A R some B -->
				<!-- not doing this time around -->

				<!-- 3.1.3 n-ary predicate -->
				<ConstrainedRoles constraintArity="1" minFactArity="3">
					<ConditionalReading>
						<!-- mandatory role starts reading -->
						<!-- Each A R some B1 ... some Bn -->
						<ReadingChoice match="RequireLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>

						<!-- mandatory role does NOT start reading-->
						<!-- For each A,
							some B1 R ... that A ... some Bn -->
						<ReadingChoice>
							<Snippet ref="ForEachQuantifier">
								<IterateRoles match="included" listStyle="SimpleList" hyphenBind="true"/>
								<Snippet ref="ImpliedModalNecessityOperator">
									<Fact>
										<PredicateReplacement match="included">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>

				<!-- Start disjunctive mandatory constraints -->
				<!-- Unaries are the only reading choice that has an optional negative reading -->
				<ConstrainedRoles sign="negative" maxFactArity="1">
					<Snippet ref="ModalPossibilityOperator">
						<Snippet ref="NegativeReadingForUnaryOnlyDisjunctiveMandatory">
							<IterateRoles listStyle="SimpleList" match="setConstraintRoles" pass="first"/>
							<IterateRoles listStyle="IndentedCompoundList" match="setConstraintRoles">
								<Fact/>
							</IterateRoles>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles sign="positive" maxFactArity="1">
					<IterateRoles listStyle="TopLevelIndentedLogicalOrList"  match="setConstraintRoles">
						<Fact>
							<PredicateReplacement match="primary" pass="first">
								<Snippet ref="UniversalQuantifier"/>
							</PredicateReplacement>
							<PredicateReplacement match="primary">
								<Snippet ref="null"/>
							</PredicateReplacement>
						</Fact>
					</IterateRoles>
				</ConstrainedRoles>
				<ConstrainedRoles sign="positive">
					<ConditionalReading>
						<ReadingChoice match="RequireAllLeadReading">
							<CompositeList listStyle="TopLevelIndentedLogicalOrList">
								<IterateRoles minFactArity="2" match="setConstraintRoles">
									<Fact readingChoice="Context">
										<PredicateReplacement match="primary" pass="first">
											<Snippet ref="UniversalQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement match="primary">
											<Snippet ref="null"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
								<IterateRoles factArity="1" match="setConstraintRoles">
									<Fact readingChoice="Context">
										<PredicateReplacement>
											<!-- UNDONE: Needs conditional snippet catering for forward text-->
											<Snippet ref="null"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</CompositeList>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ForEachQuantifier">
								<IterateRoles match="setConstraintRoles" pass="first" listStyle="SimpleList"/>
								<CompositeList listStyle="IndentedLogicalOrList">
									<IterateRoles match="setConstraintRoles" minFactArity="2">
										<Fact readingChoice="PreferPrimaryLeadReadingNoForwardText">
											<PredicateReplacement match="included">
												<Snippet ref="DefiniteArticle"/>
											</PredicateReplacement>
											<PredicateReplacement match="excluded">
												<Snippet ref="ExistentialQuantifier"/>
											</PredicateReplacement>
										</Fact>
									</IterateRoles>
									<IterateRoles factArity="1" match="setConstraintRoles">
										<Fact>
											<PredicateReplacement>
												<Snippet ref="DefiniteArticle"/>
											</PredicateReplacement>
										</Fact>
									</IterateRoles>
								</CompositeList>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			<!-- Start Uniqueness Constraint-->
			<Constraint type="UniquenessConstraint" patternGroup="SetConstraint">
				<!-- Internal constraints -->
				<ConstrainedRoles factCount="1" factArity="1" sign="positive">
					<!-- span='all' is implicit in the other conditions. 0 arity includedRoles is blocked. -->
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="OccursInPopulation">
							<Snippet ref="UniversalQuantifier">
								<IterateRoles match="included" listStyle="SimpleList"/>
							</Snippet>
							<Fact/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1" factArity="1">
					<!-- span="all" sign="negative" is implicit in the other conditions are previous element-->
					<ReadingContext>
						<Snippet ref="ModalPossibilityOperator">
							<Snippet ref="OccursInPopulation">
								<Snippet ref="IdentityReferenceQuantifier">
									<IterateRoles match="included" listStyle="SimpleList" hyphenBind="true"/>
								</Snippet>
								<Fact readingChoice="Context"/>
							</Snippet>
						</Snippet>
					</ReadingContext>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1" span="all" sign="positive">
					<!-- UNDONE: Subscripting requirements specify on for binary, off for n-ary. Currently
						 they are always on. We need to see if there are any verbalizations where subscripts are
						 required in some places but not others before designing the xml and generating from it.
						 If subscripts are required in all places in any verbalization pattern that uses them, then
						 the following would be a potential tag for this location (we'd have subscripts off by default). -->
					<!--<EnableSubscripts minFactArity="3"/>-->
					<Snippet ref="ModalPossibilityOperator">
						<IterateRoles listStyle="TopLevelIndentedLogicalAndList">
							<Fact readingChoice="PreferPrimaryLeadReading">
								<PredicateReplacement match="primary">
									<Snippet ref="MoreThanOneQuantifier"/>
								</PredicateReplacement>
								<PredicateReplacement>
									<Snippet ref="IdentityReferenceQuantifier"/>
								</PredicateReplacement>
							</Fact>
						</IterateRoles>
					</Snippet>
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="OccursInPopulation">
							<Snippet ref="CombinationIdentifier">
								<Snippet ref="UniversalQuantifier">
									<IterateRoles match="included" listStyle="CompactSimpleList"/>
								</Snippet>
							</Snippet>
							<Fact/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1" span="all">
					<!-- sign="negative" is implied by the previous element -->
					<ReadingContext>
						<Snippet ref="ModalPossibilityOperator">
							<Snippet ref="OccursInPopulation">
								<Snippet ref="CombinationIdentifier">
									<Snippet ref="IdentityReferenceQuantifier">
										<IterateRoles match="included" listStyle="CompactSimpleList" hyphenBind="true"/>
									</Snippet>
								</Snippet>
								<Fact readingChoice="Context"/>
							</Snippet>
						</Snippet>
					</ReadingContext>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1" factArity="2" sign="positive">
					<ConditionalReading>
						<ReadingChoice match="RequireLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="OneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles listStyle="SimpleList" match="included" hyphenBind="true"/>
								<Snippet ref="ImpliedModalNecessityOperator">
									<Fact>
										<PredicateReplacement match="included">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="OneQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
					<Snippet ref="ConstraintProvidesPreferredIdentifier" conditionalMatch="IsPreferredIdentifier">
						<IterateRoles listStyle="null" match="included"/>
						<IterateRoles listStyle="null" match="excluded"/>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1" factArity="2">
					<!-- sign="negative" is implied by the previous element -->
					<!-- The pattern is the same whether or not we have a lead reading, so don't use ConditionalReading here -->
					<ReadingContext match="PreferLeadReading">
						<Snippet ref="ForEachCompactQuantifier">
							<IterateRoles match="included" listStyle="CompactSimpleList" hyphenBind="true"/>
							<Snippet ref="ModalPossibilityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="excluded">
										<Snippet ref="OneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</Snippet>
					</ReadingContext>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1" sign="negative">
					<Snippet ref="ModalPossibilityOperator">
						<Fact>
							<PredicateReplacement match="included">
								<Snippet ref="IdentityReferenceQuantifier"/>
							</PredicateReplacement>
							<PredicateReplacement>
								<Snippet ref="MoreThanOneQuantifier"/>
							</PredicateReplacement>
						</Fact>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1">
					<!-- sign="positive" is implied by the previous element -->
					<ReadingContext>
						<Snippet ref="ForEachQuantifier">
							<IterateRoles match="included" listStyle="SimpleList" hyphenBind="true"/>
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="excluded">
										<Snippet ref="OneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</Snippet>
					</ReadingContext>
				</ConstrainedRoles>

				<!-- External constraints -->
				<!-- Positive Reading -->
				<ConstrainedRoles sign="positive" minFactArity="2" maxFactArity="2">
					<ConditionalReading>
						<ReadingChoice match="RequireAllNonLeadReadingNoForwardText">
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles match="setConstraintRoles" listStyle="SimpleList" />
								<IterateRoles match="setConstraintRoles" listStyle="IndentedList">
									<Fact readingChoice="Context">
										<PredicateReplacement match="excluded" pass="first">
											<Snippet ref="AtMostOneQuantifier" />
										</PredicateReplacement>
										<PredicateReplacement match="excluded">
											<Snippet ref="null" />
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
				<!-- Negative Reading for External Uniqueness Constraint-->
				<ConstrainedRoles sign="negative" minFactArity="2" maxFactArity="2">
					<ConditionalReading>
						<ReadingChoice match="RequireAllNonLeadReadingNoForwardText">
							<Snippet ref="ModalPossibilityOperator">
								<IterateRoles match="setConstraintRoles" listStyle="SimpleList">
									<Fact readingChoice="Context">
										<PredicateReplacement match="excluded" pass="first">
											<Snippet ref="MoreThanOneQuantifier" />
										</PredicateReplacement>
										<PredicateReplacement match="excluded">
											<Snippet ref="null" />
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="IdentityReferenceQuantifier" />
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			<!-- End Uniqueness Constraint  -->
			<!-- Begin Role Value Constraint -->
			<Constraint patternGroup="RoleValueConstraint" type="RoleValueConstraint">
				<ConditionalSnippet>
					<!-- Determine whether the range is degenerate. -->
					<Snippet ref="SingleValueValueConstraint" conditionalMatch="IsSingleValue"/>
					<Snippet ref="MultiValueValueConstraint"/>
					<SnippetReplacements>
						<ConditionalReplacement>
							<!-- BinaryWithRoleName matches this pattern: The values of [OpposingRolePlayerName.]roleName[(RolePlayerRefMode)] are value-spec. -->
							<IterateRoles match="included" listStyle="null" conditionalMatch="BinaryWithRoleName">
								<Snippet ref="PeriodDelimiter">
									<IterateContextRoles match="excluded" listStyle="null">
										<RolePlayer/>
									</IterateContextRoles>
									<ConditionalReplacement>
										<Snippet ref="NameWithRefMode" conditionalMatch="RolePlayerHasRefScheme">
											<RoleName/>
											<RolePlayerRefModeScheme/>
										</Snippet>
										<Snippet ref="SelfReference">
											<RoleName/>
										</Snippet>
									</ConditionalReplacement>
								</Snippet>
							</IterateRoles>
							<!-- The fallback pattern is: The values of RolePlayer[sub] in Full Fact Verbalization are value-spec. -->
							<Snippet ref="InSeparator">
								<IterateRoles match="included" listStyle="null"/>
								<Fact/>
							</Snippet>
						</ConditionalReplacement>
						<IterateValueRanges listStyle="CompactSimpleList">
							<ConditionalSnippet>
								<!-- Match one of the nine possible value range patterns.  MinUnboundedMaxUnbounded is not a valid value range pattern. -->
								<Snippet ref="SelfReference" conditionalMatch="MinEqualsMax"/>
								<Snippet ref="MinClosedMaxUnbounded" conditionalMatch="MinClosedMaxUnbounded"/>
								<Snippet ref="MinOpenMaxUnbounded" conditionalMatch="MinOpenMaxUnbounded"/>
								<Snippet ref="MinUnboundedMaxClosed" conditionalMatch="MinUnboundedMaxClosed"/>
								<Snippet ref="MinUnboundedMaxOpen" conditionalMatch="MinUnboundedMaxOpen"/>
								<Snippet ref="MinClosedMaxClosed" conditionalMatch="MinClosedMaxClosed"/>
								<Snippet ref="MinClosedMaxOpen" conditionalMatch="MinClosedMaxOpen"/>
								<Snippet ref="MinOpenMaxClosed" conditionalMatch="MinOpenMaxClosed"/>
								<Snippet ref="MinOpenMaxOpen" conditionalMatch="MinOpenMaxOpen"/>
								<SnippetReplacements>
									<MinValue/>
									<MaxValue/>
								</SnippetReplacements>
							</ConditionalSnippet>
						</IterateValueRanges>
					</SnippetReplacements>
				</ConditionalSnippet>
			</Constraint>
			<!-- End Role Value Constraint-->
			<!-- Begin Value Type Value Constraint -->
			<Constraint patternGroup="ValueTypeValueConstraint" type="ValueTypeValueConstraint">
				<ConditionalSnippet>
					<!-- Determine whether the range is degenerate. -->
					<Snippet ref="SingleValueValueConstraint" conditionalMatch="IsSingleValue"/>
					<Snippet ref="MultiValueValueConstraint"/>
					<SnippetReplacements>
						<Snippet ref="ObjectType">
							<ValueRangeValueTypeName/>
						</Snippet>
						<IterateValueRanges listStyle="CompactSimpleList">
							<ConditionalSnippet>
								<!-- Match one of the nine possible value range patterns.  MinUnboundedMaxUnbounded is not a valid value range pattern. -->
								<Snippet ref="SelfReference" conditionalMatch="MinEqualsMax"/>
								<Snippet ref="MinClosedMaxUnbounded" conditionalMatch="MinClosedMaxUnbounded"/>
								<Snippet ref="MinOpenMaxUnbounded" conditionalMatch="MinOpenMaxUnbounded"/>
								<Snippet ref="MinUnboundedMaxClosed" conditionalMatch="MinUnboundedMaxClosed"/>
								<Snippet ref="MinUnboundedMaxOpen" conditionalMatch="MinUnboundedMaxOpen"/>
								<Snippet ref="MinClosedMaxClosed" conditionalMatch="MinClosedMaxClosed"/>
								<Snippet ref="MinClosedMaxOpen" conditionalMatch="MinClosedMaxOpen"/>
								<Snippet ref="MinOpenMaxClosed" conditionalMatch="MinOpenMaxClosed"/>
								<Snippet ref="MinOpenMaxOpen" conditionalMatch="MinOpenMaxOpen"/>
								<SnippetReplacements>
									<MinValue/>
									<MaxValue/>
								</SnippetReplacements>
							</ConditionalSnippet>
						</IterateValueRanges>
					</SnippetReplacements>
				</ConditionalSnippet>
			</Constraint>
			<!-- End Value Type Value Constraint-->
		</Constraints>
	</Constructs>
</VerbalizationRoot>

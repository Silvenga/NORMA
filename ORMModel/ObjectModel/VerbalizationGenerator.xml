<?xml version="1.0" encoding="utf-8" ?>
<Root xmlns="http://Schemas.Neumont.edu/ORM/SDK/Verbalization">
	<Languages>
		<Language code="en-us">
			<FormalItems>
				<FormalItem type="UniversalQuantifier">
					<Form style="Basic"><![CDATA[<span class="quantifier">each</span> <span class="objectType">{0}</span>]]></Form>
				</FormalItem>
				<FormalItem type="ImpersonalPronoun">
					<Form style="Basic"><![CDATA[<span class="quantifier">that</span> <span class="objectType">{0}</span>]]>that {0}</Form>
				</FormalItem>
				<FormalItem type="AtMostOneQuantifier">
					<Form style="Basic"><![CDATA[<span class="quantifier">at most one</span> <span class="objectType">{0}</span>]]></Form>
				</FormalItem>
				<FormalItem type="EachInstanceQuantifier">
					<Form style="Basic"><![CDATA[<span class="quantifier">each instance of</span> {0} <span class="quantifier">occurs only once</span>]]></Form>
				</FormalItem>
				<FormalItem type="ForEachCompactQuantifier">
					<Form style="Basic"><![CDATA[<span class="quantifier">for each</span> <span class="objectType">{0}</span> <span class="objectType">{1}</span>]]></Form>
				</FormalItem>
				<FormalItem type="ForEachQuantifier">
					<Form style="Basic"><![CDATA[<span class="quantifier">for each</span> <span class="objectType">{0}</span>,&#xD;&#xA;&#x9;<span class="objectType">{1}</span>]]></Form>
				</FormalItem>
				<FormalItem type="ExistentialQuantifier">
					<Form style="Basic"><![CDATA[<span class="quantifier">some</span> <span class="objectType">{0}</span>]]></Form>
					<SplitForm style="Advanced">
						<Form condition="PreConsonant"><![CDATA[<span class="quantifier">a</span> <span class="objectType">{0}</span>]]></Form>
						<Form condition="PreVowel"><![CDATA[<span class="quantifier">an</span> <span class="objectType">{0}</span>]]></Form>
					</SplitForm>
				</FormalItem>
				<FormalItem type="IdentityReferenceQuantifier">
					<Form style="Basic"><![CDATA[<span class="quantifier">the same</span> <span class="objectType">{0}</span>]]></Form>
				</FormalItem>
				<FormalItem type="MoreThanOneQuantifier">
					<Form style="Basic"><![CDATA[<span class="quantifier">more than one</span> <span class="objectType">{0}</span>]]></Form>
				</FormalItem>
				<FormalItem type="ModalPossibilityOperator" modality="alethic" sign="+">
					<Form style="Basic"><![CDATA[<span class="quantifier">it is possible that</span> {0}]]></Form>
				</FormalItem>
				<FormalItem type="ModalPossibilityOperator" modality="deontic" sign="+">
					<Form style="Basic"><![CDATA[<span class="quantifier">it is permitted that</span> {0}]]></Form>
				</FormalItem>
				<FormalItem type="ModalPossibilityOperator" modality="alethic" sign="-">
					<Form style="Basic"><![CDATA[<span class="quantifier">it is impossible that</span> {0}]]></Form>
				</FormalItem>
				<FormalItem type="ModalPossibilityOperator" modality="deontic" sign="-">
					<Form style="Basic"><![CDATA[<span class="quantifier">it is forbidden that</span> {0}]]></Form>
				</FormalItem>
				<FormalItem type="ModalNecessityOperator" modality="alethic">
					<Form style="Basic"><![CDATA[<span class="quantifier">it is necessary that</span> {0}]]></Form>
				</FormalItem>
				<FormalItem type="ModalNecessityOperator" modality="deontic">
					<Form style="Basic"><![CDATA[<span class="quantifier">it is obligatory that</span> {0}]]></Form>
				</FormalItem>
				<FormalItem type="NegativeReadingForUnaryOnlyDisjunctiveMandatory" modality="deontic" sign="-">
					<Form style="Basic"><![CDATA[<span class="quantifier">It is permitted that some</span> <span class="objectType">{0}</span> <span class="quantifier">participates in none of the following:</span>{1}]]></Form>
				</FormalItem>
				<FormalItem type="CompoundListOpen">
					<Form style="Basic">&#xD;&#xA;&#x9;</Form>
				</FormalItem>
				<FormalItem type="CompoundListPairSeparator">
					<Form style="Basic">; </Form>
				</FormalItem>
				<FormalItem type="CompoundListSeparator">
					<Form style="Basic">; </Form>
				</FormalItem>
				<FormalItem type="CompoundListFinalSeparator">
					<Form style="Basic">; </Form>
				</FormalItem>
				<FormalItem type="CompoundListClose">
					<Form style="Basic"></Form>
				</FormalItem>
				<FormalItem type="IndentedListOpen">
					<Form style="Basic"><![CDATA[<br><span style="left:15px;position:relative">]]></Form>
					<!--<Form style="Basic">&#xD;&#xA;&#x9;</Form>-->
				</FormalItem>
				<FormalItem type="IndentedListPairSeparator">
					<Form style="Basic"><![CDATA[<b> and</b> </span><br><span style="left:15px;position:relative">]]></Form>
					<!--<Form style="Basic"> and&#xD;&#xA;&#x9;</Form>-->
				</FormalItem>
				<FormalItem type="IndentedListSeparator">
					<Form style="Basic"><![CDATA[<b> and</b> </span><br><span style="left:15px;position:relative">]]></Form>
					<!--<Form style="Basic"> and&#xD;&#xA;&#x9;</Form>-->
				</FormalItem>
				<FormalItem type="IndentedListFinalSeparator">
					<Form style="Basic"><![CDATA[<b> and</b> </span><br><span style="left:15px;position:relative">]]></Form>
					<!--<Form style="Basic"> and&#xD;&#xA;&#x9;</Form>-->
				</FormalItem>
				<FormalItem type="IndentedListClose">
					<Form style="Basic"><![CDATA[</span>]]></Form>
					<!--<Form style="Basic"></Form>-->
				</FormalItem>
				<FormalItem type="IndentedOrListOpen">
					<Form style="Basic">&#xD;&#xA;&#x9;</Form>
				</FormalItem>
				<FormalItem type="IndentedOrListPairSeparator">
					<Form style="Basic"> or&#xD;&#xA;&#x9;</Form>
				</FormalItem>
				<FormalItem type="IndentedOrListSeparator">
					<Form style="Basic"> or&#xD;&#xA;&#x9;</Form>
				</FormalItem>
				<FormalItem type="IndentedOrListFinalSeparator">
					<Form style="Basic"> or&#xD;&#xA;&#x9;</Form>
				</FormalItem>
				<FormalItem type="IndentedOrListClose">
					<Form style="Basic"></Form>
				</FormalItem>
				<FormalItem type="SimpleListOpen">
					<Form style="Basic"></Form>
				</FormalItem>
				<FormalItem type="SimpleListPairSeparator">
					<Form style="Basic"> and </Form>
				</FormalItem>
				<FormalItem type="SimpleListSeparator">
					<Form style="Basic">, </Form>
				</FormalItem>
				<FormalItem type="SimpleListFinalSeparator">
					<Form style="Basic">, and </Form>
				</FormalItem>
				<FormalItem type="SimpleListClose">
					<Form style="Basic"></Form>
				</FormalItem>
			</FormalItems>
		</Language>
	</Languages>
	<Constructs>
		<Constraints>
			<Constraint type="InternalUniquenessConstraint" patternGroup="InternalConstraint">
				<ConstrainedRoles span="all" factArity="2">
					<Quantifier type="EachInstanceQuantifier">
						<Fact/>
					</Quantifier>
					<Quantifier type="ModalPossibilityOperator">
						<IterateRoles listStyle="IndentedList">
							<!-- match="included" is not needed here because we've already filtered on span="all" -->
							<Fact readingChoice="PreferPrimaryLeadReading">
								<PredicateReplacement match="primary">
									<Quantifier type="IdentityReferenceQuantifier"/>
								</PredicateReplacement>
								<PredicateReplacement match="secondary">
									<Quantifier type="MoreThanOneQuantifier"/>
								</PredicateReplacement>
							</Fact>
						</IterateRoles>
					</Quantifier>
				</ConstrainedRoles>
				<ConstrainedRoles factArity="2">
					<ConditionalReading>
						<ReadingChoice match="RequireLeadReading">
							<Fact readingChoice="Conditional">
								<PredicateReplacement match="included">
									<Quantifier type="UniversalQuantifier"/>
								</PredicateReplacement>
								<PredicateReplacement>
									<Quantifier type="AtMostOneQuantifier"/>
								</PredicateReplacement>
							</Fact>
						</ReadingChoice>
						<ReadingChoice>
							<Quantifier type="ForEachCompactQuantifier">
								<IterateRoles listStyle="SimpleList" match="included"/>
								<Fact>
									<PredicateReplacement match="included">
										<Quantifier type="ImpersonalPronoun"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Quantifier type="AtMostOneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Quantifier>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
				<ConstrainedRoles span="all">
					<Quantifier type="EachInstanceQuantifier">
						<Fact/>
					</Quantifier>
				</ConstrainedRoles>
				<ConstrainedRoles>
					<ConditionalReading>
						<ReadingChoice match="RequireLeadReading">
							<Quantifier type="ForEachQuantifier">
								<IterateRoles listStyle="SimpleList" match="included"/>
								<Fact readingChoice="Conditional">
									<PredicateReplacement match="included">
										<Quantifier type="ImpersonalPronoun"/>
									</PredicateReplacement>
									<!-- match="excluded" is not needed here because it
										 is implied by the previous replacement.-->
									<PredicateReplacement>
										<Quantifier type="AtMostOneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Quantifier>
						</ReadingChoice>
						<ReadingChoice>
							<!-- Fallback choice -->
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			
			<!-- Simple Mandatory Constraint -->
			<Constraint type="SimpleMandatoryConstraint" patternGroup="SimpleConstraint">

				<!-- 3.1.1 unary predicate -->
				<!-- Each A R -->
				<ConstrainedRoles factArity="1">
					<Quantifier type="UniversalQuantifier">
						<Fact/>
					</Quantifier>
				</ConstrainedRoles>


				<!-- 3.1.2 binary predicate -->
				<ConstrainedRoles factArity="2">
					<ConditionalReading>

						<!-- mandatory constraint starts reading relational style -->
						<!-- Each A R some B -->
						<ReadingChoice match="RequireLeadReading">
							<Fact readingChoice="Conditional">
								<PredicateReplacement match="included">
									<Quantifier type="UniversalQuantifier"/>
								</PredicateReplacement>
								<PredicateReplacement>
									<Quantifier type="ExistentialQuantifier"/>
								</PredicateReplacement>
							</Fact>
						</ReadingChoice>

						<!-- mandatory role does NOT start reading -->
						<!-- For each A, some B S that A -->
						<ReadingChoice>
							<Quantifier type="ForEachCompactQuantifier">
								<Fact readingChoice="Conditional">
									<PredicateReplacement match="excluded">
										<Quantifier type="ExistentialQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Quantifier type="ImpersonalPronoun"/>
									</PredicateReplacement>
								</Fact>
							</Quantifier>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>

				<!-- mandatory constraint starts reading attribute style -->
				<!-- Each A R some B -->
				<!-- not doing this time around -->

				<!-- 3.1.3 n-ary predicate -->
				<ConstrainedRoles>
					<!-- mandatory role starts reading -->
					<!-- Each A R some B1 ... some Bn -->
					<ReadingChoice match="RequireLeadReading">
						<Fact readingChoice="Conditional">
							<PredicateReplacement match="included">
								<Quantifier type="UniversalQuantifier"/>
							</PredicateReplacement>
							<PredicateReplacement>
								<Quantifier type="ExistentialQuantifier"/>
							</PredicateReplacement>
						</Fact>
					</ReadingChoice>

					<!-- mandatory role does NOT start reading-->
					<!-- For each A,
						some B1 R ... that A ... some Bn -->
					<ReadingChoice>
						<Quantifier type="ForEachQuantifier">
							<IterateRoles listStyle="SimpleList"/>
							<Fact readingChoice="Conditional">
								<PredicateReplacement match="included">
									<Quantifier type="ImpersonalPronoun"/>
								</PredicateReplacement>
								<PredicateReplacement>
									<Quantifier type="ExistentialQuantifier"/>
								</PredicateReplacement>
							</Fact>
						</Quantifier>
					</ReadingChoice>
				</ConstrainedRoles>
			</Constraint>

			<!-- UNDONE: The data from here down is preliminary, but is being used for generation testing -->
			<Constraint type="DisjunctiveMandatoryConstraint" patternGroup="SingleColumnExternalConstraint">
				<!-- Unaries are the only reading choice that has an optional negative reading -->
				<ConstrainedRoles sign="-" maxFactArity="1">
					<Quantifier type="NegativeReadingForUnaryOnlyDisjunctiveMandatory">
						<IterateRoles listStyle="SimpleList" match="singleColumnConstraintRoles" pass="first"/>
						<IterateRoles listStyle="CompoundList" match="singleColumnConstraintRoles">
							<Fact/>
						</IterateRoles>
					</Quantifier>
				</ConstrainedRoles>
				<ConstrainedRoles sign="-" maxFactArity="2">
					<ConditionalReading>
						<ReadingChoice match="RequireAllPrimaryLeadReading">
							<CompositeList listStyle="IndentedOrList">
								<IterateRoles minFactArity="2" match="singleColumnConstraintRoles">
									<Fact readingChoice="Conditional">
										<PredicateReplacement match="primary" pass="first">
											<Quantifier type="UniversalQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement match="primary">
											<Quantifier type="ImpersonalPronoun"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Quantifier type="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
								<IterateRoles factArity="1" match="singleColumnConstraintRoles">
									<Fact readingChoice="Conditional">
										<PredicateReplacement>
											<Quantifier type="ImpersonalPronoun"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</CompositeList>
						</ReadingChoice>
						<!--<ReadingChoice>
							<Quantifier type="ForEachQuantifier">
								<IterateRoles minFactArity="2" match="singleColumnConstraintRoles">
									<Fact readingChoice="PreferPrimaryLeadReading">
										<PredicateReplacement match="primary">
											<Quantifier type="ImpersonalQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement match="primary">
											<Quantifier type="ExistentialQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement match="secondary">
											<Quantifier type="ExistentialQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement match="secondary">
											<Quantifier type="ImpersonalQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
								<IterateRoles factArity="1" match="singleColumnConstraintRoles">
									<Fact/>
								</IterateRoles>
							</Quantifier>
						</ReadingChoice>-->
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			<!-- Start External Uniqueness Constraint-->
			<!--
			- -->
			<!-- Positive Reading -->
			<!--
			- <Constraint type="ExternalUniquenessConstraint" patternGroup="SingleColumnExternalConstraint">
				- <ConstrainedRoles sign="+" minFactArity="2" maxFactArity="2">
					- <ConditionalReading>
						- <ReadingChoice match="RequireAllNonLeadReadingNoForwardText">
							- <Quantifier type="ForEachQuantifier">
								<IterateRoles match="singleColumnConstraintRoles" listStyle="SimpleList" />
								- <IterateRoles match="singleColumnConstraintRoles" listStyle="IndentedList">
									- <Fact readingChoice="Conditional">
										- <PredicateReplacement match="excluded" pass="first">
											<Quantifier type="AtMostOneQuantifier" />
										</PredicateReplacement>
										- <PredicateReplacement match="excluded">
											<Quantifier type="null" />
										</PredicateReplacement>
										- <PredicateReplacement>
											<Quantifier type="ImpersonalPronoun" />
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</Quantifier>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
				- -->
			<!-- Negative Reading for External Uniqueness Constraint-->
			<!--
				- <ConstrainedRoles sign="-" minFactArity="2" maxFactArity="2">
					- <ConditionalReading>
						- <ReadingChoice match="RequireAllNonLeadReadingNoForwardText">
							- <Quantifier type="ModalPossibilityOperator">
								<IterateRoles match="singleColumnConstraintRoles" listStyle="SimpleList" />
								- <Fact readingChoice="Conditional">
									- <Predicate Replacement="" match="excluded">
										<Quantifier type="MoreThanOneQuantifier" />
									</Predicate>
									- <Predicate>
										<Quantifier type="IdentityReferenceQuantifier" />
									</Predicate>
									- <Predicate>
										<Quantifier type="SimpleListPairSeparator" />
									</Predicate>
									- <Predicate>
										<Quantifier type="IdentityReferenceQuantifier" />
									</Predicate>
								</Fact>
							</Quantifier>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			- -->
			<!-- End External Uniqueness Constraint  -->
		</Constraints>
	</Constructs>
</Root>

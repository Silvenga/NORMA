<?xml version="1.0" encoding="utf-8"?>
<VerbalizationRoot
	xmlns="http://schemas.neumont.edu/ORM/SDK/CoreVerbalizationGenerator"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://schemas.neumont.edu/ORM/SDK/CoreVerbalizationGenerator VerbalizationGenerator.xsd"
	snippetsLocation="VerbalizationCoreSnippets/VerbalizationCoreSnippets.xml">
	<Copyright name="Common Public License Copyright Notice">
		<CopyrightLine>/**************************************************************************\</CopyrightLine>
		<CopyrightLine>* Natural Object-Role Modeling Architect for Visual Studio                 *</CopyrightLine>
		<CopyrightLine>*                                                                          *</CopyrightLine>
		<CopyrightLine>* Copyright © Neumont University. All rights reserved.                     *</CopyrightLine>
		<CopyrightLine>* Copyright © ORM Solutions, LLC. All rights reserved.                     *</CopyrightLine>
		<CopyrightLine>*                                                                          *</CopyrightLine>
		<CopyrightLine>* The use and distribution terms for this software are covered by the      *</CopyrightLine>
		<CopyrightLine>* Common Public License 1.0 (http://opensource.org/licenses/cpl) which     *</CopyrightLine>
		<CopyrightLine>* can be found in the file CPL.txt at the root of this distribution.       *</CopyrightLine>
		<CopyrightLine>* By using this software in any fashion, you are agreeing to be bound by   *</CopyrightLine>
		<CopyrightLine>* the terms of this license.                                               *</CopyrightLine>
		<CopyrightLine>*                                                                          *</CopyrightLine>
		<CopyrightLine>* You must not remove this notice, or any other, from this software.       *</CopyrightLine>
		<CopyrightLine>\**************************************************************************/</CopyrightLine>
	</Copyright>
	<Constructs>
		<ORMModel>
			<Snippet ref="ModelVerbalization">
				<ContextName/>
				<ContextId/>
			</Snippet>
		</ORMModel>
		<!-- Generate FactType verbalization along with constraints -->
		<FactType/>
		<SubtypeFact>
			<Snippet ref="ImpliedModalNecessityOperator" conditionalBlockContext="SubtypeFactRolePlayers">
				<Snippet ref="SubtypeMetaReading">
					<Snippet ref="ObjectType">
						<SubtypeName/>
						<SubtypeId/>
					</Snippet>
					<Snippet ref="ObjectType">
						<SupertypeName/>
						<SupertypeId/>
					</Snippet>
					<ContextId/>
				</Snippet>
			</Snippet>
		</SubtypeFact>
		<!-- Generate ObjectType verbalization along with constraints -->
		<ObjectType>
			<ConditionalSnippet>
				<Snippet ref="EntityTypeVerbalization" conditionalMatch="IsEntityType"/>
				<Snippet ref="ValueTypeVerbalization"/>
				<SnippetReplacements>
					<Snippet ref="ObjectType">
						<ContextName isObjectType="true"/>
						<ContextId/>
					</Snippet>
				</SnippetReplacements>
			</ConditionalSnippet>
			<Snippet ref="FullSubtypeDerivation" conditionalMatch="HasVerbalizableSubtypeDerivationPath">
				<ProvidedRolePlayer rolePlayerKey="DerivationRule"/>
				<DerivationPath/>
			</Snippet>
			<ErrorReportHere/>
			<Snippet ref="ObjectifiesFactTypeVerbalization" conditionalMatch="IsObjectifiedFactType" conditionalBlockContext="ObjectifiedFactType">
				<Snippet ref="ObjectType">
					<ContextName isObjectType="true"/>
					<ContextId/>
				</Snippet>
				<Fact/>
			</Snippet>
			<Snippet ref="ReferenceSchemeVerbalization" conditionalMatch="HasUnobjectifiedPreferredIdentifier">
				<!-- UNDONE: Non-trivial join path external identifiers are not currently supported. Verbalize
				the join path here when they are. -->
				<IterateRoles match="preferredIdentifier" listStyle="CompoundList">
					<Fact/>
				</IterateRoles>
			</Snippet>
			<Snippet ref="ReferenceModeVerbalization" conditionalMatch="HasReferenceMode">
				<ReferenceMode/>
			</Snippet>
			<Snippet ref="IndependentVerbalization" conditionalMatch="IsIndependent">
				<Snippet ref="ObjectType">
					<ContextName isObjectType="true"/>
					<ContextId/>
				</Snippet>
			</Snippet>
			<Snippet ref="PortableDataTypeVerbalization" conditionalMatch="HasPortableDataType">
				<PortableDataType/>
			</Snippet>
			<Snippet ref="SelfReference" conditionalMatch="VerbalizeFactTypesWithBrowserObjectType">
				<IterateRoles match="playedRoles" listStyle="FactTypeList" verifyCanVerbalizeFactType="true" uniqueFactType="true">
					<Fact subtypeMetaReading="true" closeSentence="true"/>
				</IterateRoles>
			</Snippet>
		</ObjectType>
		<Definition>
			<Snippet ref="DescriptionVerbalization">
				<NoteText/>
			</Snippet>
		</Definition>
		<Note>
			<Snippet ref="NotesVerbalization">
				<NoteText/>
			</Snippet>
		</Note>
		<DerivationNote>
			<Snippet ref="DerivationNoteVerbalization">
				<ExpressionBody/>
			</Snippet>
		</DerivationNote>
		<ErrorReports>
			<ErrorReport type="ErrorReport" childHelperFor="Role" childHelperErrorReport="true"/>
		</ErrorReports>
		<!-- Generate constraint verbalizations -->
		<Constraints>
			<Constraint type="SubsetConstraint" patternGroup="SetComparisonConstraint">
				<ConstrainedRoles columnArity="1" sign="positive">
					<ConditionalReading>
						<ReadingChoice match="RequireAllPrimaryLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Snippet ref="Conditional">
									<IterateSequences listStyle="null" pass="first">
										<SequenceJoinPath markTrailingOutdentStart="true">
											<IterateRoles listStyle="null" match="constraintRoles">
												<Fact readingChoice="PreferPrimaryLeadReading">
													<ProvidedPredicateReplacement match="included" quantify="true"/>
													<ProvidedPredicateReplacement quantify="true"/>
												</Fact>
											</IterateRoles>
										</SequenceJoinPath>
									</IterateSequences>
									<IterateSequences listStyle="null" pass="notFirst">
										<SequenceJoinPath markTrailingOutdentStart="true">
											<IterateRoles match="constraintRoles" listStyle="null">
												<Fact readingChoice="PreferPrimaryLeadReading">
													<ProvidedPredicateReplacement match="included" quantify="true"/>
													<ProvidedPredicateReplacement quantify="true"/>
												</Fact>
											</IterateRoles>
										</SequenceJoinPath>
									</IterateSequences>
								</Snippet>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ImpliedModalNecessityOperator">
								<Snippet ref="ForEachIndentedQuantifier">
									<IterateSequences listStyle="null" pass="first">
										<IterateRoles match="providedConstraintRoles" listStyle="null" pass="first" markProvidedConstraintRolesAsHead="true"/>
									</IterateSequences>
									<Snippet ref="Conditional">
										<IterateSequences listStyle="null" pass="first">
											<SequenceJoinPath markTrailingOutdentStart="true">
												<IterateRoles match="constraintRoles" listStyle="null" pass="first">
													<Fact readingChoice="PreferLeadReading">
														<ProvidedPredicateReplacement match="included" quantify="true"/>
														<ProvidedPredicateReplacement quantify="true"/>
													</Fact>
												</IterateRoles>
											</SequenceJoinPath>
										</IterateSequences>
										<IterateSequences listStyle="null" pass="notFirst">
											<SequenceJoinPath markTrailingOutdentStart="true">
												<IterateRoles match="constraintRoles" listStyle="null" pass="first">
													<Fact readingChoice="PreferLeadReading">
														<ProvidedPredicateReplacement match="included" quantify="true"/>
														<ProvidedPredicateReplacement quantify="true"/>
													</Fact>
												</IterateRoles>
											</SequenceJoinPath>
										</IterateSequences>
									</Snippet>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
				<ConstrainedRoles sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="Conditional">
							<IterateSequences listStyle="CompoundList" pass="first" compositeList="true">
								<SequenceJoinPath markTrailingOutdentStart="true">
									<IterateRoles match="constraintRoles" listStyle="null" uniqueFactType="true">
										<Fact readingChoice="PreferPrimaryLeadReading">
											<ProvidedPredicateReplacement match="included" quantify="true"/>
											<ProvidedPredicateReplacement quantify="true"/>
										</Fact>
									</IterateRoles>
								</SequenceJoinPath>
							</IterateSequences>
							<IterateSequences listStyle="CompoundList" pass="notFirst" compositeList="true">
								<SequenceJoinPath markTrailingOutdentStart="true">
									<IterateRoles match="constraintRoles" listStyle="null" uniqueFactType="true">
										<Fact readingChoice="PreferPrimaryLeadReading">
											<ProvidedPredicateReplacement match="included" quantify="true"/>
											<ProvidedPredicateReplacement quantify="true"/>
										</Fact>
									</IterateRoles>
								</SequenceJoinPath>
							</IterateSequences>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<!-- Implied single-role internal uniqueness constraint on proxy role of implied binary fact -->
			<Constraint type="ImpliedUniqueVerbalizer" childHelperFor="FactType" patternGroup="InternalConstraint">
				<ConstrainedRoles constraintArity="1" factArity="2" sign="positive">
					<ConditionalReading>
						<ReadingChoice match="RequireLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="OneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles listStyle="SimpleList" match="included" hyphenBind="true"/>
								<Snippet ref="ImpliedModalNecessityOperator">
									<Fact>
										<PredicateReplacement match="included">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="OneQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
					<Snippet ref="ConstraintProvidesPreferredIdentifier" conditionalMatch="IsPreferredIdentifier">
						<IterateRoles listStyle="null" match="included"/>
						<IterateRoles listStyle="null" match="excluded"/>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles constraintArity="1" factArity="2">
					<!-- sign="negative" is implied by the previous element -->
					<!-- The pattern is the same whether or not we have a lead reading, so don't use ConditionalReading here -->
					<ReadingContext match="PreferLeadReading">
						<Snippet ref="ForEachCompactQuantifier">
							<IterateRoles match="included" listStyle="CompactSimpleList" hyphenBind="true"/>
							<Snippet ref="ModalPossibilityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="excluded">
										<Snippet ref="OneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</Snippet>
					</ReadingContext>
				</ConstrainedRoles>
			</Constraint>
			<!-- Implied simple mandatory on constraint on proxy role of implied binary fact -->
			<Constraint type="ImpliedMandatoryVerbalizer" childHelperFor="FactType" patternGroup="InternalConstraint">
				<!-- 3.1.2 binary predicate -->
				<ConstrainedRoles factArity="2">
					<ConditionalReading>

						<!-- mandatory constraint starts reading relational style -->
						<!-- Each A R some B -->
						<ReadingChoice match="RequireLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>

						<!-- mandatory role does NOT start reading -->
						<!-- For each A, some B S that A -->
						<ReadingChoice>
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles match="included" listStyle="SimpleList" hyphenBind="true"/>
								<Snippet ref="ImpliedModalNecessityOperator">
									<Fact>
										<PredicateReplacement match="included">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			<!-- FactType.DefaultBinaryMissingUniquenessVerbalizer -->
			<Constraint type="DefaultBinaryMissingUniquenessVerbalizer" childHelperFor="FactType" patternGroup="InternalConstraint">
				<!-- The context here is an alethic constraint covering the opposite single role -->
				<ConstrainedRoles factArity="2" sign="positive">
					<Snippet ref="ModalPossibilityOperator">
						<Fact readingChoice="PreferNonLeadReading">
							<PredicateReplacement match="included">
								<Snippet ref="MoreThanOneQuantifier"/>
							</PredicateReplacement>
							<PredicateReplacement>
								<Snippet ref="IdentityReferenceQuantifier"/>
							</PredicateReplacement>
						</Fact>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<!-- FactType.CombinedMandatoryUniqueVerbalizer -->
			<Constraint type="CombinedMandatoryUniqueVerbalizer" childHelperFor="FactType" childHelperErrorReport="true" patternGroup="InternalConstraint">
				<!-- 3.1.2 binary predicate -->
				<ConstrainedRoles factArity="2" sign="positive">
					<ConditionalReading>

						<!-- mandatory constraint starts reading relational style -->
						<!-- Each A R some B -->
						<ReadingChoice match="RequireLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExactlyOneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>

						<!-- mandatory role does NOT start reading -->
						<!-- For each A, some B S that A -->
						<ReadingChoice>
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles match="included" listStyle="SimpleList" hyphenBind="true"/>
								<Snippet ref="ImpliedModalNecessityOperator">
									<Fact>
										<PredicateReplacement match="included">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExactlyOneQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="MandatoryConstraint" patternGroup="SetConstraint" compatibleColumns="true">
				<!-- Handle internal constraint patterns first -->
				<!-- 3.1.1 unary predicate -->
				<!-- Each A R -->
				<ConstrainedRoles constraintArity="1" factArity="1" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="UniversalQuantifier">
							<Fact/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>

				<!-- 3.1.2 binary predicate -->
				<ConstrainedRoles constraintArity="1" factArity="2" maxFactArity="2">
					<ConditionalReading>

						<!-- mandatory constraint starts reading relational style -->
						<!-- Each A R some B -->
						<ReadingChoice match="RequireLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>

						<!-- mandatory role does NOT start reading -->
						<!-- For each A, some B S that A -->
						<ReadingChoice>
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles match="included" listStyle="SimpleList" hyphenBind="true"/>
								<Snippet ref="ImpliedModalNecessityOperator">
									<Fact>
										<PredicateReplacement match="included">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>

				<!-- mandatory constraint starts reading attribute style -->
				<!-- Each A R some B -->
				<!-- not doing this time around -->

				<!-- 3.1.3 n-ary predicate -->
				<ConstrainedRoles constraintArity="1" minFactArity="3">
					<ConditionalReading>
						<!-- mandatory role starts reading -->
						<!-- Each A R some B1 ... some Bn -->
						<ReadingChoice match="RequireLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>

						<!-- mandatory role does NOT start reading-->
						<!-- For each A,
							some B1 R ... that A ... some Bn -->
						<ReadingChoice>
							<Snippet ref="ForEachIndentedQuantifier">
								<IterateRoles match="included" listStyle="SimpleList" hyphenBind="true"/>
								<Snippet ref="ImpliedModalNecessityOperator">
									<Fact>
										<PredicateReplacement match="included">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>

				<!-- Start disjunctive mandatory constraints -->
				<!-- Unaries are the only reading choice that has an optional negative reading -->
				<ConstrainedRoles sign="negative" maxFactArity="1">
					<Snippet ref="ModalPossibilityOperator">
						<Snippet ref="NegativeReadingForUnaryOnlyDisjunctiveMandatory">
							<IterateRoles listStyle="null" match="constraintRoles" pass="first"/>
							<IterateFacts listStyle="IndentedCompoundList"/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles sign="positive" maxFactArity="1">
					<ConditionalReading>
						<ReadingChoice match="RequireAllLeadReadingNoFrontText">
							<Snippet ref="ImpliedModalNecessityOperator">
								<IterateRoles listStyle="TopLevelIndentedLogicalOrList"  match="constraintRoles">
									<Fact readingChoice="Context">
										<PredicateReplacement match="primary" pass="first">
											<Snippet ref="UniversalQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement match="primary">
											<Snippet ref="null"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles listStyle="null" pass="first" match="constraintRoles"/>
								<Snippet ref="ImpliedModalNecessityOperator">
									<IterateRoles listStyle="SimpleLogicalOrList" match="constraintRoles">
										<Fact readingChoice="PreferPrimaryLeadReadingNoFrontText">
											<PredicateReplacement match="included">
												<Snippet ref="DefiniteArticle"/>
											</PredicateReplacement>
										</Fact>
									</IterateRoles>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
				<ConstrainedRoles sign="positive">
					<ConditionalReading>
						<ReadingChoice match="RequireAllPrimaryLeadReadingNoFrontText">
							<Snippet ref="ImpliedModalNecessityOperator">
								<CompositeList listStyle="TopLevelIndentedLogicalOrList">
									<IterateRoles minFactArity="2" match="constraintRoles">
										<Fact readingChoice="Context">
											<PredicateReplacement match="primary" pass="first">
												<Snippet ref="UniversalQuantifier"/>
											</PredicateReplacement>
											<PredicateReplacement match="primary">
												<Snippet ref="null"/>
											</PredicateReplacement>
											<PredicateReplacement>
												<Snippet ref="ExistentialQuantifier"/>
											</PredicateReplacement>
										</Fact>
									</IterateRoles>
									<IterateRoles factArity="1" match="constraintRoles">
										<Fact readingChoice="Context">
											<PredicateReplacement>
												<Snippet ref="null"/>
											</PredicateReplacement>
										</Fact>
									</IterateRoles>
								</CompositeList>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles match="constraintRoles" pass="first" listStyle="SimpleList"/>
								<Snippet ref="ImpliedModalNecessityOperator">
									<CompositeList listStyle="IndentedLogicalOrList">
										<IterateRoles match="constraintRoles" minFactArity="2">
											<Fact readingChoice="PreferPrimaryLeadReadingNoFrontText">
												<PredicateReplacement match="included">
													<Snippet ref="DefiniteArticle"/>
												</PredicateReplacement>
												<PredicateReplacement match="excluded">
													<Snippet ref="ExistentialQuantifier"/>
												</PredicateReplacement>
											</Fact>
										</IterateRoles>
										<IterateRoles factArity="1" match="constraintRoles">
											<Fact>
												<PredicateReplacement>
													<Snippet ref="DefiniteArticle"/>
												</PredicateReplacement>
											</Fact>
										</IterateRoles>
									</CompositeList>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
				<!-- Exclusive-Or Constraint (Exclusion 6.1.2)-->
				<!--<ConstrainedRoles columnArity="1">
					
				</ConstrainedRoles>-->
			</Constraint>
			<!-- Start Uniqueness Constraint-->
			<Constraint type="UniquenessConstraint" patternGroup="SetConstraint" automaticJoinPathPattern="OppositeRole">
				<!-- UNDONE: Subscripting requirements are harder than this. Subscripting
				needs to go across FactTypes, and be based on included/excluded roles. In this
				case, the subscripts are only needed if the duplicates role players intersect
				the constraint roles. For now, this subscripts internal uniqueness correctly
				in most situations. -->
				<EnableSubscripts factCount="1" minFactArity="3"/>
				<!-- Internal constraints -->
				<ConstrainedRoles factCount="1" factArity="1" sign="positive">
					<!-- span='all' is implicit in the other conditions. 0 arity includedRoles is blocked. -->
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="OccursInPopulation">
							<Snippet ref="UniversalQuantifier">
								<IterateRoles match="included" listStyle="SimpleList"/>
							</Snippet>
							<Fact/>
						</Snippet>
					</Snippet>
					<Snippet ref="ConstraintProvidesPreferredIdentifier" conditionalMatch="IsPreferredIdentifier" conditionalBlockContext="PreferredFor">
						<IterateRoles listStyle="null" match="included"/>
						<Snippet ref="ObjectType">
							<PreferredIdentifierFor/>
							<PreferredIdentifierForId/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1" factArity="1">
					<!-- span="all" sign="negative" is implicit in the other conditions are previous element-->
					<ReadingContext>
						<Snippet ref="ModalPossibilityOperator">
							<Snippet ref="OccursInPopulation">
								<Snippet ref="IdentityReferenceQuantifier">
									<IterateRoles match="included" listStyle="SimpleList" hyphenBind="true"/>
								</Snippet>
								<Fact readingChoice="Context"/>
							</Snippet>
						</Snippet>
					</ReadingContext>
					<Snippet ref="ConstraintProvidesPreferredIdentifier" conditionalMatch="IsPreferredIdentifier" conditionalBlockContext="PreferredFor">
						<IterateRoles listStyle="null" match="included"/>
						<Snippet ref="ObjectType">
							<PreferredIdentifierFor/>
							<PreferredIdentifierForId/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1" span="all" sign="positive">
					<!-- UNDONE: Subscripting requirements specify on for binary, off for n-ary. Currently
						 they are always on. We need to see if there are any verbalizations where subscripts are
						 required in some places but not others before designing the xml and generating from it.
						 If subscripts are required in all places in any verbalization pattern that uses them, then
						 the following would be a potential tag for this location (we'd have subscripts off by default). -->
					<!--<EnableSubscripts minFactArity="3"/>-->
					<Snippet ref="ModalPossibilityOperator">
						<IterateRoles listStyle="TopLevelIndentedLogicalAndList">
							<Fact readingChoice="PreferPrimaryLeadReading">
								<PredicateReplacement match="primary">
									<Snippet ref="MoreThanOneQuantifier"/>
								</PredicateReplacement>
								<PredicateReplacement>
									<Snippet ref="IdentityReferenceQuantifier"/>
								</PredicateReplacement>
							</Fact>
						</IterateRoles>
					</Snippet>
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="OccursInPopulation">
							<Snippet ref="CombinationIdentifier">
								<Snippet ref="UniversalQuantifier">
									<IterateRoles match="included" listStyle="CompactSimpleList"/>
								</Snippet>
							</Snippet>
							<Fact/>
						</Snippet>
					</Snippet>
					<Snippet ref="ConstraintProvidesPreferredIdentifier" conditionalMatch="IsPreferredIdentifier" conditionalBlockContext="PreferredFor">
						<IterateRoles listStyle="CompactSimpleList" match="included"/>
						<Snippet ref="ObjectType">
							<PreferredIdentifierFor/>
							<PreferredIdentifierForId/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1" span="all">
					<!-- sign="negative" is implied by the previous element -->
					<Snippet ref="ModalPossibilityOperator" alternateSign="positive">
						<IterateRoles listStyle="TopLevelIndentedLogicalAndList">
							<Fact readingChoice="PreferPrimaryLeadReading">
								<PredicateReplacement match="primary">
									<Snippet ref="MoreThanOneQuantifier" alternateSign="positive"/>
								</PredicateReplacement>
								<PredicateReplacement>
									<Snippet ref="IdentityReferenceQuantifier" alternateSign="positive"/>
								</PredicateReplacement>
							</Fact>
						</IterateRoles>
					</Snippet>
					<ReadingContext>
						<Snippet ref="ModalPossibilityOperator">
							<Snippet ref="OccursInPopulation">
								<Snippet ref="CombinationIdentifier">
									<Snippet ref="IdentityReferenceQuantifier">
										<IterateRoles match="included" listStyle="CompactSimpleList" hyphenBind="true"/>
									</Snippet>
								</Snippet>
								<Fact readingChoice="Context"/>
							</Snippet>
						</Snippet>
					</ReadingContext>
					<Snippet ref="ConstraintProvidesPreferredIdentifier" conditionalMatch="IsPreferredIdentifier" conditionalBlockContext="PreferredFor">
						<IterateRoles listStyle="CompactSimpleList" match="included"/>
						<Snippet ref="ObjectType">
							<PreferredIdentifierFor/>
							<PreferredIdentifierForId/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1" factArity="2" sign="positive">
					<ConditionalReading>
						<ReadingChoice match="RequireLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="OneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles listStyle="SimpleList" match="included" hyphenBind="true"/>
								<Snippet ref="ImpliedModalNecessityOperator">
									<Fact>
										<PredicateReplacement match="included">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="OneQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
					<Snippet ref="ConstraintProvidesPreferredIdentifier" conditionalMatch="IsPreferredIdentifier" conditionalBlockContext="PreferredFor">
						<IterateRoles listStyle="CompactSimpleList" match="included"/>
						<Snippet ref="ObjectType">
							<PreferredIdentifierFor/>
							<PreferredIdentifierForId/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1" factArity="2">
					<!-- sign="negative" is implied by the previous element -->
					<!-- The pattern is the same whether or not we have a lead reading, so don't use ConditionalReading here -->
					<ReadingContext match="PreferLeadReading">
						<Snippet ref="ForEachCompactQuantifier">
							<IterateRoles match="included" listStyle="CompactSimpleList" hyphenBind="true"/>
							<Snippet ref="ModalPossibilityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="excluded">
										<Snippet ref="OneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</Snippet>
					</ReadingContext>
					<Snippet ref="ConstraintProvidesPreferredIdentifier" conditionalMatch="IsPreferredIdentifier" conditionalBlockContext="PreferredFor">
						<IterateRoles listStyle="CompactSimpleList" match="included"/>
						<Snippet ref="ObjectType">
							<PreferredIdentifierFor/>
							<PreferredIdentifierForId/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1" sign="negative">
					<Snippet ref="ModalPossibilityOperator">
						<Fact>
							<PredicateReplacement match="included">
								<Snippet ref="IdentityReferenceQuantifier"/>
							</PredicateReplacement>
							<PredicateReplacement>
								<Snippet ref="MoreThanOneQuantifier"/>
							</PredicateReplacement>
						</Fact>
					</Snippet>
					<Snippet ref="ConstraintProvidesPreferredIdentifier" conditionalMatch="IsPreferredIdentifier" conditionalBlockContext="PreferredFor">
						<IterateRoles listStyle="CompactSimpleList" match="included"/>
						<Snippet ref="ObjectType">
							<PreferredIdentifierFor/>
							<PreferredIdentifierForId/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1">
					<!-- sign="positive" is implied by the previous element -->
					<ReadingContext>
						<Snippet ref="ForEachIndentedQuantifier">
							<IterateRoles match="included" listStyle="SimpleList" hyphenBind="true"/>
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="excluded">
										<Snippet ref="OneQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</Snippet>
					</ReadingContext>
					<Snippet ref="ConstraintProvidesPreferredIdentifier" conditionalMatch="IsPreferredIdentifier" conditionalBlockContext="PreferredFor">
						<IterateRoles listStyle="CompactSimpleList" match="included"/>
						<Snippet ref="ObjectType">
							<PreferredIdentifierFor/>
							<PreferredIdentifierForId/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>

				<!-- External constraints -->
				<!-- Positive Reading -->
				<ConstrainedRoles trivialOppositeRolePath="true" sign="positive" minFactArity="2" maxFactArity="2" blockHelpers="pathVerbalizer">
					<ConditionalReading>
						<ReadingChoice match="RequireAllNonLeadReadingNoFrontText">
							<Snippet ref="ForEachCompactQuantifier">
								<IterateRoles match="providedConstraintRoles" listStyle="SimpleList" hyphenBind="true">
									<ReadingContext match="PreferNonPrimaryLeadReadingNoFrontText"/>
								</IterateRoles>
								<IterateRoles match="providedConstraintRoles" listStyle="IndentedList">
									<Fact readingChoice="Context">
										<ProvidedPredicateReplacement match="excluded" pass="first">
											<Snippet ref="AtMostOneQuantifier" />
										</ProvidedPredicateReplacement>
										<ProvidedPredicateReplacement match="excluded">
											<Snippet ref="null" />
										</ProvidedPredicateReplacement>
										<ProvidedPredicateReplacement match="included" quantify="true"/>
									</Fact>
								</IterateRoles>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ContextScope">
								<!-- State the join path with a fallback to list the fact types. The fallback should
								occur only for an non-automatic join path with insufficient data to verbalize. -->
								<SequenceJoinPath>
									<IterateRoles match="constraintRoles" listStyle="CompoundList" uniqueFactType="true">
										<Fact readingChoice="PreferPrimaryLeadReading">
											<ProvidedPredicateReplacement match="included" quantify="false"/>
											<ProvidedPredicateReplacement quantify="false"/>
										</Fact>
									</IterateRoles>
								</SequenceJoinPath>
							</Snippet>
							<Snippet ref="ContextScopeReference">
								<Snippet ref="ImpliedModalNecessityOperator">
									<Snippet ref="UniversalQuantifier">
										<Snippet ref="CombinationAssociation">
											<IterateRoles match="providedConstraintRoles" listStyle="CompactSimpleList"/>
											<Snippet ref="OneQuantifier">
												<ProvidedRolePlayer rolePlayerKey="SingleLeadRolePath"/>
											</Snippet>
										</Snippet>
									</Snippet>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
					<Snippet ref="ConstraintProvidesPreferredIdentifier" conditionalMatch="IsPreferredIdentifier" conditionalBlockContext="PreferredFor">
						<IterateRoles listStyle="CompactSimpleList" match="providedConstraintRoles"/>
						<Snippet ref="ObjectType">
							<PreferredIdentifierFor/>
							<PreferredIdentifierForId/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<!-- Negative Reading for External Uniqueness Constraint-->
				<ConstrainedRoles trivialOppositeRolePath="true" sign="negative" minFactArity="2" maxFactArity="2" blockHelpers="pathVerbalizer">
					<ConditionalReading>
						<ReadingChoice match="RequireAllNonLeadReadingNoFrontText">
							<Snippet ref="ModalPossibilityOperator">
								<IterateRoles match="providedConstraintRoles" listStyle="SimpleList">
									<Fact readingChoice="Context">
										<ProvidedPredicateReplacement match="excluded" pass="first">
											<Snippet ref="MoreThanOneQuantifier" />
										</ProvidedPredicateReplacement>
										<ProvidedPredicateReplacement match="excluded">
											<Snippet ref="null" />
										</ProvidedPredicateReplacement>
										<ProvidedPredicateReplacement match="included">
											<Snippet ref="IdentityReferenceQuantifier" />
										</ProvidedPredicateReplacement>
									</Fact>
								</IterateRoles>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ContextScope">
								<!-- State the join path with a fallback to list the fact types. The fallback should
								occur only for an non-automatic join path with insufficient data to verbalize. -->
								<SequenceJoinPath>
									<IterateRoles match="constraintRoles" listStyle="CompoundList" uniqueFactType="true">
										<Fact readingChoice="PreferPrimaryLeadReading">
											<ProvidedPredicateReplacement match="included" quantify="false"/>
											<ProvidedPredicateReplacement quantify="false"/>
										</Fact>
									</IterateRoles>
								</SequenceJoinPath>
							</Snippet>
							<Snippet ref="ContextScopeReference">
								<Snippet ref="ModalPossibilityOperator">
									<Snippet ref="CombinationAssociation">
										<Snippet ref="IdentityReferenceQuantifier">
											<IterateRoles match="providedConstraintRoles" listStyle="CompactSimpleList"/>
										</Snippet>
										<Snippet ref="MoreThanOneQuantifier">
											<ProvidedRolePlayer rolePlayerKey="SingleLeadRolePath"/>
										</Snippet>
									</Snippet>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
					<Snippet ref="ConstraintProvidesPreferredIdentifier" conditionalMatch="IsPreferredIdentifier" conditionalBlockContext="PreferredFor">
						<IterateRoles listStyle="CompactSimpleList" match="providedConstraintRoles"/>
						<Snippet ref="ObjectType">
							<PreferredIdentifierFor/>
							<PreferredIdentifierForId/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles sign="positive" blockHelpers="pathVerbalizer">
					<Snippet ref="ContextScope">
						<!-- State the join path with a fallback to list the fact types. -->
						<SequenceJoinPath>
							<IterateRoles match="constraintRoles" listStyle="CompoundList" uniqueFactType="true">
								<Fact readingChoice="PreferPrimaryLeadReading">
									<ProvidedPredicateReplacement match="included" quantify="false"/>
									<ProvidedPredicateReplacement quantify="false"/>
								</Fact>
							</IterateRoles>
						</SequenceJoinPath>
					</Snippet>
					<Snippet ref="ContextScopeReference">
						<Snippet ref="ImpliedModalNecessityOperator">
							<Snippet ref="UniversalQuantifier">
								<Snippet ref="CombinationUniqueness">
									<IterateRoles match="providedConstraintRoles" listStyle="CompactSimpleList"/>
								</Snippet>
							</Snippet>
						</Snippet>
					</Snippet>
					<Snippet ref="ConstraintProvidesPreferredIdentifier" conditionalMatch="IsPreferredIdentifier" conditionalBlockContext="PreferredFor">
						<IterateRoles listStyle="CompactSimpleList" match="providedConstraintRoles"/>
						<Snippet ref="ObjectType">
							<PreferredIdentifierFor/>
							<PreferredIdentifierForId/>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<!-- End Uniqueness Constraint  -->
			<!-- Begin Frequency Constraint  -->
			<Constraint patternGroup="SetConstraint" type="FrequencyConstraint" automaticJoinPathPattern="OppositeRole">
				<EnableSubscripts nonOptimizedFrequencyPattern="true"/>
				<ConstrainedRoles factCount="1" factArity="2" constraintArity="1" sign="positive" frequencyRangePattern="MinUnbounded">
					<ConditionalReading>
						<ReadingChoice match="RequireLeadReading">
							<Snippet ref="ImpliedModalNecessityOperator">
								<Fact readingChoice="Context">
									<PredicateReplacement match="included">
										<Snippet ref="UniversalQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="FrequencyTypedOccurrences">
											<Snippet ref="FrequencyRangeMinUnbounded">
												<MinFrequencyValue/>
												<MaxFrequencyValue/>
											</Snippet>
										</Snippet>
									</PredicateReplacement>
								</Fact>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ImpliedModalNecessityOperator">
								<Snippet ref="FrequencyPopulation">
									<IterateRoles match="constraintRoles" listStyle="null"/>
									<Fact/>
									<Snippet ref="FrequencyUntypedOccurrences">
										<ConditionalSnippet>
											<Snippet ref="FrequencyRangeExact" conditionalMatch="FrequencyRangeExact"/>
											<Snippet ref="FrequencyRangeMaxUnbounded" conditionalMatch="FrequencyRangeMaxUnbounded"/>
											<Snippet ref="FrequencyRangeMinUnbounded" conditionalMatch="FrequencyRangeMinUnbounded"/>
											<Snippet ref="FrequencyRangeMinAndMax"/>
											<SnippetReplacements>
												<MinFrequencyValue/>
												<MaxFrequencyValue/>
											</SnippetReplacements>
										</ConditionalSnippet>
									</Snippet>
								</Snippet>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="1" minFactArity="2" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="FrequencyPopulation">
							<ConditionalReplacement>
								<IterateRoles conditionalMatch="SingleRoleRoleSequence" match="constraintRoles" listStyle="null"/>
								<Snippet ref="CombinationIdentifier">
									<IterateRoles match="constraintRoles" listStyle="CompactSimpleList"/>
								</Snippet>
							</ConditionalReplacement>
							<Fact/>
							<Snippet ref="FrequencyUntypedOccurrences">
								<ConditionalSnippet>
									<Snippet ref="FrequencyRangeExact" conditionalMatch="FrequencyRangeExact"/>
									<Snippet ref="FrequencyRangeMaxUnbounded" conditionalMatch="FrequencyRangeMaxUnbounded"/>
									<Snippet ref="FrequencyRangeMinUnbounded" conditionalMatch="FrequencyRangeMinUnbounded"/>
									<Snippet ref="FrequencyRangeMinAndMax"/>
									<SnippetReplacements>
										<MinFrequencyValue/>
										<MaxFrequencyValue/>
									</SnippetReplacements>
								</ConditionalSnippet>
							</Snippet>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles sign="positive" minFactArity="2" maxFactArity="2" trivialOppositeRolePath="true" blockHelpers="pathVerbalizer">
					<Snippet ref="ContextScope">
						<SequenceJoinPath>
							<IterateRoles match="constraintRoles" listStyle="CompoundList" uniqueFactType="true">
								<Fact readingChoice="PreferPrimaryLeadReading">
									<ProvidedPredicateReplacement match="included" quantify="false"/>
									<ProvidedPredicateReplacement quantify="false"/>
								</Fact>
							</IterateRoles>
						</SequenceJoinPath>
					</Snippet>
					<Snippet ref="ContextScopeReference">
						<Snippet ref="ImpliedModalNecessityOperator">
							<Snippet ref="UniversalQuantifier">
								<Snippet ref="CombinationAssociation">
									<IterateRoles match="providedConstraintRoles" listStyle="CompactSimpleList"/>
									<Snippet ref="FrequencyTypedOccurrences">
										<ProvidedRolePlayer rolePlayerKey="SingleLeadRolePath"/>
										<ConditionalSnippet>
											<Snippet ref="FrequencyRangeExact" conditionalMatch="FrequencyRangeExact"/>
											<Snippet ref="FrequencyRangeMaxUnbounded" conditionalMatch="FrequencyRangeMaxUnbounded"/>
											<Snippet ref="FrequencyRangeMinUnbounded" conditionalMatch="FrequencyRangeMinUnbounded"/>
											<Snippet ref="FrequencyRangeMinAndMax"/>
											<SnippetReplacements>
												<MinFrequencyValue/>
												<MaxFrequencyValue/>
											</SnippetReplacements>
										</ConditionalSnippet>
									</Snippet>
								</Snippet>
							</Snippet>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles sign="positive" blockHelpers="pathVerbalizer">
					<Snippet ref="ContextScope">
						<SequenceJoinPath>
							<IterateRoles match="constraintRoles" listStyle="CompoundList" uniqueFactType="true">
								<Fact readingChoice="PreferPrimaryLeadReading">
									<ProvidedPredicateReplacement match="included" quantify="false"/>
									<ProvidedPredicateReplacement quantify="false"/>
								</Fact>
							</IterateRoles>
						</SequenceJoinPath>
					</Snippet>
					<Snippet ref="ContextScopeReference">
						<Snippet ref="ImpliedModalNecessityOperator">
							<Snippet ref="UniversalQuantifier">
								<Snippet ref="CombinationOccurrence">
									<IterateRoles match="providedConstraintRoles" listStyle="CompactSimpleList"/>
									<Snippet ref="FrequencyUntypedOccurrences">
										<ConditionalSnippet>
											<Snippet ref="FrequencyRangeExact" conditionalMatch="FrequencyRangeExact"/>
											<Snippet ref="FrequencyRangeMaxUnbounded" conditionalMatch="FrequencyRangeMaxUnbounded"/>
											<Snippet ref="FrequencyRangeMinUnbounded" conditionalMatch="FrequencyRangeMinUnbounded"/>
											<Snippet ref="FrequencyRangeMinAndMax"/>
											<SnippetReplacements>
												<MinFrequencyValue/>
												<MaxFrequencyValue/>
											</SnippetReplacements>
										</ConditionalSnippet>
									</Snippet>
								</Snippet>
							</Snippet>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<!-- End Frequency Constraint -->
			<!-- Begin Role Value Constraint -->
			<Constraint patternGroup="RoleValueConstraint" type="RoleValueConstraint">
				<ConditionalSnippet>
					<!-- Determine whether the range is degenerate. -->
					<Snippet ref="SingleValueValueConstraint" conditionalMatch="IsSingleValue"/>
					<Snippet ref="MultiValueValueConstraint"/>
					<SnippetReplacements>
						<ConditionalReplacement>
							<!-- BinaryWithRoleName matches this pattern: The values of [OpposingRolePlayerName.]roleName[(RolePlayerRefMode)] are value-spec. -->
							<IterateRoles match="included" listStyle="null" conditionalMatch="BinaryWithRoleName">
								<Snippet ref="PeriodSeparator">
									<IterateContextRoles match="excluded" listStyle="null"/>
									<ConditionalReplacement>
										<Snippet ref="ReferenceScheme" conditionalMatch="RolePlayerHasReferenceScheme">
											<RoleName/>
											<RolePlayerReferenceMode/>
										</Snippet>
										<RoleName/>
									</ConditionalReplacement>
								</Snippet>
							</IterateRoles>
							<!-- The fallback pattern is: The values of RolePlayer[sub] in Full Fact Verbalization are value-spec. -->
							<ReadingContext>
								<Snippet ref="InQuantifier">
									<IterateRoles match="included" listStyle="null" hyphenBind="true"/>
									<Fact readingChoice="Context"/>
								</Snippet>
							</ReadingContext>
						</ConditionalReplacement>
						<IterateValueRanges listStyle="CompactSimpleList">
							<ConditionalSnippet>
								<!-- Match one of the nine possible value range patterns.  MinUnboundedMaxUnbounded is not a valid value range pattern. -->
								<Snippet ref="SelfReference" conditionalMatch="MinEqualsMax"/>
								<Snippet ref="MinClosedMaxUnbounded" conditionalMatch="MinClosedMaxUnbounded"/>
								<Snippet ref="MinOpenMaxUnbounded" conditionalMatch="MinOpenMaxUnbounded"/>
								<Snippet ref="MinUnboundedMaxClosed" conditionalMatch="MinUnboundedMaxClosed"/>
								<Snippet ref="MinUnboundedMaxOpen" conditionalMatch="MinUnboundedMaxOpen"/>
								<Snippet ref="MinClosedMaxClosed" conditionalMatch="MinClosedMaxClosed"/>
								<Snippet ref="MinClosedMaxOpen" conditionalMatch="MinClosedMaxOpen"/>
								<Snippet ref="MinOpenMaxClosed" conditionalMatch="MinOpenMaxClosed"/>
								<Snippet ref="MinOpenMaxOpen" conditionalMatch="MinOpenMaxOpen"/>
								<SnippetReplacements>
									<ConditionalSnippet>
										<Snippet ref="TextInstanceValue" conditionalMatch="IsText"/>
										<Snippet ref="NonTextInstanceValue"/>
										<SnippetReplacements>
											<MinValue/>
										</SnippetReplacements>
									</ConditionalSnippet>
									<ConditionalSnippet>
										<Snippet ref="TextInstanceValue" conditionalMatch="IsText"/>
										<Snippet ref="NonTextInstanceValue"/>
										<SnippetReplacements>
											<MaxValue/>
										</SnippetReplacements>
									</ConditionalSnippet>
								</SnippetReplacements>
							</ConditionalSnippet>
						</IterateValueRanges>
					</SnippetReplacements>
				</ConditionalSnippet>
			</Constraint>
			<!-- End Role Value Constraint-->
			<!-- Begin Value Type Value Constraint -->
			<Constraint patternGroup="ValueTypeValueConstraint" type="ValueTypeValueConstraint">
				<ConditionalSnippet>
					<!-- Determine whether the range is degenerate. -->
					<Snippet ref="SingleValueValueConstraint" conditionalMatch="IsSingleValue"/>
					<Snippet ref="MultiValueValueConstraint"/>
					<SnippetReplacements>
						<Snippet ref="ObjectType">
							<ValueRangeValueTypeName/>
							<ValueRangeValueTypeId/>
						</Snippet>
						<IterateValueRanges listStyle="CompactSimpleList">
							<ConditionalSnippet>
								<!-- Match one of the nine possible value range patterns.  MinUnboundedMaxUnbounded is not a valid value range pattern. -->
								<Snippet ref="SelfReference" conditionalMatch="MinEqualsMax"/>
								<Snippet ref="MinClosedMaxUnbounded" conditionalMatch="MinClosedMaxUnbounded"/>
								<Snippet ref="MinOpenMaxUnbounded" conditionalMatch="MinOpenMaxUnbounded"/>
								<Snippet ref="MinUnboundedMaxClosed" conditionalMatch="MinUnboundedMaxClosed"/>
								<Snippet ref="MinUnboundedMaxOpen" conditionalMatch="MinUnboundedMaxOpen"/>
								<Snippet ref="MinClosedMaxClosed" conditionalMatch="MinClosedMaxClosed"/>
								<Snippet ref="MinClosedMaxOpen" conditionalMatch="MinClosedMaxOpen"/>
								<Snippet ref="MinOpenMaxClosed" conditionalMatch="MinOpenMaxClosed"/>
								<Snippet ref="MinOpenMaxOpen" conditionalMatch="MinOpenMaxOpen"/>
								<SnippetReplacements>
									<ConditionalSnippet>
										<Snippet ref="TextInstanceValue" conditionalMatch="IsText"/>
										<Snippet ref="NonTextInstanceValue"/>
										<SnippetReplacements>
											<MinValue/>
										</SnippetReplacements>
									</ConditionalSnippet>
									<ConditionalSnippet>
										<Snippet ref="TextInstanceValue" conditionalMatch="IsText"/>
										<Snippet ref="NonTextInstanceValue"/>
										<SnippetReplacements>
											<MaxValue/>
										</SnippetReplacements>
									</ConditionalSnippet>
								</SnippetReplacements>
							</ConditionalSnippet>
						</IterateValueRanges>
					</SnippetReplacements>
				</ConditionalSnippet>
			</Constraint>
			<!-- End Value Type Value Constraint -->
			<!-- Begin nearest EntityType ValueConstraint -->
			<Constraint patternGroup="NearestValueConstraint" type="NearestValueConstraintVerbalizer" childHelperFor="ObjectType">
				<ConditionalSnippet>
					<!-- Determine whether the range is degenerate. -->
					<Snippet ref="SingleValueValueConstraint" conditionalMatch="IsSingleValue"/>
					<Snippet ref="MultiValueValueConstraint"/>
					<SnippetReplacements>
						<Snippet ref="ObjectType">
							<ContextName isObjectType="true"/>
							<ContextId/>
						</Snippet>
						<IterateValueRanges listStyle="CompactSimpleList">
							<ConditionalSnippet>
								<!-- Match one of the nine possible value range patterns.  MinUnboundedMaxUnbounded is not a valid value range pattern. -->
								<Snippet ref="SelfReference" conditionalMatch="MinEqualsMax"/>
								<Snippet ref="MinClosedMaxUnbounded" conditionalMatch="MinClosedMaxUnbounded"/>
								<Snippet ref="MinOpenMaxUnbounded" conditionalMatch="MinOpenMaxUnbounded"/>
								<Snippet ref="MinUnboundedMaxClosed" conditionalMatch="MinUnboundedMaxClosed"/>
								<Snippet ref="MinUnboundedMaxOpen" conditionalMatch="MinUnboundedMaxOpen"/>
								<Snippet ref="MinClosedMaxClosed" conditionalMatch="MinClosedMaxClosed"/>
								<Snippet ref="MinClosedMaxOpen" conditionalMatch="MinClosedMaxOpen"/>
								<Snippet ref="MinOpenMaxClosed" conditionalMatch="MinOpenMaxClosed"/>
								<Snippet ref="MinOpenMaxOpen" conditionalMatch="MinOpenMaxOpen"/>
								<SnippetReplacements>
									<ConditionalSnippet>
										<Snippet ref="TextInstanceValue" conditionalMatch="IsText"/>
										<Snippet ref="NonTextInstanceValue"/>
										<SnippetReplacements>
											<MinValue/>
										</SnippetReplacements>
									</ConditionalSnippet>
									<ConditionalSnippet>
										<Snippet ref="TextInstanceValue" conditionalMatch="IsText"/>
										<Snippet ref="NonTextInstanceValue"/>
										<SnippetReplacements>
											<MaxValue/>
										</SnippetReplacements>
									</ConditionalSnippet>
								</SnippetReplacements>
							</ConditionalSnippet>
						</IterateValueRanges>
					</SnippetReplacements>
				</ConditionalSnippet>
			</Constraint>
			<!-- End nearest EntityType ValueConstraint -->
			<Constraint type="RingConstraint" patternGroup="SetConstraint" deferMatchesTo="VerbalizeByRingType"/>
			<!-- Implementation note on ring constraints:
			The following child helper classes (with adjustments for custom subscript settings) can be combined into
			one verbalization implementation of RingConstraint. However, the resulting function is huge and cyclomatically
			off the charts, and the conditions are significantly different for the combinations, so the final result would
			end up being even larger. Breaking into pieces duplicates some runtime effort for the combined settings,
			but the maintenance and combination enhancements are worth the tradeoff. -->
			<Constraint type="AcyclicRingVerbalizer" childHelperFor="RingConstraint" patternGroup="SetConstraint">
				<ConstrainedRoles constraintArity="2" factCount="1" sign="positive" sameConstraintRolePlayers="true" rolePlayerLimitedToConstraintRoles="true">
					<ReadingContext match="PreferLeadReading">
						<Snippet ref="ImpliedModalNecessityOperator">
							<Snippet ref="Acyclicity">
								<IterateRoles match="included" listStyle="null" pass="first"/>
								<Fact readingChoice="Context"/>
							</Snippet>
						</Snippet>
					</ReadingContext>
				</ConstrainedRoles>
				<ConstrainedRoles constraintArity="2" factCount="1" sign="positive">
					<ReadingContext match="PreferLeadReading">
						<Snippet ref="ImpliedModalNecessityOperator">
							<Snippet ref="AcyclicityWithRoleNumbers">
								<IterateRoles match="included" listStyle="null" pass="first"/>
								<Fact readingChoice="Context"/>
								<IterateRoles match="included" listStyle="null" pass="first">
									<RoleIndex/>
								</IterateRoles>
								<IterateRoles match="included" listStyle="null" pass="notFirst">
									<RoleIndex/>
								</IterateRoles>
							</Snippet>
						</Snippet>
					</ReadingContext>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="AntisymmetricRingVerbalizer" childHelperFor="RingConstraint" patternGroup="SetConstraint">
				<EnableSubscripts minFactArity="2" custom="defaultSubscript"/>
				<ConstrainedRoles constraintArity="2" factCount="1" sameConstraintRolePlayers="true" sign="positive">
					<Snippet ref="ConditionalMultiLine">
						<Snippet ref="LogicalAndOperator">
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="included">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement subscript="false">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
							<Snippet ref="SameTypeIdentityInequalityOperator">
								<IterateRoles match="constraintRoles" listStyle="null" pass="first"/>
								<IterateRoles match="constraintRoles" listStyle="null" pass="notFirst"/>
							</Snippet>
						</Snippet>
						<Snippet ref="ModalPossibilityOperator" alternateSign="negative">
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary" alternateRolePlayer="other">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" alternateRolePlayer="primary">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement subscript="false">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles constraintArity="2" factCount="1" sign="positive">
					<Snippet ref="ConditionalMultiLine">
						<Snippet ref="LogicalAndOperator">
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="included">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement subscript="false">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
							<Snippet ref="CompatibleTypesIdentityInequalityOperator">
								<IterateRoles match="constraintRoles" listStyle="null" pass="first" subscript="true"/>
								<IterateRoles match="constraintRoles" listStyle="null" pass="notFirst" subscript="true"/>
							</Snippet>
						</Snippet>
						<Snippet ref="ModalPossibilityOperator" alternateSign="negative">
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary" alternateRolePlayer="other">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" alternateRolePlayer="primary">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement subscript="false">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="AsymmetricRingVerbalizer" childHelperFor="RingConstraint" patternGroup="SetConstraint">
				<EnableSubscripts minFactArity="2" custom="defaultSubscript"/>
				<ConstrainedRoles constraintArity="2" factCount="1" sameConstraintRolePlayers="true" sign="positive">
					<Snippet ref="ConditionalMultiLine">
						<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first">
							<Fact readingChoice="ConditionalContext">
								<PredicateReplacement match="included">
									<Snippet ref="SelfReference"/>
								</PredicateReplacement>
								<PredicateReplacement subscript="false">
									<Snippet ref="ExistentialQuantifier"/>
								</PredicateReplacement>
							</Fact>
						</IterateRoles>
						<Snippet ref="ModalPossibilityOperator" alternateSign="negative">
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary" alternateRolePlayer="other">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" alternateRolePlayer="primary">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement subscript="false">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles constraintArity="2" factCount="1" sign="positive">
					<Snippet ref="ConditionalMultiLine">
						<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first">
							<Fact readingChoice="ConditionalContext">
								<PredicateReplacement match="included">
									<Snippet ref="ExistentialQuantifier"/>
								</PredicateReplacement>
								<PredicateReplacement subscript="false">
									<Snippet ref="ExistentialQuantifier"/>
								</PredicateReplacement>
							</Fact>
						</IterateRoles>
						<Snippet ref="ModalPossibilityOperator" alternateSign="negative">
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary" alternateRolePlayer="other">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" alternateRolePlayer="primary">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement subscript="false">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="IrreflexiveRingVerbalizer" childHelperFor="RingConstraint" patternGroup="SetConstraint">
				<EnableSubscripts minFactArity="2" custom="defaultPlain"/>
				<ConstrainedRoles constraintArity="2" factCount="1" sign="positive">
					<ConditionalReading>
						<ReadingChoice match="RequireLeadReadingNoFrontText">
							<Snippet ref="ImpliedModalNecessityOperator">
								<IterateRoles match="included" listStyle="null" conditionalReading="RequirePrimaryLeadReadingNoFrontText" pass="first">
									<Fact readingChoice="ConditionalContext">
										<PredicateReplacement match="primary">
											<Snippet ref="ExistentialQuantifier" alternateSign="negative"/>
										</PredicateReplacement>
										<PredicateReplacement match="secondary" alternateRolePlayer="primary">
											<Snippet ref="IdentityReferenceQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement subscript="true">
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
				<ConstrainedRoles constraintArity="2" factCount="1">
					<!-- sign="negative" is implied -->
					<ConditionalReading>
						<ReadingChoice match="RequireLeadReadingNoFrontText">
							<Snippet ref="ImpliedModalNecessityOperator">
								<IterateRoles match="included" listStyle="null" conditionalReading="RequirePrimaryLeadReadingNoFrontText" pass="first">
									<Fact readingChoice="ConditionalContext">
										<PredicateReplacement match="primary">
											<Snippet ref="ExistentialQuantifier" alternateSign="positive"/>
										</PredicateReplacement>
										<PredicateReplacement match="secondary" alternateRolePlayer="primary">
											<Snippet ref="IdentityReferenceQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement subscript="true">
											<Snippet ref="ExistentialQuantifier" alternateSign="positive"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</Snippet>
						</ReadingChoice>
						<ReadingChoice>
							<Snippet ref="ImpliedModalNecessityOperator">
								<!-- UNDONE: This is correct for binaries, but not quite right for n-aries, which need to pick
								a reading where the first role encountered in the constrained roles (not necessarily the lead role)
								matches the current primary reading. This currently gives '...same A r some A...' instead of
								'...some A r the -->
								<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first">
									<Fact readingChoice="ConditionalContext">
										<PredicateReplacement match="primary">
											<Snippet ref="ExistentialQuantifier" alternateSign="positive"/>
										</PredicateReplacement>
										<PredicateReplacement match="secondary" alternateRolePlayer="primary">
											<Snippet ref="IdentityReferenceQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement subscript="true">
											<Snippet ref="ExistentialQuantifier" alternateSign="positive"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</Snippet>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="IntransitiveRingVerbalizer" childHelperFor="RingConstraint" patternGroup="SetConstraint">
				<EnableSubscripts minFactArity="2" custom="defaultPlain"/>
				<ConstrainedRoles constraintArity="2" factCount="1" sameConstraintRolePlayers="true" sign="positive">
					<Snippet ref="ConditionalMultiLine">
						<Snippet ref="LogicalAndOperator">
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="included">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary" alternateRolePlayer="other">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" alternateRolePlayer="primary" overflowSubscript="1">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
						<Snippet ref="ModalPossibilityOperator" alternateSign="negative">
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" overflowSubscript="1">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles constraintArity="2" factCount="1" factArity="2" sign="positive">
					<!-- Section 8.4.2, binary with different role players -->
					<Snippet ref="ConditionalMultiLine">
						<Snippet ref="LogicalAndOperator">
							<IterateRoles match="included" listStyle="null" conditionalReading="RequirePrimaryLeadReading" pass="first">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" overflowSubscript="0">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
							<IterateRoles match="included" listStyle="null" conditionalReading="RequirePrimaryLeadReading" pass="first">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary" alternateRolePlayer="other" overflowSubscript="0">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" overflowSubscript="1">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
						<Snippet ref="ModalPossibilityOperator" alternateSign="negative">
							<IterateRoles match="included" listStyle="null" conditionalReading="RequirePrimaryLeadReading" pass="first">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" overflowSubscript="1">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles constraintArity="2" factCount="1" sign="positive">
					<Snippet ref="ConditionalMultiLine">
						<Snippet ref="LogicalAndOperator">
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary" alternateRolePlayer="other">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" alternateRolePlayer="primary" overflowSubscript="1">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
						<Snippet ref="ModalPossibilityOperator" alternateSign="negative">
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" alternateRolePlayer="primary" overflowSubscript="1">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="StronglyIntransitiveRingVerbalizer" childHelperFor="RingConstraint" patternGroup="SetConstraint">
				<EnableSubscripts minFactArity="2" custom="defaultSubscript"/>
				<ConstrainedRoles constraintArity="2" factCount="1" sign="positive">
						<Snippet ref="ImpliedModalNecessityOperator">
							<Snippet ref="ConditionalMultiLine">
								<IterateRoles match="included" pass="first" listStyle="null">
									<Fact readingChoice="PreferPrimaryLeadReading">
										<PredicateReplacement match="primary">
											<Snippet ref="SelfReference"/>
										</PredicateReplacement>
										<PredicateReplacement match="included">
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement match="excluded" subscript="false">
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
								<Snippet ref="StronglyIntransitiveConsequent">
									<IterateRoles match="included" pass="first" listStyle="null"/>
									<IterateRoles match="included" pass="notFirst" listStyle="null"/>
								</Snippet>
							</Snippet>
						</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="SymmetricRingVerbalizer" childHelperFor="RingConstraint" patternGroup="SetConstraint">
				<EnableSubscripts minFactArity="2" custom="defaultSubscript"/>
				<ConstrainedRoles constraintArity="2" factCount="1" sameConstraintRolePlayers="true" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="ConditionalMultiLine">
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="included">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement subscript="false">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary" alternateRolePlayer="other">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" alternateRolePlayer="primary">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement subscript="false">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles constraintArity="2" factCount="1" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="ConditionalMultiLine">
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="included">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement subscript="false">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary" alternateRolePlayer="other">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" alternateRolePlayer="primary">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement subscript="false">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="ReflexiveRingVerbalizer" childHelperFor="RingConstraint" patternGroup="SetConstraint">
				<EnableSubscripts minFactArity="2" custom="defaultSubscript"/>
				<ConstrainedRoles constraintArity="2" factCount="1" sign="positive">
					<ConditionalReading>
						<ReadingChoice match="RequireLeadReading">
							<!-- We have a lead reading for one of the constrained roles, so we know the variable
							for this role will be defined before it is referenced with 'itself'.-->
							<IterateRoles pass="first" listStyle="null" match="included" conditionalReading="RequirePrimaryLeadReading">
								<Snippet ref="ImpliedModalNecessityOperator">
									<Snippet ref="ConditionalMultiLine">
										<Fact readingChoice="ConditionalContext">
											<PredicateReplacement match="secondary">
												<Snippet ref="ExistentialQuantifier"/>
											</PredicateReplacement>
											<PredicateReplacement match="excluded" subscript="false">
												<Snippet ref="ExistentialQuantifier"/>
											</PredicateReplacement>
										</Fact>
										<Fact readingChoice="ConditionalContext">
											<PredicateReplacement match="secondary">
												<Snippet ref="ReflexivePronoun"/>
											</PredicateReplacement>
											<PredicateReplacement match="excluded" subscript="false">
												<Snippet ref="ExistentialQuantifier"/>
											</PredicateReplacement>
										</Fact>
									</Snippet>
								</Snippet>
							</IterateRoles>
						</ReadingChoice>
						<ReadingChoice>
							<!-- Use the clumsier fallback form, using 'x itself r x' -->
							<IterateRoles pass="first" listStyle="null" match="included" conditionalReading="PreferLeadReading">
								<Snippet ref="ImpliedModalNecessityOperator">
									<Snippet ref="ConditionalMultiLine">
										<Fact readingChoice="Context">
											<PredicateReplacement match="secondary">
												<Snippet ref="ExistentialQuantifier"/>
											</PredicateReplacement>
											<PredicateReplacement match="excluded" subscript="false">
												<Snippet ref="ExistentialQuantifier"/>
											</PredicateReplacement>
										</Fact>
										<Fact readingChoice="Context">
											<PredicateReplacement match="secondary" alternateRolePlayer="primary">
												<Snippet ref="ReflexiveQuantifier"/>
											</PredicateReplacement>
											<PredicateReplacement match="excluded" subscript="false">
												<Snippet ref="ExistentialQuantifier"/>
											</PredicateReplacement>
										</Fact>
									</Snippet>
								</Snippet>
							</IterateRoles>
						</ReadingChoice>
					</ConditionalReading>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="PurelyReflexiveRingVerbalizer" childHelperFor="RingConstraint" patternGroup="SetConstraint">
				<EnableSubscripts minFactArity="2" custom="defaultSubscript"/>
				<ConstrainedRoles constraintArity="2" factCount="1" sign="positive">
					<IterateRoles pass="first" listStyle="null" match="included">
						<Snippet ref="ImpliedModalNecessityOperator">
							<Snippet ref="ConditionalMultiLine">
								<Fact readingChoice="PreferLeadReading">
									<PredicateReplacement match="secondary">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
									<PredicateReplacement match="excluded" subscript="false">
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
								<IterateContextRoles listStyle="EqualsList" match="included"/>
							</Snippet>
						</Snippet>
					</IterateRoles>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="TransitiveRingVerbalizer" childHelperFor="RingConstraint" patternGroup="SetConstraint">
				<EnableSubscripts minFactArity="2" custom="defaultPlain"/>
				<ConstrainedRoles constraintArity="2" factCount="1" sameConstraintRolePlayers="true" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="ConditionalMultiLine">
							<Snippet ref="LogicalAndOperator">
								<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
									<Fact readingChoice="ConditionalContext">
										<PredicateReplacement match="included">
											<Snippet ref="SelfReference"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
								<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
									<Fact readingChoice="ConditionalContext">
										<PredicateReplacement match="primary" alternateRolePlayer="other">
											<Snippet ref="SelfReference"/>
										</PredicateReplacement>
										<PredicateReplacement match="secondary" alternateRolePlayer="primary" overflowSubscript="1">
											<Snippet ref="SelfReference"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</Snippet>
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" overflowSubscript="1">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles constraintArity="2" factCount="1" factArity="2" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="ConditionalMultiLine">
							<Snippet ref="LogicalAndOperator">
								<IterateRoles match="included" listStyle="null" conditionalReading="RequirePrimaryLeadReading" pass="first">
									<Fact readingChoice="ConditionalContext">
										<PredicateReplacement match="primary">
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement match="secondary" overflowSubscript="0">
											<Snippet ref="SelfReference"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
								<IterateRoles match="included" listStyle="null" conditionalReading="RequirePrimaryLeadReading" pass="first">
									<Fact readingChoice="ConditionalContext">
										<PredicateReplacement match="primary" alternateRolePlayer="other" overflowSubscript="0">
											<Snippet ref="SelfReference"/>
										</PredicateReplacement>
										<PredicateReplacement match="secondary" overflowSubscript="1">
											<Snippet ref="SelfReference"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</Snippet>
							<IterateRoles match="included" listStyle="null" conditionalReading="RequirePrimaryLeadReading" pass="first">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" overflowSubscript="1">
										<Snippet ref="SelfReference"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles constraintArity="2" factCount="1" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="ConditionalMultiLine">
							<Snippet ref="LogicalAndOperator">
								<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
									<Fact readingChoice="ConditionalContext">
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
								<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
									<Fact readingChoice="ConditionalContext">
										<PredicateReplacement match="primary" alternateRolePlayer="other">
											<Snippet ref="DefiniteArticle"/>
										</PredicateReplacement>
										<PredicateReplacement match="secondary" alternateRolePlayer="primary" overflowSubscript="1">
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
										<PredicateReplacement>
											<Snippet ref="ExistentialQuantifier"/>
										</PredicateReplacement>
									</Fact>
								</IterateRoles>
							</Snippet>
							<IterateRoles match="included" listStyle="null" conditionalReading="PreferPrimaryLeadReading" pass="first" subscript="true">
								<Fact readingChoice="ConditionalContext">
									<PredicateReplacement match="primary">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement match="secondary" alternateRolePlayer="primary" overflowSubscript="1">
										<Snippet ref="DefiniteArticle"/>
									</PredicateReplacement>
									<PredicateReplacement>
										<Snippet ref="ExistentialQuantifier"/>
									</PredicateReplacement>
								</Fact>
							</IterateRoles>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<Constraint type="EqualityConstraint" patternGroup="SetComparisonConstraint">
				<ConstrainedRoles columnArity="1" constraintArity="2" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="ForEachIndentedQuantifier">
							<IterateSequences listStyle="null" pass="first">
								<IterateRoles listStyle="null" match="providedConstraintRoles" pass="first" markProvidedConstraintRolesAsHead="true" minimizeProvidedConstraintRoleHeadSubscripting="true" resolveProvidedConstraintRoleSupertype="true"/>
							</IterateSequences>
							<Snippet ref="Equality">
								<IterateSequences listStyle="null" pass="first">
									<SequenceJoinPath markTrailingOutdentStart="true">
										<IterateRoles match="constraintRoles" listStyle="null" pass="first">
											<Fact readingChoice="PreferPrimaryLeadReading">
												<ProvidedPredicateReplacement match="included"  quantify="true"/>
												<ProvidedPredicateReplacement quantify="true"/>
											</Fact>
										</IterateRoles>
									</SequenceJoinPath>
								</IterateSequences>
								<IterateSequences listStyle="null" pass="notFirst">
									<SequenceJoinPath markTrailingOutdentStart="true">
										<IterateRoles match="constraintRoles" listStyle="null" pass="first">
											<Fact readingChoice="PreferPrimaryLeadReading">
												<ProvidedPredicateReplacement match="included" quantify="true"/>
												<ProvidedPredicateReplacement quantify="true"/>
											</Fact>
										</IterateRoles>
									</SequenceJoinPath>
								</IterateSequences>
							</Snippet>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles constraintArity="2" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="ForEachIndentedQuantifier">
							<IterateSequences listStyle="null" pass="first">
								<IterateRoles listStyle="SimpleLogicalAndList" match="providedConstraintRoles" markProvidedConstraintRolesAsHead="true" minimizeProvidedConstraintRoleHeadSubscripting="true" resolveProvidedConstraintRoleSupertype="true"/>
							</IterateSequences>
							<Snippet ref="Equality">
								<IterateSequences listStyle="null" pass="first">
									<SequenceJoinPath markTrailingOutdentStart="true">
										<IterateRoles match="constraintRoles" listStyle="null" pass="first">
											<Fact readingChoice="PreferPrimaryLeadReading">
												<ProvidedPredicateReplacement match="included" quantify="true"/>
												<ProvidedPredicateReplacement quantify="true"/>
											</Fact>
										</IterateRoles>
									</SequenceJoinPath>
								</IterateSequences>
								<IterateSequences listStyle="null" pass="notFirst">
									<SequenceJoinPath markTrailingOutdentStart="true">
										<IterateRoles match="constraintRoles" listStyle="null" pass="first">
											<Fact readingChoice="PreferPrimaryLeadReading">
												<ProvidedPredicateReplacement match="included" quantify="true"/>
												<ProvidedPredicateReplacement quantify="true"/>
											</Fact>
										</IterateRoles>
									</SequenceJoinPath>
								</IterateSequences>
							</Snippet>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles minConstraintArity="3" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="ForEachCompactQuantifier">
							<IterateSequences listStyle="null" pass="first">
								<IterateRoles match="providedConstraintRoles" listStyle="SimpleLogicalAndList" markProvidedConstraintRolesAsHead="true" minimizeProvidedConstraintRoleHeadSubscripting="true" resolveProvidedConstraintRoleSupertype="true"/>
							</IterateSequences>
							<Snippet ref="GroupEquality">
								<IterateSequences listStyle="MultilineIndentedCompoundList" compositeList="true">
									<SequenceJoinPath markTrailingOutdentStart="true">
										<IterateRoles match="constraintRoles" listStyle="null" uniqueFactType="true">
											<Fact readingChoice="PreferPrimaryLeadReading">
												<ProvidedPredicateReplacement match="included" quantify="true"/>
												<ProvidedPredicateReplacement quantify="true"/>
											</Fact>
										</IterateRoles>
									</SequenceJoinPath>
								</IterateSequences>
							</Snippet>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
			<!-- 
				6.1.1: Exclusion constraint but no inclusive-or constraint over the same roles 
				6.1.2: Exclusion plus Inclusive-or constraint over the same roles
			-->
			<Constraint type="ExclusionConstraint" patternGroup="SetComparisonConstraint">
				<ConstrainedRoles columnArity="1" minConstraintArity="2" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="ForEachCompactQuantifier">
							<IterateSequences listStyle="null" pass="first">
								<IterateRoles match="providedConstraintRoles" listStyle="SimpleLogicalAndList" markProvidedConstraintRolesAsHead="true" minimizeProvidedConstraintRoleHeadSubscripting="true" resolveProvidedConstraintRoleSupertype="true"/>
							</IterateSequences>
							<ConditionalSnippet>
								<Snippet ref="GroupExclusiveOr" conditionalMatch="ExclusionIsExclusiveOrConstraint"/>
								<Snippet ref="GroupExclusion"/>
								<SnippetReplacements>
									<IterateSequences listStyle="MultilineIndentedCompoundList" compositeList="true">
										<SequenceJoinPath markTrailingOutdentStart="true">
											<IterateRoles match="constraintRoles" listStyle="null" uniqueFactType="true">
												<Fact readingChoice="PreferPrimaryLeadReading">
													<ProvidedPredicateReplacement match="included" quantify="true"/>
													<ProvidedPredicateReplacement quantify="true"/>
												</Fact>
											</IterateRoles>
										</SequenceJoinPath>
									</IterateSequences>
								</SnippetReplacements>
							</ConditionalSnippet>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles factCount="2" columnArity="2" constraintArity="2" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator" conditionalBlockContext="BinaryLeadReading">
						<ConditionalSnippet>
							<Snippet conditionalMatch="IsBinaryLeadReading" ref="ExclusionBinaryLeadReading"/>
							<Snippet conditionalMatch="IsBinaryLeadReadingReverse" ref="ExclusionBinaryLeadReading"/>
							<Snippet ref="ForEachCompactQuantifier"/>
							<SnippetReplacements>
								<ConditionalReplacement>
									<Snippet ref="ExclusionCombined" conditionalMatch="IsBinaryLeadReading">
										<IterateSequences listStyle="null" pass="first">
											<IterateRoles match="providedConstraintRoles" listStyle="null" pass="first"/>
										</IterateSequences>
										<IterateSequences listStyle="SimpleLogicalAndList" compositeList="true">
											<IterateRoles match="constraintRoles" pass="first" listStyle="null">
												<Fact readingChoice="PreferPrimaryLeadReadingInfixTextOnlyNotHyphenBound">
													<PredicateReplacement>
														<Snippet ref="null"/>
													</PredicateReplacement>
												</Fact>
											</IterateRoles>
										</IterateSequences>
									</Snippet>
									<Snippet ref="ExclusionCombined" conditionalMatch="IsBinaryLeadReadingReverse">
										<IterateSequences listStyle="null" pass="first">
											<IterateRoles match="providedConstraintRoles" listStyle="null" pass="notFirst"/>
										</IterateSequences>
										<IterateSequences listStyle="SimpleLogicalAndList" compositeList="true">
											<IterateRoles match="constraintRoles" pass="notFirst" listStyle="null">
												<Fact readingChoice="PreferPrimaryLeadReadingInfixTextOnlyNotHyphenBound">
													<PredicateReplacement>
														<Snippet ref="null"/>
													</PredicateReplacement>
												</Fact>
											</IterateRoles>
										</IterateSequences>
									</Snippet>
									<IterateSequences listStyle="null" pass="first">
										<IterateRoles match="providedConstraintRoles" listStyle="SimpleLogicalAndList" markProvidedConstraintRolesAsHead="true" minimizeProvidedConstraintRoleHeadSubscripting="true" resolveProvidedConstraintRoleSupertype="true"/>
									</IterateSequences>
								</ConditionalReplacement>
								<ConditionalReplacement>
									<IterateSequences listStyle="null" pass="first" conditionalMatch="IsBinaryLeadReading">
										<IterateRoles match="providedConstraintRoles" listStyle="null" pass="notFirst"/>
									</IterateSequences>
									<IterateSequences listStyle="null" pass="first" conditionalMatch="IsBinaryLeadReadingReverse">
										<IterateRoles match="providedConstraintRoles" listStyle="null" pass="first"/>
									</IterateSequences>
									<Snippet ref="GroupExclusion">
										<IterateSequences listStyle="MultilineIndentedCompoundList" compositeList="true">
											<SequenceJoinPath markTrailingOutdentStart="true">
												<IterateRoles match="constraintRoles" listStyle="null" uniqueFactType="true">
													<Fact>
														<ProvidedPredicateReplacement match="included" quantify="true"/>
														<ProvidedPredicateReplacement quantify="true"/>
													</Fact>
												</IterateRoles>
											</SequenceJoinPath>
										</IterateSequences>
									</Snippet>
								</ConditionalReplacement>
							</SnippetReplacements>
						</ConditionalSnippet>
					</Snippet>
				</ConstrainedRoles>
				<ConstrainedRoles minConstraintArity="2" sign="positive">
					<Snippet ref="ImpliedModalNecessityOperator">
						<Snippet ref="ForEachCompactQuantifier">
							<IterateSequences listStyle="null" pass="first">
								<IterateRoles match="providedConstraintRoles" listStyle="SimpleLogicalAndList" markProvidedConstraintRolesAsHead="true" minimizeProvidedConstraintRoleHeadSubscripting="true" resolveProvidedConstraintRoleSupertype="true"/>
							</IterateSequences>
							<Snippet ref="GroupExclusion">
								<IterateSequences listStyle="MultilineIndentedCompoundList" compositeList="true">
									<SequenceJoinPath markTrailingOutdentStart="true">
										<IterateRoles match="constraintRoles" listStyle="null" uniqueFactType="true">
											<Fact readingChoice="PreferPrimaryLeadReading">
												<ProvidedPredicateReplacement match="included" quantify="true"/>
												<ProvidedPredicateReplacement quantify="true"/>
											</Fact>
										</IterateRoles>
									</SequenceJoinPath>
								</IterateSequences>
							</Snippet>
						</Snippet>
					</Snippet>
				</ConstrainedRoles>
			</Constraint>
		</Constraints>
		<SampleInstances>
			<SingleSnippet type="FactTypeInstanceBlockStart" childHelperFor="FactType" snippetRef="FactTypeInstanceBlockStart"/>
			<SingleSnippet type="FactTypeInstanceBlockEnd" childHelperFor="FactType" snippetRef="FactTypeInstanceBlockEnd"/>
			<SampleInstance type="FactTypeInstanceVerbalizer" childHelperFor="FactType">
				<!-- UNDONE: Collapse this to use a mechanism similar to ObjectTypeInstanceVerbalizer.
				IterateInstances should support a FactType parent, and the BlockStart/BlockEnd snippets
				should be folded into a normal listStyle. -->
				<FactInstance/>
				<Snippet ref="FactTypeInstanceIdentifier" conditionalMatch="ObjectifyingInstance">
					<ObjectifyingInstanceIdentifierName/>
				</Snippet>
			</SampleInstance>
			<SampleInstance type="ObjectTypeInstanceVerbalizer" childHelperFor="ObjectType">
				<IterateInstances listStyle="ObjectTypeInstanceList">
					<ObjectTypeInstanceValue/>
				</IterateInstances>
			</SampleInstance>
		</SampleInstances>
	</Constructs>
</VerbalizationRoot>